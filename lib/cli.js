var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = {exports: {}}).exports, mod), mod.exports;
};

// .pnpm/color-name@1.1.4/node_modules/color-name/index.js
var require_color_name = __commonJS({
  ".pnpm/color-name@1.1.4/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// .pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  ".pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: {channels: 3, labels: "rgb"},
      hsl: {channels: 3, labels: "hsl"},
      hsv: {channels: 3, labels: "hsv"},
      hwb: {channels: 3, labels: "hwb"},
      cmyk: {channels: 4, labels: "cmyk"},
      xyz: {channels: 3, labels: "xyz"},
      lab: {channels: 3, labels: "lab"},
      lch: {channels: 3, labels: "lch"},
      hex: {channels: 1, labels: ["hex"]},
      keyword: {channels: 1, labels: ["keyword"]},
      ansi16: {channels: 1, labels: ["ansi16"]},
      ansi256: {channels: 1, labels: ["ansi256"]},
      hcg: {channels: 3, labels: ["h", "c", "g"]},
      apple: {channels: 3, labels: ["r16", "g16", "b16"]},
      gray: {channels: 1, labels: ["gray"]}
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const {channels, labels} = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", {value: channels});
      Object.defineProperty(convert[model], "labels", {value: labels});
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// .pnpm/color-convert@2.0.1/node_modules/color-convert/route.js
var require_route = __commonJS({
  ".pnpm/color-convert@2.0.1/node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// .pnpm/color-convert@2.0.1/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  ".pnpm/color-convert@2.0.1/node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", {value: conversions[fromModel].channels});
      Object.defineProperty(convert[fromModel], "labels", {value: conversions[fromModel].labels});
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// .pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  ".pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `[${style[0]}m`,
            close: `[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "[39m";
      styles.bgColor.close = "[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// .pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  ".pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// .pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  ".pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var {env} = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// .pnpm/chalk@4.1.0/node_modules/chalk/source/util.js
var require_util = __commonJS({
  ".pnpm/chalk@4.1.0/node_modules/chalk/source/util.js"(exports2, module2) {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// .pnpm/chalk@4.1.0/node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  ".pnpm/chalk@4.1.0/node_modules/chalk/source/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", ""],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk2, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk2;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk2, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk2, styles)(string));
          styles.push({inverse, styles: parseStyle(style)});
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk2, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// .pnpm/chalk@4.1.0/node_modules/chalk/source/index.js
var require_source = __commonJS({
  ".pnpm/chalk@4.1.0/node_modules/chalk/source/index.js"(exports2, module2) {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var {stdout: stdoutColor, stderr: stderrColor} = require_supports_color();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util();
    var {isArray} = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk3 = {};
      applyOptions(chalk3, options);
      chalk3.template = (...arguments_) => chalkTag(chalk3.template, ...arguments_);
      Object.setPrototypeOf(chalk3, Chalk.prototype);
      Object.setPrototypeOf(chalk3.template, chalk3);
      chalk3.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk3.template.Instance = ChalkClass;
      return chalk3.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, {value: builder});
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", {value: builder});
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const {level} = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const {level} = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, __spreadProps(__spreadValues({}, styles), {
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    }));
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self, string) => {
      if (self.level <= 0 || !string) {
        return self._isEmpty ? "" : string;
      }
      let styler = self._styler;
      if (styler === void 0) {
        return string;
      }
      const {openAll, closeAll} = styler;
      if (string.indexOf("") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk3, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk3, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk2 = Chalk();
    chalk2.supportsColor = stdoutColor;
    chalk2.stderr = Chalk({level: stderrColor ? stderrColor.level : 0});
    chalk2.stderr.supportsColor = stderrColor;
    module2.exports = chalk2;
  }
});

// lib/package-82f828d2.js
var require_package_82f828d2 = __commonJS({
  "lib/package-82f828d2.js"(exports2) {
    "use strict";
    var version = "0.0.0";
    exports2.version = version;
  }
});

// lib/DeploymentManager-b2827254.js
var require_DeploymentManager_b2827254 = __commonJS({
  "lib/DeploymentManager-b2827254.js"(exports2) {
    "use strict";
    var chalk2 = require_source();
    var CP = require("child_process");
    var FS2 = require("fs");
    var OS = require("os");
    var Path2 = require("path");
    var Util = require("util");
    function _interopDefaultLegacy2(e) {
      return e && typeof e === "object" && "default" in e ? e : {"default": e};
    }
    function _interopNamespace2(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var chalk__default2 = /* @__PURE__ */ _interopDefaultLegacy2(chalk2);
    var CP__namespace = /* @__PURE__ */ _interopNamespace2(CP);
    var FS__namespace2 = /* @__PURE__ */ _interopNamespace2(FS2);
    var OS__namespace = /* @__PURE__ */ _interopNamespace2(OS);
    var Path__namespace2 = /* @__PURE__ */ _interopNamespace2(Path2);
    var Util__namespace = /* @__PURE__ */ _interopNamespace2(Util);
    function quote(text) {
      return JSON.stringify(text);
    }
    var Exception = class extends Error {
      constructor(code, message = code) {
        super(message);
        this.code = code;
      }
    };
    var FileNotFoundException = class extends Exception {
      constructor(fileName) {
        super("FileNotFound", `No such file ${quote(fileName)}`);
        this.fileName = fileName;
      }
    };
    function uuid() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    }
    function areObjectsEqual(a, b, depth = 0) {
      if (typeof a !== typeof b)
        return false;
      const type = typeof a;
      if (type === "object") {
        if (a === null || b === null) {
          return a === b;
        }
        if (depth > 20)
          throw new Exception("PossibleCircularObject");
        if (Array.isArray(a) || Array.isArray(b)) {
          if (Array.isArray(a) && Array.isArray(b)) {
            if (a.length !== b.length)
              return false;
            return a.every((_, index) => areObjectsEqual(a[index], b[index], depth + 1));
          }
          return false;
        }
        const keys = Object.keys(a);
        if (keys.length !== Object.keys(b).length)
          return false;
        return keys.every((key) => areObjectsEqual(a[key], b[key], depth + 1));
      }
      return a === b;
    }
    function getCreatedAt() {
      return new Date().toISOString();
    }
    async function importJSON(configFile) {
      const contents = await FS__namespace2.promises.readFile(configFile, "utf-8");
      try {
        return JSON.parse(contents);
      } catch (error) {
        throw new Exception("InvalidJSONObject", error.message);
      }
    }
    var AppManager = class {
      constructor(app, manifest, sh) {
        this.app = app;
        this.manifest = manifest;
        this.sh = sh;
        this.appDir = Path__namespace2.dirname(this.manifest);
      }
      async saveManifest() {
        await this.sh.write(this.manifest, JSON.stringify(this.app, null, 2));
      }
      async withManifestSync(fn) {
        const app = JSON.parse(JSON.stringify(this.app));
        try {
          const result = await fn();
          await this.saveManifest();
          return result;
        } catch (error) {
          if (!areObjectsEqual(app, this.app)) {
            FS__namespace2.promises.writeFile("deploy-debug.log", [
              `===== Current Manifest ====`,
              JSON.stringify(app, null, 2),
              `===== Unsaved Manifest ====`,
              JSON.stringify(this.app, null, 2)
            ].join("\n") + "\n");
            console.warn(chalk__default2["default"].yellow(chalk__default2["default"].bold("CommandFailure: ", "reverting app manifest to previous state.")));
          }
          throw error;
        }
      }
      async createCertificates() {
        const cmd = (await this.instances()).length > 0 ? "run --installer nginx" : "certonly";
        const args = `-n --agree-tos --dns-digitalocean --dns-digitalocean-credentials /root/.secrets/certbot/digitalocean.ini`;
        const certFile = (domain) => `/etc/letsencrypt/live/${domain}/fullchain.pem`;
        const certbot = (domain, wildCard = true) => `test -f ${quote(certFile(domain))} || certbot ${cmd} ${args} -m ${quote(this.app.domain.email)} -d ${quote(domain)} ${wildCard ? `-d ${quote(`*.${domain}`)}` : ""};`;
        await this.sh.exec([certbot(this.app.domain.primary), ...this.app.domain.aliases.map((alias) => certbot(alias))].join("\n"));
      }
      async createRelease(options, asset) {
        if (!Path__namespace2.isAbsolute(asset))
          asset = Path__namespace2.resolve(process.cwd(), asset);
        const stat = await FS__namespace2.promises.stat(asset);
        let assetFilename = asset;
        if (stat.isFile()) {
          const {stderr} = await Util__namespace.promisify(CP__namespace.exec)(`tar -tzf  ${quote(asset)}`);
          if (stderr.trim().length > 0) {
            throw new Exception("InvalidArchive", stderr);
          }
        } else if (stat.isDirectory()) {
          const pkg = await importJSON(Path__namespace2.resolve(asset, "package.json"));
          assetFilename = Path__namespace2.resolve(asset, `${pkg.name}-${pkg.version}.tgz`.replace("@", "").replace("/", "-"));
          const cmd = `npm pack`;
          console.log(chalk__default2["default"].gray(chalk__default2["default"].bold("Execute (localhost): "), cmd));
          const {stderr} = await Util__namespace.promisify(CP__namespace.exec)(cmd, {
            env: __spreadProps(__spreadValues({}, process.env), {COPYFILE_DISABLE: "true"}),
            cwd: asset
          });
          if (stderr.trim().length > 0) {
            throw new Exception("InvalidArchive", stderr);
          }
        }
        const release = {
          id: this.app.releases.length > 0 ? this.app.releases[0].id + 1 : 1,
          commit: options.commit,
          tag: options.tag,
          createdAt: getCreatedAt()
        };
        return this.withManifestSync(async () => {
          await this.sh.upload(assetFilename, Path__namespace2.join(this.appDir, "releases", `v${release.id}.tar.gz`));
          this.log(`Create release v${release.id} from ${this.app.repository}/commit/${release.commit} (version: ${release.tag})`);
          this.app.releases.unshift(release);
          return release;
        });
      }
      log(line) {
        this.app.changelog.push({
          info: `${OS__namespace.userInfo().username}@${OS__namespace.hostname()}`,
          message: line,
          timestamp: getCreatedAt()
        });
      }
      async setEnv(key, value) {
        return this.withManifestSync(async () => {
          if (!/^[a-z][a-z0-9_]*$/.test(key))
            throw new Exception("InvalidEnvironmentVariableName", `Invalid characters in environment variable name: ${key}`);
          await this.sh.exec([
            `sed -i ${quote(`/^${key}=.*$//g`)} ${this.appDir}/.env`,
            `echo ${quote(`${key}=${quote(value)}
`)} >> ${this.appDir}/.env`
          ].join("\n"));
          if (!this.app.env.includes(key)) {
            this.app.env.push(key);
            this.log(`Set environment variables ${quote(key)}`);
          } else {
            this.log(`Update environment variables ${quote(key)}`);
          }
        });
      }
      async instances() {
        return this.app.deployments.current;
      }
      async getInstance(instanceId) {
        return this.app.deployments.current.find((instance) => instance.id === instanceId);
      }
      async getInstancesByReleaseId(releaseId) {
        return this.app.deployments.current.filter((instance) => instance.releaseId === releaseId);
      }
      async getRelease(releaseId) {
        return this.app.releases.find((release) => release.id === releaseId);
      }
      async getReleasesByTag(tag) {
        return this.app.releases.filter((release) => release.tag === tag);
      }
      async current() {
        const id = this.app.deployments.active;
        if (id != null) {
          return this.app.deployments.current.find((instance) => instance.id === id);
        }
      }
      async createInstance(releaseId) {
        const release = this.app.releases.find((release2) => release2.id);
        if (release == null)
          throw new Exception("UnknownRelease", `Cannot find release v${releaseId}`);
        return this.withManifestSync(async () => {
          const id = uuid();
          const usedPorts = this.app.deployments.current.map((instance2) => instance2.internal.port);
          usedPorts.sort((a, b) => a - b);
          let port = 3e3;
          for (const usedPort of usedPorts) {
            if (usedPort > port)
              break;
            port++;
          }
          const directory = `${this.appDir}/instances/${id}`;
          const logs = `/var/log/${this.app.name}/${id}.log`;
          const errors = `/var/log/${this.app.name}/${id}-error.log`;
          const instance = {
            id,
            releaseId,
            preview: `https://preview-${id}.${this.app.domain.primary}/`,
            createdAt: getCreatedAt(),
            internal: {
              directory,
              port,
              logs,
              errors
            }
          };
          const artefact = `${this.appDir}/releases/v${releaseId}.tar.gz`;
          if (!await this.sh.exists(artefact)) {
            throw new Exception("MissingReleaseArtefact", `Cannot find artefact for release v${releaseId}`);
          }
          const supervisorFile = `/etc/supervisor/conf.d/${this.app.name}-${id}.conf`;
          const supervisorConfig = [
            `[program:${this.app.name}-${id}]`,
            `directory=${directory}/package`,
            `command=bash -c "set -a; source ${this.appDir}/.env; set +a; n auto; npm start"`,
            `stderr_logfile=${logs}`,
            `stdout_logfile=${errors}`,
            `user=appuser`,
            `stopasgroup=true`
          ].join("\n") + "\n";
          const nginxFile = `/etc/nginx/sites-enabled/${instance.id}.${this.app.domain.primary}.conf`;
          const nginxConfig = [
            `upstream ${this.app.name}-${instance.id} {`,
            `  server 127.0.0.1:${port};`,
            `  keepalive 64;`,
            `}`,
            `server {`,
            `  listen 80;`,
            `  server_name preview-${instance.id}.${this.app.domain.primary};`,
            `  return 301 https://$host$request_uri;`,
            `}`,
            `server {`,
            `  listen 443 ssl;`,
            `  server_name preview-${instance.id}.${this.app.domain.primary};`,
            `  ssl_certificate /etc/letsencrypt/live/${this.app.domain.primary}/fullchain.pem;`,
            `  ssl_certificate_key /etc/letsencrypt/live/${this.app.domain.primary}/privkey.pem;`,
            `  include /etc/deploy/nginx/options-ssl.conf;`,
            `  location / {`,
            `    proxy_redirect     off;`,
            `    proxy_set_header   X-Real-IP          $remote_addr;`,
            `    proxy_set_header   X-Forwarded-For    $proxy_add_x_forwarded_for;`,
            `    proxy_set_header   X-Forwarded-Proto  $scheme;`,
            `    proxy_set_header   Host               $http_host;`,
            `    proxy_set_header   X-NginX-Proxy      true;`,
            `    proxy_set_header   Connection         "";`,
            `    proxy_http_version 1.1;`,
            `    proxy_pass         http://${this.app.name}-${instance.id};`,
            `  }`,
            `}`
          ].join("\n") + "\n";
          this.app.deployments.current.push(instance);
          this.app.deployments.history.unshift({
            active: this.app.deployments.active,
            deployments: this.app.deployments.current.map((instance2) => instance2.id),
            createdAt: getCreatedAt()
          });
          this.app.deployments.history = this.app.deployments.history.slice(0, this.app.config.maxDeploymentHistory);
          await this.sh.exec([
            `type n || npm install --global n`,
            `mkdir -p ${quote(Path__namespace2.dirname(logs))}`,
            `mkdir -p ${quote(directory)}`,
            `tar -zxf ${quote(artefact)} -C ${quote(directory)}`,
            `cat <<- 'EOF' > ${quote(supervisorFile)}
${supervisorConfig}
EOF
`,
            `cat <<- 'EOF' > ${quote(nginxFile)}
${nginxConfig}
EOF
`,
            `supervisorctl reread`,
            `supervisorctl update`,
            `nginx -t`
          ].join("\n"));
          await this.createCertificates();
          await this.sh.exec("service nginx reload");
          this.log(`Create new app instance ${quote(instance.id)} from release v${releaseId}.`);
          return instance;
        });
      }
      async start(instanceId) {
        await this.withManifestSync(async () => {
          this.log(`Start app instance ${this.app.name}-${instanceId}`);
          await this.sh.exec(`supervisorctl start ${this.app.name}-${instanceId}`);
        });
      }
      async restart(instanceId) {
        await this.withManifestSync(async () => {
          this.log(`Restart app instance ${this.app.name}-${instanceId}`);
          await this.sh.exec(`supervisorctl restart ${this.app.name}-${instanceId}`);
        });
      }
      async status(instanceId) {
        return await this.withManifestSync(async () => {
          this.log(`Status app instance ${this.app.name}-${instanceId}`);
          const statusText = await this.sh.execNoFail(`supervisorctl status ${this.app.name}-${instanceId}`);
          if (statusText != null) {
            const match = /^[\S]+\s+([\S]+)\s+(.*)$/i.exec(statusText.trim());
            return match == null ? {status: "UNKNOWN", text: statusText} : {status: match[1], text: statusText};
          }
          return {status: "SSH_ERROR", text: "Error in SSH command."};
        });
      }
      async stop(instanceId) {
        await this.withManifestSync(async () => {
          this.log(`Stop app instance ${this.app.name}-${instanceId}`);
          await this.sh.exec(`supervisorctl stop ${this.app.name}-${instanceId}`);
        });
      }
      async destroyRelease(releaseId) {
        await this.withManifestSync(async () => {
          const release = await this.getRelease(releaseId);
          if (release == null) {
            throw new Exception("UnknownRelease", `There is no such release.`);
          }
          const instances = await this.instances();
          const matchedInstances = instances.filter((instance) => instance.releaseId === releaseId);
          if (matchedInstances.length > 0) {
            throw new Exception("ReleaseInUse", `There are ${matchedInstances.length} active instance(s).`);
          }
          this.app.releases = this.app.releases.filter((release2) => release2.id !== releaseId);
          await this.sh.exec(`
        rm -f ${quote(`${this.appDir}/releases/v${release.id}.tar.gz`)};
      `);
          this.log(`Delete release v${release.id}`);
        });
      }
      async destroyInstance(instanceId) {
        const supervisorFile = `/etc/supervisor/conf.d/${this.app.name}-${instanceId}.conf`;
        const nginxFile = `/etc/nginx/sites-enabled/${instanceId}.${this.app.domain.primary}.conf`;
        await this.withManifestSync(async () => {
          const instance = await this.getInstance(instanceId);
          const instances = await this.instances();
          if (instance == null)
            throw new Exception("UnknownAppInstance", `No such instance: ${instanceId}`);
          this.app.deployments.current = instances.filter((instance2) => instance2.id !== instanceId);
          this.app.deployments.history.push(this.createHistoryItem());
          await this.sh.exec(`
        rm -f ${quote(supervisorFile)};
        rm -f ${quote(nginxFile)};
        rm -rf ${quote(instance.internal.directory)};
        supervisorctl reread;
        supervisorctl update;
        service nginx reload;
      `);
          this.log(`Destroy app instance ${this.app.name}-${instanceId}`);
        });
      }
      createHistoryItem() {
        return {
          active: this.app.deployments.active,
          deployments: this.app.deployments.current.map((instance) => instance.id),
          createdAt: getCreatedAt()
        };
      }
      async logs(instanceId) {
        throw new Error("Unimplemented");
      }
      async deploy(instanceId) {
        const instance = await this.getInstance(instanceId);
        if (instance == null)
          throw new Exception("UnknownAppInstance");
        return await this.withManifestSync(async () => {
          this.app.deployments.active = instanceId;
          const historyItem = this.createHistoryItem();
          const config = [
            `server {`,
            `  listen 80;`,
            `  server_name ${this.app.domain.primary} ${this.app.domain.aliases.join(" ")};`,
            `  return 301 https://$host$request_uri;`,
            `}`,
            `server {`,
            `  listen 443 ssl;`,
            `  server_name ${this.app.domain.primary} ${this.app.domain.aliases.join(" ")};`,
            `  ssl_certificate /etc/letsencrypt/live/${this.app.domain.primary}/fullchain.pem;`,
            `  ssl_certificate_key /etc/letsencrypt/live/${this.app.domain.primary}/privkey.pem;`,
            `  include /etc/deploy/nginx/options-ssl.conf`,
            `  location / {`,
            `    proxy_redirect     off;`,
            `    proxy_set_header   X-Real-IP          $remote_addr;`,
            `    proxy_set_header   X-Forwarded-For    $proxy_add_x_forwarded_for;`,
            `    proxy_set_header   X-Forwarded-Proto  $scheme;`,
            `    proxy_set_header   Host               $http_host;`,
            `    proxy_set_header   X-NginX-Proxy      true;`,
            `    proxy_set_header   Connection         "";`,
            `    proxy_http_version 1.1;`,
            `    proxy_pass         http://${this.app.name}-${instance.id};`,
            `  }`,
            `}`
          ].join("\n") + "\n";
          await this.sh.exec([
            `cat <<- 'EOF' > /etc/nginx/sites-enabled/${this.app.name}.conf
${config}
EOF
`,
            `service nginx reload`
          ].join("\n") + "\n");
          return historyItem;
        });
      }
      async rollback() {
        var _a;
        if (this.app.deployments.history.length === 0)
          throw new Exception("NoHistoryFound");
        const lastVersion = this.app.deployments.history[0].active;
        if (lastVersion == null)
          throw new Exception("NoDeploymentFound");
        const instance = await this.getInstance(lastVersion);
        if (instance == null)
          throw new Exception("NoDeploymentFound");
        this.log(`Rollback from ${quote((_a = this.app.deployments.active) !== null && _a !== void 0 ? _a : "none")} to ${quote(instance.id)}`);
        return await this.deploy(lastVersion);
      }
    };
    var SSHClient = class {
      constructor(server) {
        var _a, _b;
        this.binSSH = (_a = process.env.SSH_BIN_PATH) !== null && _a !== void 0 ? _a : "/usr/bin/ssh";
        this.binSCP = (_b = process.env.SCP_BIN_PATH) !== null && _b !== void 0 ? _b : "/usr/bin/scp";
        this.server = __spreadValues({
          port: 22,
          user: "root",
          privateKey: "~/.ssh/id_rsa",
          appsDirectory: "/apps"
        }, server);
        if (process.env.DEPLOYER_SSH_KEY != null) {
          this.server.privateKey = Path__namespace2.resolve(OS__namespace.tmpdir(), "deployer", Date.now() + ".pem");
          FS__namespace2.mkdirSync(Path__namespace2.dirname(this.server.privateKey), {recursive: true});
          FS__namespace2.writeFileSync(this.server.privateKey, process.env.DEPLOYER_SSH_KEY, {mode: 384, encoding: "utf8"});
        }
      }
      async ls(expr) {
        const output = await this.exec(`find ${quote(expr)} -mindepth 1 -maxdepth 1 -type d`);
        const lines = output.trim().split(/\r?\n/);
        return lines.map((line) => line.trim());
      }
      async mkdir(path) {
        await this.exec(`mkdir -p ${quote(path)}`);
      }
      async exists(file) {
        const result = (await this.exec(`
      test -f ${quote(file)} && echo 'file'  || echo ''
      test -d ${quote(file)} && echo 'dir'   || echo ''
      `)).trim();
        return result === "file" || result === "dir";
      }
      async read(file) {
        if (await this.exists(file)) {
          const output = await this.exec(`cat ${quote(file)}`);
          return output;
        }
        throw new FileNotFoundException(file);
      }
      async write(file, contents) {
        console.debug(chalk__default2["default"].gray(`Writing file: ${chalk__default2["default"].bold(file)}`));
        await this.exec(`cat <<- EOF > ${quote(file)}
${contents}
EOF
`);
      }
      async readJSON(file) {
        return JSON.parse(await this.read(file));
      }
      async upload(localFile, remoteFile) {
        try {
          console.debug(chalk__default2["default"].gray(chalk__default2["default"].bold(`Upload (${this.server.host}): `), localFile, " to ", remoteFile));
          const {stdout, stderr} = await Util__namespace.promisify(CP__namespace.exec)(`${this.binSCP} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -q -i ${quote(this.server.privateKey)} -P ${this.server.port} ${quote(localFile)} ${this.server.user}@${this.server.host}:${quote(remoteFile)}`);
          if (stderr !== "")
            console.error(chalk__default2["default"].red(stderr));
          if (stdout !== "")
            console.log(chalk__default2["default"].gray(stdout));
        } catch (error) {
          throw new Exception("SCPError", error.message);
        }
      }
      async exec(script) {
        try {
          console.debug(chalk__default2["default"].gray(chalk__default2["default"].bold(`Execute (${this.server.host}): `), script));
          const boundary = `END_OF_SCRIPT_${Date.now()}`;
          const outputBoundary = `-------------SSH-OUTPUT-----`;
          const {stdout, stderr} = await Util__namespace.promisify(CP__namespace.exec)(`${this.binSSH} -T -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ${quote(this.server.privateKey)} -p ${this.server.port} ${this.server.user}@${this.server.host} <<'${boundary}'
echo ${quote(outputBoundary)};
` + script + "\n" + boundary + "\n");
          if (stderr !== "")
            console.error(chalk__default2["default"].red(stderr));
          const index = stdout.indexOf(outputBoundary);
          if (index >= 0)
            return stdout.substr(index + outputBoundary.length + 1);
          return stdout;
        } catch (error) {
          throw new Exception("SCPError", error.message);
        }
      }
      async execNoFail(script) {
        try {
          return await this.exec(script);
        } catch (_a) {
          return null;
        }
      }
    };
    var DeploymentManager2 = class {
      constructor(server) {
        var _a;
        this.server = server;
        this.appsDir = (_a = this.server.appsDirectory) !== null && _a !== void 0 ? _a : "/apps";
        this.sh = new SSHClient(this.server);
      }
      async info() {
        const node = await this.sh.execNoFail(`node --version`);
        const npm = await this.sh.execNoFail(`npm --version`);
        const tar = await this.sh.execNoFail(`tar --version`);
        const nginx = await this.sh.execNoFail(`nginx -v 2>&1`);
        const curl = await this.sh.execNoFail(`curl --version`);
        const user = await this.sh.execNoFail(`id -u appuser`);
        const supervisor = await this.sh.execNoFail(`supervisord --version`);
        const certbot = await this.sh.execNoFail(`certbot --version`);
        return {node, npm, tar, nginx, curl, user, certbot, supervisor};
      }
      async apps() {
        if (await this.sh.exists(this.appsDir)) {
          const files = await this.sh.ls(this.appsDir);
          const prefixLength = this.appsDir.length + 1;
          return files.map((file) => file.substr(prefixLength));
        }
        return [];
      }
      async connect(app) {
        try {
          const manifestFile = `${this.appsDir}/${app}/deploy.json`;
          const manifest = await this.sh.readJSON(manifestFile);
          return new AppManager(manifest, manifestFile, this.sh);
        } catch (error) {
          if (error instanceof FileNotFoundException) {
            throw new Exception("AppNotFound", `No such app: ${quote(app)}`);
          }
          throw error;
        }
      }
      async create(options) {
        var _a, _b, _c, _d, _e, _f;
        if (await this.sh.exists(`${this.appsDir}/${options.name}/deploy.json`)) {
          throw new Exception("DuplicateApp", `Another app with name (${quote(options.name)}) already exists.`);
        }
        const manifest = {
          name: options.name,
          repository: (_a = options.repository) !== null && _a !== void 0 ? _a : "",
          domain: {
            email: (_b = options.email) !== null && _b !== void 0 ? _b : `certbot-notif@${options.domain}`,
            primary: options.domain,
            aliases: (_c = options.domainAliases) !== null && _c !== void 0 ? _c : []
          },
          healthcheck: (_d = options.healthcheck) !== null && _d !== void 0 ? _d : "curl -sSf http://localhost:${PORT}/health",
          releases: [],
          deployments: {
            current: [],
            history: []
          },
          changelog: [],
          config: {
            maxReleases: (_e = options.maxReleases) !== null && _e !== void 0 ? _e : 10,
            maxDeploymentHistory: (_f = options.maxDeploymentHistory) !== null && _f !== void 0 ? _f : 100
          },
          env: []
        };
        await this.check();
        await this.sh.mkdir(`/apps/${manifest.name}`);
        await this.sh.mkdir(`/apps/${manifest.name}/releases`);
        await this.sh.mkdir(`/apps/${manifest.name}/deployments`);
        await this.sh.write(`/apps/${manifest.name}/.env`, ``);
        await this.sh.write(`/apps/${manifest.name}/deploy.json`, JSON.stringify(manifest, null, 2));
        const connection = await this.connect(manifest.name);
        await connection.createCertificates();
        return connection;
      }
      async check() {
        const tools = Object.entries(await this.info()).filter(([_, version]) => version == null).map(([tool]) => tool);
        if (tools.length > 0) {
          throw new Exception("UnsupportedServer", `Missing required programs: ${tools.join(", ")}`);
        }
      }
    };
    exports2.AppManager = AppManager;
    exports2.DeploymentManager = DeploymentManager2;
    exports2.Exception = Exception;
    exports2.SSHClient = SSHClient;
    exports2.importJSON = importJSON;
    exports2.quote = quote;
  }
});

// .pnpm/y18n@5.0.8/node_modules/y18n/build/index.cjs
var require_build = __commonJS({
  ".pnpm/y18n@5.0.8/node_modules/y18n/build/index.cjs"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var util = require("util");
    var path = require("path");
    var shim;
    var Y18N = class {
      constructor(opts) {
        opts = opts || {};
        this.directory = opts.directory || "./locales";
        this.updateFiles = typeof opts.updateFiles === "boolean" ? opts.updateFiles : true;
        this.locale = opts.locale || "en";
        this.fallbackToLanguage = typeof opts.fallbackToLanguage === "boolean" ? opts.fallbackToLanguage : true;
        this.cache = Object.create(null);
        this.writeQueue = [];
      }
      __(...args) {
        if (typeof arguments[0] !== "string") {
          return this._taggedLiteral(arguments[0], ...arguments);
        }
        const str = args.shift();
        let cb = function() {
        };
        if (typeof args[args.length - 1] === "function")
          cb = args.pop();
        cb = cb || function() {
        };
        if (!this.cache[this.locale])
          this._readLocaleFile();
        if (!this.cache[this.locale][str] && this.updateFiles) {
          this.cache[this.locale][str] = str;
          this._enqueueWrite({
            directory: this.directory,
            locale: this.locale,
            cb
          });
        } else {
          cb();
        }
        return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args));
      }
      __n() {
        const args = Array.prototype.slice.call(arguments);
        const singular = args.shift();
        const plural = args.shift();
        const quantity = args.shift();
        let cb = function() {
        };
        if (typeof args[args.length - 1] === "function")
          cb = args.pop();
        if (!this.cache[this.locale])
          this._readLocaleFile();
        let str = quantity === 1 ? singular : plural;
        if (this.cache[this.locale][singular]) {
          const entry = this.cache[this.locale][singular];
          str = entry[quantity === 1 ? "one" : "other"];
        }
        if (!this.cache[this.locale][singular] && this.updateFiles) {
          this.cache[this.locale][singular] = {
            one: singular,
            other: plural
          };
          this._enqueueWrite({
            directory: this.directory,
            locale: this.locale,
            cb
          });
        } else {
          cb();
        }
        const values = [str];
        if (~str.indexOf("%d"))
          values.push(quantity);
        return shim.format.apply(shim.format, values.concat(args));
      }
      setLocale(locale) {
        this.locale = locale;
      }
      getLocale() {
        return this.locale;
      }
      updateLocale(obj) {
        if (!this.cache[this.locale])
          this._readLocaleFile();
        for (const key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            this.cache[this.locale][key] = obj[key];
          }
        }
      }
      _taggedLiteral(parts, ...args) {
        let str = "";
        parts.forEach(function(part, i) {
          const arg = args[i + 1];
          str += part;
          if (typeof arg !== "undefined") {
            str += "%s";
          }
        });
        return this.__.apply(this, [str].concat([].slice.call(args, 1)));
      }
      _enqueueWrite(work) {
        this.writeQueue.push(work);
        if (this.writeQueue.length === 1)
          this._processWriteQueue();
      }
      _processWriteQueue() {
        const _this = this;
        const work = this.writeQueue[0];
        const directory = work.directory;
        const locale = work.locale;
        const cb = work.cb;
        const languageFile = this._resolveLocaleFile(directory, locale);
        const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
        shim.fs.writeFile(languageFile, serializedLocale, "utf-8", function(err) {
          _this.writeQueue.shift();
          if (_this.writeQueue.length > 0)
            _this._processWriteQueue();
          cb(err);
        });
      }
      _readLocaleFile() {
        let localeLookup = {};
        const languageFile = this._resolveLocaleFile(this.directory, this.locale);
        try {
          if (shim.fs.readFileSync) {
            localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, "utf-8"));
          }
        } catch (err) {
          if (err instanceof SyntaxError) {
            err.message = "syntax error in " + languageFile;
          }
          if (err.code === "ENOENT")
            localeLookup = {};
          else
            throw err;
        }
        this.cache[this.locale] = localeLookup;
      }
      _resolveLocaleFile(directory, locale) {
        let file = shim.resolve(directory, "./", locale + ".json");
        if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf("_")) {
          const languageFile = shim.resolve(directory, "./", locale.split("_")[0] + ".json");
          if (this._fileExistsSync(languageFile))
            file = languageFile;
        }
        return file;
      }
      _fileExistsSync(file) {
        return shim.exists(file);
      }
    };
    function y18n$1(opts, _shim) {
      shim = _shim;
      const y18n2 = new Y18N(opts);
      return {
        __: y18n2.__.bind(y18n2),
        __n: y18n2.__n.bind(y18n2),
        setLocale: y18n2.setLocale.bind(y18n2),
        getLocale: y18n2.getLocale.bind(y18n2),
        updateLocale: y18n2.updateLocale.bind(y18n2),
        locale: y18n2.locale
      };
    }
    var nodePlatformShim = {
      fs: {
        readFileSync: fs.readFileSync,
        writeFile: fs.writeFile
      },
      format: util.format,
      resolve: path.resolve,
      exists: (file) => {
        try {
          return fs.statSync(file).isFile();
        } catch (err) {
          return false;
        }
      }
    };
    var y18n = (opts) => {
      return y18n$1(opts, nodePlatformShim);
    };
    module2.exports = y18n;
  }
});

// .pnpm/yargs-parser@20.2.7/node_modules/yargs-parser/build/index.cjs
var require_build2 = __commonJS({
  ".pnpm/yargs-parser@20.2.7/node_modules/yargs-parser/build/index.cjs"(exports2, module2) {
    "use strict";
    var util = require("util");
    var fs = require("fs");
    var path = require("path");
    function camelCase(str) {
      const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
      if (!isCamelCase) {
        str = str.toLocaleLowerCase();
      }
      if (str.indexOf("-") === -1 && str.indexOf("_") === -1) {
        return str;
      } else {
        let camelcase = "";
        let nextChrUpper = false;
        const leadingHyphens = str.match(/^-+/);
        for (let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++) {
          let chr = str.charAt(i);
          if (nextChrUpper) {
            nextChrUpper = false;
            chr = chr.toLocaleUpperCase();
          }
          if (i !== 0 && (chr === "-" || chr === "_")) {
            nextChrUpper = true;
          } else if (chr !== "-" && chr !== "_") {
            camelcase += chr;
          }
        }
        return camelcase;
      }
    }
    function decamelize(str, joinString) {
      const lowercase = str.toLocaleLowerCase();
      joinString = joinString || "-";
      let notCamelcase = "";
      for (let i = 0; i < str.length; i++) {
        const chrLower = lowercase.charAt(i);
        const chrString = str.charAt(i);
        if (chrLower !== chrString && i > 0) {
          notCamelcase += `${joinString}${lowercase.charAt(i)}`;
        } else {
          notCamelcase += chrString;
        }
      }
      return notCamelcase;
    }
    function looksLikeNumber(x) {
      if (x === null || x === void 0)
        return false;
      if (typeof x === "number")
        return true;
      if (/^0x[0-9a-f]+$/i.test(x))
        return true;
      if (x.length > 1 && x[0] === "0")
        return false;
      return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    function tokenizeArgString(argString) {
      if (Array.isArray(argString)) {
        return argString.map((e) => typeof e !== "string" ? e + "" : e);
      }
      argString = argString.trim();
      let i = 0;
      let prevC = null;
      let c = null;
      let opening = null;
      const args = [];
      for (let ii = 0; ii < argString.length; ii++) {
        prevC = c;
        c = argString.charAt(ii);
        if (c === " " && !opening) {
          if (!(prevC === " ")) {
            i++;
          }
          continue;
        }
        if (c === opening) {
          opening = null;
        } else if ((c === "'" || c === '"') && !opening) {
          opening = c;
        }
        if (!args[i])
          args[i] = "";
        args[i] += c;
      }
      return args;
    }
    var mixin;
    var YargsParser = class {
      constructor(_mixin) {
        mixin = _mixin;
      }
      parse(argsInput, options) {
        const opts = Object.assign({
          alias: void 0,
          array: void 0,
          boolean: void 0,
          config: void 0,
          configObjects: void 0,
          configuration: void 0,
          coerce: void 0,
          count: void 0,
          default: void 0,
          envPrefix: void 0,
          narg: void 0,
          normalize: void 0,
          string: void 0,
          number: void 0,
          __: void 0,
          key: void 0
        }, options);
        const args = tokenizeArgString(argsInput);
        const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
        const configuration = Object.assign({
          "boolean-negation": true,
          "camel-case-expansion": true,
          "combine-arrays": false,
          "dot-notation": true,
          "duplicate-arguments-array": true,
          "flatten-duplicate-arrays": true,
          "greedy-arrays": true,
          "halt-at-non-option": false,
          "nargs-eats-options": false,
          "negation-prefix": "no-",
          "parse-numbers": true,
          "parse-positional-numbers": true,
          "populate--": false,
          "set-placeholder-key": false,
          "short-option-groups": true,
          "strip-aliased": false,
          "strip-dashed": false,
          "unknown-options-as-args": false
        }, opts.configuration);
        const defaults = Object.assign(Object.create(null), opts.default);
        const configObjects = opts.configObjects || [];
        const envPrefix = opts.envPrefix;
        const notFlagsOption = configuration["populate--"];
        const notFlagsArgv = notFlagsOption ? "--" : "_";
        const newAliases = Object.create(null);
        const defaulted = Object.create(null);
        const __ = opts.__ || mixin.format;
        const flags = {
          aliases: Object.create(null),
          arrays: Object.create(null),
          bools: Object.create(null),
          strings: Object.create(null),
          numbers: Object.create(null),
          counts: Object.create(null),
          normalize: Object.create(null),
          configs: Object.create(null),
          nargs: Object.create(null),
          coercions: Object.create(null),
          keys: []
        };
        const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
        const negatedBoolean = new RegExp("^--" + configuration["negation-prefix"] + "(.+)");
        [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
          const key = typeof opt === "object" ? opt.key : opt;
          const assignment = Object.keys(opt).map(function(key2) {
            const arrayFlagKeys = {
              boolean: "bools",
              string: "strings",
              number: "numbers"
            };
            return arrayFlagKeys[key2];
          }).filter(Boolean).pop();
          if (assignment) {
            flags[assignment][key] = true;
          }
          flags.arrays[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {
          flags.bools[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.string || []).filter(Boolean).forEach(function(key) {
          flags.strings[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.number || []).filter(Boolean).forEach(function(key) {
          flags.numbers[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.count || []).filter(Boolean).forEach(function(key) {
          flags.counts[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {
          flags.normalize[key] = true;
          flags.keys.push(key);
        });
        if (typeof opts.narg === "object") {
          Object.entries(opts.narg).forEach(([key, value]) => {
            if (typeof value === "number") {
              flags.nargs[key] = value;
              flags.keys.push(key);
            }
          });
        }
        if (typeof opts.coerce === "object") {
          Object.entries(opts.coerce).forEach(([key, value]) => {
            if (typeof value === "function") {
              flags.coercions[key] = value;
              flags.keys.push(key);
            }
          });
        }
        if (typeof opts.config !== "undefined") {
          if (Array.isArray(opts.config) || typeof opts.config === "string") {
            [].concat(opts.config).filter(Boolean).forEach(function(key) {
              flags.configs[key] = true;
            });
          } else if (typeof opts.config === "object") {
            Object.entries(opts.config).forEach(([key, value]) => {
              if (typeof value === "boolean" || typeof value === "function") {
                flags.configs[key] = value;
              }
            });
          }
        }
        extendAliases(opts.key, aliases, opts.default, flags.arrays);
        Object.keys(defaults).forEach(function(key) {
          (flags.aliases[key] || []).forEach(function(alias) {
            defaults[alias] = defaults[key];
          });
        });
        let error = null;
        checkConfiguration();
        let notFlags = [];
        const argv = Object.assign(Object.create(null), {_: []});
        const argvReturn = {};
        for (let i = 0; i < args.length; i++) {
          const arg = args[i];
          let broken;
          let key;
          let letters;
          let m;
          let next;
          let value;
          if (arg !== "--" && isUnknownOptionAsArg(arg)) {
            pushPositional(arg);
          } else if (arg.match(/---+(=|$)/)) {
            pushPositional(arg);
            continue;
          } else if (arg.match(/^--.+=/) || !configuration["short-option-groups"] && arg.match(/^-.+=/)) {
            m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
            if (m !== null && Array.isArray(m) && m.length >= 3) {
              if (checkAllAliases(m[1], flags.arrays)) {
                i = eatArray(i, m[1], args, m[2]);
              } else if (checkAllAliases(m[1], flags.nargs) !== false) {
                i = eatNargs(i, m[1], args, m[2]);
              } else {
                setArg(m[1], m[2]);
              }
            }
          } else if (arg.match(negatedBoolean) && configuration["boolean-negation"]) {
            m = arg.match(negatedBoolean);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
            }
          } else if (arg.match(/^--.+/) || !configuration["short-option-groups"] && arg.match(/^-[^-]+/)) {
            m = arg.match(/^--?(.+)/);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              if (checkAllAliases(key, flags.arrays)) {
                i = eatArray(i, key, args);
              } else if (checkAllAliases(key, flags.nargs) !== false) {
                i = eatNargs(i, key, args);
              } else {
                next = args[i + 1];
                if (next !== void 0 && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                  setArg(key, next);
                  i++;
                } else if (/^(true|false)$/.test(next)) {
                  setArg(key, next);
                  i++;
                } else {
                  setArg(key, defaultValue(key));
                }
              }
            }
          } else if (arg.match(/^-.\..+=/)) {
            m = arg.match(/^-([^=]+)=([\s\S]*)$/);
            if (m !== null && Array.isArray(m) && m.length >= 3) {
              setArg(m[1], m[2]);
            }
          } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
            next = args[i + 1];
            m = arg.match(/^-(.\..+)/);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              if (next !== void 0 && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                setArg(key, next);
                i++;
              } else {
                setArg(key, defaultValue(key));
              }
            }
          } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
            letters = arg.slice(1, -1).split("");
            broken = false;
            for (let j = 0; j < letters.length; j++) {
              next = arg.slice(j + 2);
              if (letters[j + 1] && letters[j + 1] === "=") {
                value = arg.slice(j + 3);
                key = letters[j];
                if (checkAllAliases(key, flags.arrays)) {
                  i = eatArray(i, key, args, value);
                } else if (checkAllAliases(key, flags.nargs) !== false) {
                  i = eatNargs(i, key, args, value);
                } else {
                  setArg(key, value);
                }
                broken = true;
                break;
              }
              if (next === "-") {
                setArg(letters[j], next);
                continue;
              }
              if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
                setArg(letters[j], next);
                broken = true;
                break;
              }
              if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                setArg(letters[j], next);
                broken = true;
                break;
              } else {
                setArg(letters[j], defaultValue(letters[j]));
              }
            }
            key = arg.slice(-1)[0];
            if (!broken && key !== "-") {
              if (checkAllAliases(key, flags.arrays)) {
                i = eatArray(i, key, args);
              } else if (checkAllAliases(key, flags.nargs) !== false) {
                i = eatNargs(i, key, args);
              } else {
                next = args[i + 1];
                if (next !== void 0 && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                  setArg(key, next);
                  i++;
                } else if (/^(true|false)$/.test(next)) {
                  setArg(key, next);
                  i++;
                } else {
                  setArg(key, defaultValue(key));
                }
              }
            }
          } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
            key = arg.slice(1);
            setArg(key, defaultValue(key));
          } else if (arg === "--") {
            notFlags = args.slice(i + 1);
            break;
          } else if (configuration["halt-at-non-option"]) {
            notFlags = args.slice(i);
            break;
          } else {
            pushPositional(arg);
          }
        }
        applyEnvVars(argv, true);
        applyEnvVars(argv, false);
        setConfig(argv);
        setConfigObjects();
        applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
        applyCoercions(argv);
        if (configuration["set-placeholder-key"])
          setPlaceholderKeys(argv);
        Object.keys(flags.counts).forEach(function(key) {
          if (!hasKey(argv, key.split(".")))
            setArg(key, 0);
        });
        if (notFlagsOption && notFlags.length)
          argv[notFlagsArgv] = [];
        notFlags.forEach(function(key) {
          argv[notFlagsArgv].push(key);
        });
        if (configuration["camel-case-expansion"] && configuration["strip-dashed"]) {
          Object.keys(argv).filter((key) => key !== "--" && key.includes("-")).forEach((key) => {
            delete argv[key];
          });
        }
        if (configuration["strip-aliased"]) {
          [].concat(...Object.keys(aliases).map((k) => aliases[k])).forEach((alias) => {
            if (configuration["camel-case-expansion"] && alias.includes("-")) {
              delete argv[alias.split(".").map((prop) => camelCase(prop)).join(".")];
            }
            delete argv[alias];
          });
        }
        function pushPositional(arg) {
          const maybeCoercedNumber = maybeCoerceNumber("_", arg);
          if (typeof maybeCoercedNumber === "string" || typeof maybeCoercedNumber === "number") {
            argv._.push(maybeCoercedNumber);
          }
        }
        function eatNargs(i, key, args2, argAfterEqualSign) {
          let ii;
          let toEat = checkAllAliases(key, flags.nargs);
          toEat = typeof toEat !== "number" || isNaN(toEat) ? 1 : toEat;
          if (toEat === 0) {
            if (!isUndefined(argAfterEqualSign)) {
              error = Error(__("Argument unexpected for: %s", key));
            }
            setArg(key, defaultValue(key));
            return i;
          }
          let available = isUndefined(argAfterEqualSign) ? 0 : 1;
          if (configuration["nargs-eats-options"]) {
            if (args2.length - (i + 1) + available < toEat) {
              error = Error(__("Not enough arguments following: %s", key));
            }
            available = toEat;
          } else {
            for (ii = i + 1; ii < args2.length; ii++) {
              if (!args2[ii].match(/^-[^0-9]/) || args2[ii].match(negative) || isUnknownOptionAsArg(args2[ii]))
                available++;
              else
                break;
            }
            if (available < toEat)
              error = Error(__("Not enough arguments following: %s", key));
          }
          let consumed = Math.min(available, toEat);
          if (!isUndefined(argAfterEqualSign) && consumed > 0) {
            setArg(key, argAfterEqualSign);
            consumed--;
          }
          for (ii = i + 1; ii < consumed + i + 1; ii++) {
            setArg(key, args2[ii]);
          }
          return i + consumed;
        }
        function eatArray(i, key, args2, argAfterEqualSign) {
          let argsToSet = [];
          let next = argAfterEqualSign || args2[i + 1];
          const nargsCount = checkAllAliases(key, flags.nargs);
          if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
            argsToSet.push(true);
          } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
            if (defaults[key] !== void 0) {
              const defVal = defaults[key];
              argsToSet = Array.isArray(defVal) ? defVal : [defVal];
            }
          } else {
            if (!isUndefined(argAfterEqualSign)) {
              argsToSet.push(processValue(key, argAfterEqualSign));
            }
            for (let ii = i + 1; ii < args2.length; ii++) {
              if (!configuration["greedy-arrays"] && argsToSet.length > 0 || nargsCount && typeof nargsCount === "number" && argsToSet.length >= nargsCount)
                break;
              next = args2[ii];
              if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
                break;
              i = ii;
              argsToSet.push(processValue(key, next));
            }
          }
          if (typeof nargsCount === "number" && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
            error = Error(__("Not enough arguments following: %s", key));
          }
          setArg(key, argsToSet);
          return i;
        }
        function setArg(key, val) {
          if (/-/.test(key) && configuration["camel-case-expansion"]) {
            const alias = key.split(".").map(function(prop) {
              return camelCase(prop);
            }).join(".");
            addNewAlias(key, alias);
          }
          const value = processValue(key, val);
          const splitKey = key.split(".");
          setKey(argv, splitKey, value);
          if (flags.aliases[key]) {
            flags.aliases[key].forEach(function(x) {
              const keyProperties = x.split(".");
              setKey(argv, keyProperties, value);
            });
          }
          if (splitKey.length > 1 && configuration["dot-notation"]) {
            (flags.aliases[splitKey[0]] || []).forEach(function(x) {
              let keyProperties = x.split(".");
              const a = [].concat(splitKey);
              a.shift();
              keyProperties = keyProperties.concat(a);
              if (!(flags.aliases[key] || []).includes(keyProperties.join("."))) {
                setKey(argv, keyProperties, value);
              }
            });
          }
          if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
            const keys = [key].concat(flags.aliases[key] || []);
            keys.forEach(function(key2) {
              Object.defineProperty(argvReturn, key2, {
                enumerable: true,
                get() {
                  return val;
                },
                set(value2) {
                  val = typeof value2 === "string" ? mixin.normalize(value2) : value2;
                }
              });
            });
          }
        }
        function addNewAlias(key, alias) {
          if (!(flags.aliases[key] && flags.aliases[key].length)) {
            flags.aliases[key] = [alias];
            newAliases[alias] = true;
          }
          if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
            addNewAlias(alias, key);
          }
        }
        function processValue(key, val) {
          if (typeof val === "string" && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0]) {
            val = val.substring(1, val.length - 1);
          }
          if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
            if (typeof val === "string")
              val = val === "true";
          }
          let value = Array.isArray(val) ? val.map(function(v) {
            return maybeCoerceNumber(key, v);
          }) : maybeCoerceNumber(key, val);
          if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === "boolean")) {
            value = increment();
          }
          if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
            if (Array.isArray(val))
              value = val.map((val2) => {
                return mixin.normalize(val2);
              });
            else
              value = mixin.normalize(val);
          }
          return value;
        }
        function maybeCoerceNumber(key, value) {
          if (!configuration["parse-positional-numbers"] && key === "_")
            return value;
          if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
            const shouldCoerceNumber = looksLikeNumber(value) && configuration["parse-numbers"] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));
            if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) {
              value = Number(value);
            }
          }
          return value;
        }
        function setConfig(argv2) {
          const configLookup = Object.create(null);
          applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
          Object.keys(flags.configs).forEach(function(configKey) {
            const configPath = argv2[configKey] || configLookup[configKey];
            if (configPath) {
              try {
                let config = null;
                const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
                const resolveConfig = flags.configs[configKey];
                if (typeof resolveConfig === "function") {
                  try {
                    config = resolveConfig(resolvedConfigPath);
                  } catch (e) {
                    config = e;
                  }
                  if (config instanceof Error) {
                    error = config;
                    return;
                  }
                } else {
                  config = mixin.require(resolvedConfigPath);
                }
                setConfigObject(config);
              } catch (ex) {
                if (ex.name === "PermissionDenied")
                  error = ex;
                else if (argv2[configKey])
                  error = Error(__("Invalid JSON config file: %s", configPath));
              }
            }
          });
        }
        function setConfigObject(config, prev) {
          Object.keys(config).forEach(function(key) {
            const value = config[key];
            const fullKey = prev ? prev + "." + key : key;
            if (typeof value === "object" && value !== null && !Array.isArray(value) && configuration["dot-notation"]) {
              setConfigObject(value, fullKey);
            } else {
              if (!hasKey(argv, fullKey.split(".")) || checkAllAliases(fullKey, flags.arrays) && configuration["combine-arrays"]) {
                setArg(fullKey, value);
              }
            }
          });
        }
        function setConfigObjects() {
          if (typeof configObjects !== "undefined") {
            configObjects.forEach(function(configObject) {
              setConfigObject(configObject);
            });
          }
        }
        function applyEnvVars(argv2, configOnly) {
          if (typeof envPrefix === "undefined")
            return;
          const prefix = typeof envPrefix === "string" ? envPrefix : "";
          const env2 = mixin.env();
          Object.keys(env2).forEach(function(envVar) {
            if (prefix === "" || envVar.lastIndexOf(prefix, 0) === 0) {
              const keys = envVar.split("__").map(function(key, i) {
                if (i === 0) {
                  key = key.substring(prefix.length);
                }
                return camelCase(key);
              });
              if ((configOnly && flags.configs[keys.join(".")] || !configOnly) && !hasKey(argv2, keys)) {
                setArg(keys.join("."), env2[envVar]);
              }
            }
          });
        }
        function applyCoercions(argv2) {
          let coerce;
          const applied = new Set();
          Object.keys(argv2).forEach(function(key) {
            if (!applied.has(key)) {
              coerce = checkAllAliases(key, flags.coercions);
              if (typeof coerce === "function") {
                try {
                  const value = maybeCoerceNumber(key, coerce(argv2[key]));
                  [].concat(flags.aliases[key] || [], key).forEach((ali) => {
                    applied.add(ali);
                    argv2[ali] = value;
                  });
                } catch (err) {
                  error = err;
                }
              }
            }
          });
        }
        function setPlaceholderKeys(argv2) {
          flags.keys.forEach((key) => {
            if (~key.indexOf("."))
              return;
            if (typeof argv2[key] === "undefined")
              argv2[key] = void 0;
          });
          return argv2;
        }
        function applyDefaultsAndAliases(obj, aliases2, defaults2, canLog = false) {
          Object.keys(defaults2).forEach(function(key) {
            if (!hasKey(obj, key.split("."))) {
              setKey(obj, key.split("."), defaults2[key]);
              if (canLog)
                defaulted[key] = true;
              (aliases2[key] || []).forEach(function(x) {
                if (hasKey(obj, x.split(".")))
                  return;
                setKey(obj, x.split("."), defaults2[key]);
              });
            }
          });
        }
        function hasKey(obj, keys) {
          let o = obj;
          if (!configuration["dot-notation"])
            keys = [keys.join(".")];
          keys.slice(0, -1).forEach(function(key2) {
            o = o[key2] || {};
          });
          const key = keys[keys.length - 1];
          if (typeof o !== "object")
            return false;
          else
            return key in o;
        }
        function setKey(obj, keys, value) {
          let o = obj;
          if (!configuration["dot-notation"])
            keys = [keys.join(".")];
          keys.slice(0, -1).forEach(function(key2) {
            key2 = sanitizeKey(key2);
            if (typeof o === "object" && o[key2] === void 0) {
              o[key2] = {};
            }
            if (typeof o[key2] !== "object" || Array.isArray(o[key2])) {
              if (Array.isArray(o[key2])) {
                o[key2].push({});
              } else {
                o[key2] = [o[key2], {}];
              }
              o = o[key2][o[key2].length - 1];
            } else {
              o = o[key2];
            }
          });
          const key = sanitizeKey(keys[keys.length - 1]);
          const isTypeArray = checkAllAliases(keys.join("."), flags.arrays);
          const isValueArray = Array.isArray(value);
          let duplicate = configuration["duplicate-arguments-array"];
          if (!duplicate && checkAllAliases(key, flags.nargs)) {
            duplicate = true;
            if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {
              o[key] = void 0;
            }
          }
          if (value === increment()) {
            o[key] = increment(o[key]);
          } else if (Array.isArray(o[key])) {
            if (duplicate && isTypeArray && isValueArray) {
              o[key] = configuration["flatten-duplicate-arrays"] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
            } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
              o[key] = value;
            } else {
              o[key] = o[key].concat([value]);
            }
          } else if (o[key] === void 0 && isTypeArray) {
            o[key] = isValueArray ? value : [value];
          } else if (duplicate && !(o[key] === void 0 || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
            o[key] = [o[key], value];
          } else {
            o[key] = value;
          }
        }
        function extendAliases(...args2) {
          args2.forEach(function(obj) {
            Object.keys(obj || {}).forEach(function(key) {
              if (flags.aliases[key])
                return;
              flags.aliases[key] = [].concat(aliases[key] || []);
              flags.aliases[key].concat(key).forEach(function(x) {
                if (/-/.test(x) && configuration["camel-case-expansion"]) {
                  const c = camelCase(x);
                  if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                    flags.aliases[key].push(c);
                    newAliases[c] = true;
                  }
                }
              });
              flags.aliases[key].concat(key).forEach(function(x) {
                if (x.length > 1 && /[A-Z]/.test(x) && configuration["camel-case-expansion"]) {
                  const c = decamelize(x, "-");
                  if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                    flags.aliases[key].push(c);
                    newAliases[c] = true;
                  }
                }
              });
              flags.aliases[key].forEach(function(x) {
                flags.aliases[x] = [key].concat(flags.aliases[key].filter(function(y) {
                  return x !== y;
                }));
              });
            });
          });
        }
        function checkAllAliases(key, flag) {
          const toCheck = [].concat(flags.aliases[key] || [], key);
          const keys = Object.keys(flag);
          const setAlias = toCheck.find((key2) => keys.includes(key2));
          return setAlias ? flag[setAlias] : false;
        }
        function hasAnyFlag(key) {
          const flagsKeys = Object.keys(flags);
          const toCheck = [].concat(flagsKeys.map((k) => flags[k]));
          return toCheck.some(function(flag) {
            return Array.isArray(flag) ? flag.includes(key) : flag[key];
          });
        }
        function hasFlagsMatching(arg, ...patterns) {
          const toCheck = [].concat(...patterns);
          return toCheck.some(function(pattern) {
            const match = arg.match(pattern);
            return match && hasAnyFlag(match[1]);
          });
        }
        function hasAllShortFlags(arg) {
          if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
            return false;
          }
          let hasAllFlags = true;
          let next;
          const letters = arg.slice(1).split("");
          for (let j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2);
            if (!hasAnyFlag(letters[j])) {
              hasAllFlags = false;
              break;
            }
            if (letters[j + 1] && letters[j + 1] === "=" || next === "-" || /[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\W/)) {
              break;
            }
          }
          return hasAllFlags;
        }
        function isUnknownOptionAsArg(arg) {
          return configuration["unknown-options-as-args"] && isUnknownOption(arg);
        }
        function isUnknownOption(arg) {
          if (arg.match(negative)) {
            return false;
          }
          if (hasAllShortFlags(arg)) {
            return false;
          }
          const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
          const normalFlag = /^-+([^=]+?)$/;
          const flagEndingInHyphen = /^-+([^=]+?)-$/;
          const flagEndingInDigits = /^-+([^=]+?\d+)$/;
          const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
          return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
        }
        function defaultValue(key) {
          if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {
            return defaults[key];
          } else {
            return defaultForType(guessType(key));
          }
        }
        function defaultForType(type) {
          const def = {
            boolean: true,
            string: "",
            number: void 0,
            array: []
          };
          return def[type];
        }
        function guessType(key) {
          let type = "boolean";
          if (checkAllAliases(key, flags.strings))
            type = "string";
          else if (checkAllAliases(key, flags.numbers))
            type = "number";
          else if (checkAllAliases(key, flags.bools))
            type = "boolean";
          else if (checkAllAliases(key, flags.arrays))
            type = "array";
          return type;
        }
        function isUndefined(num) {
          return num === void 0;
        }
        function checkConfiguration() {
          Object.keys(flags.counts).find((key) => {
            if (checkAllAliases(key, flags.arrays)) {
              error = Error(__("Invalid configuration: %s, opts.count excludes opts.array.", key));
              return true;
            } else if (checkAllAliases(key, flags.nargs)) {
              error = Error(__("Invalid configuration: %s, opts.count excludes opts.narg.", key));
              return true;
            }
            return false;
          });
        }
        return {
          aliases: Object.assign({}, flags.aliases),
          argv: Object.assign(argvReturn, argv),
          configuration,
          defaulted: Object.assign({}, defaulted),
          error,
          newAliases: Object.assign({}, newAliases)
        };
      }
    };
    function combineAliases(aliases) {
      const aliasArrays = [];
      const combined = Object.create(null);
      let change = true;
      Object.keys(aliases).forEach(function(key) {
        aliasArrays.push([].concat(aliases[key], key));
      });
      while (change) {
        change = false;
        for (let i = 0; i < aliasArrays.length; i++) {
          for (let ii = i + 1; ii < aliasArrays.length; ii++) {
            const intersect = aliasArrays[i].filter(function(v) {
              return aliasArrays[ii].indexOf(v) !== -1;
            });
            if (intersect.length) {
              aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
              aliasArrays.splice(ii, 1);
              change = true;
              break;
            }
          }
        }
      }
      aliasArrays.forEach(function(aliasArray) {
        aliasArray = aliasArray.filter(function(v, i, self) {
          return self.indexOf(v) === i;
        });
        const lastAlias = aliasArray.pop();
        if (lastAlias !== void 0 && typeof lastAlias === "string") {
          combined[lastAlias] = aliasArray;
        }
      });
      return combined;
    }
    function increment(orig) {
      return orig !== void 0 ? orig + 1 : 1;
    }
    function sanitizeKey(key) {
      if (key === "__proto__")
        return "___proto___";
      return key;
    }
    var minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 10;
    if (process && process.version) {
      const major = Number(process.version.match(/v([^.]+)/)[1]);
      if (major < minNodeVersion) {
        throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
      }
    }
    var env = process ? process.env : {};
    var parser = new YargsParser({
      cwd: process.cwd,
      env: () => {
        return env;
      },
      format: util.format,
      normalize: path.normalize,
      resolve: path.resolve,
      require: (path2) => {
        if (typeof require !== "undefined") {
          return require(path2);
        } else if (path2.match(/\.json$/)) {
          return fs.readFileSync(path2, "utf8");
        } else {
          throw Error("only .json config files are supported in ESM");
        }
      }
    });
    var yargsParser = function Parser(args, opts) {
      const result = parser.parse(args.slice(), opts);
      return result.argv;
    };
    yargsParser.detailed = function(args, opts) {
      return parser.parse(args.slice(), opts);
    };
    yargsParser.camelCase = camelCase;
    yargsParser.decamelize = decamelize;
    yargsParser.looksLikeNumber = looksLikeNumber;
    module2.exports = yargsParser;
  }
});

// .pnpm/ansi-regex@5.0.0/node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  ".pnpm/ansi-regex@5.0.0/node_modules/ansi-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = ({onlyFirst = false} = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// .pnpm/strip-ansi@6.0.0/node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  ".pnpm/strip-ansi@6.0.0/node_modules/strip-ansi/index.js"(exports2, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex();
    module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
  }
});

// .pnpm/is-fullwidth-code-point@3.0.0/node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS({
  ".pnpm/is-fullwidth-code-point@3.0.0/node_modules/is-fullwidth-code-point/index.js"(exports2, module2) {
    "use strict";
    var isFullwidthCodePoint = (codePoint) => {
      if (Number.isNaN(codePoint)) {
        return false;
      }
      if (codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141)) {
        return true;
      }
      return false;
    };
    module2.exports = isFullwidthCodePoint;
    module2.exports.default = isFullwidthCodePoint;
  }
});

// .pnpm/emoji-regex@8.0.0/node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS({
  ".pnpm/emoji-regex@8.0.0/node_modules/emoji-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
  }
});

// .pnpm/string-width@4.2.2/node_modules/string-width/index.js
var require_string_width = __commonJS({
  ".pnpm/string-width@4.2.2/node_modules/string-width/index.js"(exports2, module2) {
    "use strict";
    var stripAnsi = require_strip_ansi();
    var isFullwidthCodePoint = require_is_fullwidth_code_point();
    var emojiRegex = require_emoji_regex();
    var stringWidth = (string) => {
      if (typeof string !== "string" || string.length === 0) {
        return 0;
      }
      string = stripAnsi(string);
      if (string.length === 0) {
        return 0;
      }
      string = string.replace(emojiRegex(), "  ");
      let width = 0;
      for (let i = 0; i < string.length; i++) {
        const code = string.codePointAt(i);
        if (code <= 31 || code >= 127 && code <= 159) {
          continue;
        }
        if (code >= 768 && code <= 879) {
          continue;
        }
        if (code > 65535) {
          i++;
        }
        width += isFullwidthCodePoint(code) ? 2 : 1;
      }
      return width;
    };
    module2.exports = stringWidth;
    module2.exports.default = stringWidth;
  }
});

// .pnpm/wrap-ansi@7.0.0/node_modules/wrap-ansi/index.js
var require_wrap_ansi = __commonJS({
  ".pnpm/wrap-ansi@7.0.0/node_modules/wrap-ansi/index.js"(exports2, module2) {
    "use strict";
    var stringWidth = require_string_width();
    var stripAnsi = require_strip_ansi();
    var ansiStyles = require_ansi_styles();
    var ESCAPES = new Set([
      "",
      "\x9B"
    ]);
    var END_CODE = 39;
    var ANSI_ESCAPE_BELL = "\x07";
    var ANSI_CSI = "[";
    var ANSI_OSC = "]";
    var ANSI_SGR_TERMINATOR = "m";
    var ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;
    var wrapAnsi = (code) => `${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;
    var wrapAnsiHyperlink = (uri) => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${uri}${ANSI_ESCAPE_BELL}`;
    var wordLengths = (string) => string.split(" ").map((character) => stringWidth(character));
    var wrapWord = (rows, word, columns) => {
      const characters = [...word];
      let isInsideEscape = false;
      let isInsideLinkEscape = false;
      let visible = stringWidth(stripAnsi(rows[rows.length - 1]));
      for (const [index, character] of characters.entries()) {
        const characterLength = stringWidth(character);
        if (visible + characterLength <= columns) {
          rows[rows.length - 1] += character;
        } else {
          rows.push(character);
          visible = 0;
        }
        if (ESCAPES.has(character)) {
          isInsideEscape = true;
          isInsideLinkEscape = characters.slice(index + 1).join("").startsWith(ANSI_ESCAPE_LINK);
        }
        if (isInsideEscape) {
          if (isInsideLinkEscape) {
            if (character === ANSI_ESCAPE_BELL) {
              isInsideEscape = false;
              isInsideLinkEscape = false;
            }
          } else if (character === ANSI_SGR_TERMINATOR) {
            isInsideEscape = false;
          }
          continue;
        }
        visible += characterLength;
        if (visible === columns && index < characters.length - 1) {
          rows.push("");
          visible = 0;
        }
      }
      if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
        rows[rows.length - 2] += rows.pop();
      }
    };
    var stringVisibleTrimSpacesRight = (string) => {
      const words = string.split(" ");
      let last = words.length;
      while (last > 0) {
        if (stringWidth(words[last - 1]) > 0) {
          break;
        }
        last--;
      }
      if (last === words.length) {
        return string;
      }
      return words.slice(0, last).join(" ") + words.slice(last).join("");
    };
    var exec = (string, columns, options = {}) => {
      if (options.trim !== false && string.trim() === "") {
        return "";
      }
      let returnValue = "";
      let escapeCode;
      let escapeUrl;
      const lengths = wordLengths(string);
      let rows = [""];
      for (const [index, word] of string.split(" ").entries()) {
        if (options.trim !== false) {
          rows[rows.length - 1] = rows[rows.length - 1].trimStart();
        }
        let rowLength = stringWidth(rows[rows.length - 1]);
        if (index !== 0) {
          if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
            rows.push("");
            rowLength = 0;
          }
          if (rowLength > 0 || options.trim === false) {
            rows[rows.length - 1] += " ";
            rowLength++;
          }
        }
        if (options.hard && lengths[index] > columns) {
          const remainingColumns = columns - rowLength;
          const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
          const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
          if (breaksStartingNextLine < breaksStartingThisLine) {
            rows.push("");
          }
          wrapWord(rows, word, columns);
          continue;
        }
        if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
          if (options.wordWrap === false && rowLength < columns) {
            wrapWord(rows, word, columns);
            continue;
          }
          rows.push("");
        }
        if (rowLength + lengths[index] > columns && options.wordWrap === false) {
          wrapWord(rows, word, columns);
          continue;
        }
        rows[rows.length - 1] += word;
      }
      if (options.trim !== false) {
        rows = rows.map(stringVisibleTrimSpacesRight);
      }
      const pre = [...rows.join("\n")];
      for (const [index, character] of pre.entries()) {
        returnValue += character;
        if (ESCAPES.has(character)) {
          const {groups} = new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(pre.slice(index).join("")) || {groups: {}};
          if (groups.code !== void 0) {
            const code2 = Number.parseFloat(groups.code);
            escapeCode = code2 === END_CODE ? void 0 : code2;
          } else if (groups.uri !== void 0) {
            escapeUrl = groups.uri.length === 0 ? void 0 : groups.uri;
          }
        }
        const code = ansiStyles.codes.get(Number(escapeCode));
        if (pre[index + 1] === "\n") {
          if (escapeUrl) {
            returnValue += wrapAnsiHyperlink("");
          }
          if (escapeCode && code) {
            returnValue += wrapAnsi(code);
          }
        } else if (character === "\n") {
          if (escapeCode && code) {
            returnValue += wrapAnsi(escapeCode);
          }
          if (escapeUrl) {
            returnValue += wrapAnsiHyperlink(escapeUrl);
          }
        }
      }
      return returnValue;
    };
    module2.exports = (string, columns, options) => {
      return String(string).normalize().replace(/\r\n/g, "\n").split("\n").map((line) => exec(line, columns, options)).join("\n");
    };
  }
});

// .pnpm/cliui@7.0.4/node_modules/cliui/build/index.cjs
var require_build3 = __commonJS({
  ".pnpm/cliui@7.0.4/node_modules/cliui/build/index.cjs"(exports2, module2) {
    "use strict";
    var align = {
      right: alignRight,
      center: alignCenter
    };
    var top = 0;
    var right = 1;
    var bottom = 2;
    var left = 3;
    var UI = class {
      constructor(opts) {
        var _a;
        this.width = opts.width;
        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;
        this.rows = [];
      }
      span(...args) {
        const cols = this.div(...args);
        cols.span = true;
      }
      resetOutput() {
        this.rows = [];
      }
      div(...args) {
        if (args.length === 0) {
          this.div("");
        }
        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === "string") {
          return this.applyLayoutDSL(args[0]);
        }
        const cols = args.map((arg) => {
          if (typeof arg === "string") {
            return this.colFromString(arg);
          }
          return arg;
        });
        this.rows.push(cols);
        return cols;
      }
      shouldApplyLayoutDSL(...args) {
        return args.length === 1 && typeof args[0] === "string" && /[\t\n]/.test(args[0]);
      }
      applyLayoutDSL(str) {
        const rows = str.split("\n").map((row) => row.split("	"));
        let leftColumnWidth = 0;
        rows.forEach((columns) => {
          if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
            leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
          }
        });
        rows.forEach((columns) => {
          this.div(...columns.map((r, i) => {
            return {
              text: r.trim(),
              padding: this.measurePadding(r),
              width: i === 0 && columns.length > 1 ? leftColumnWidth : void 0
            };
          }));
        });
        return this.rows[this.rows.length - 1];
      }
      colFromString(text) {
        return {
          text,
          padding: this.measurePadding(text)
        };
      }
      measurePadding(str) {
        const noAnsi = mixin.stripAnsi(str);
        return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
      }
      toString() {
        const lines = [];
        this.rows.forEach((row) => {
          this.rowToString(row, lines);
        });
        return lines.filter((line) => !line.hidden).map((line) => line.text).join("\n");
      }
      rowToString(row, lines) {
        this.rasterize(row).forEach((rrow, r) => {
          let str = "";
          rrow.forEach((col, c) => {
            const {width} = row[c];
            const wrapWidth = this.negatePadding(row[c]);
            let ts = col;
            if (wrapWidth > mixin.stringWidth(col)) {
              ts += " ".repeat(wrapWidth - mixin.stringWidth(col));
            }
            if (row[c].align && row[c].align !== "left" && this.wrap) {
              const fn = align[row[c].align];
              ts = fn(ts, wrapWidth);
              if (mixin.stringWidth(ts) < wrapWidth) {
                ts += " ".repeat((width || 0) - mixin.stringWidth(ts) - 1);
              }
            }
            const padding = row[c].padding || [0, 0, 0, 0];
            if (padding[left]) {
              str += " ".repeat(padding[left]);
            }
            str += addBorder(row[c], ts, "| ");
            str += ts;
            str += addBorder(row[c], ts, " |");
            if (padding[right]) {
              str += " ".repeat(padding[right]);
            }
            if (r === 0 && lines.length > 0) {
              str = this.renderInline(str, lines[lines.length - 1]);
            }
          });
          lines.push({
            text: str.replace(/ +$/, ""),
            span: row.span
          });
        });
        return lines;
      }
      renderInline(source, previousLine) {
        const match = source.match(/^ */);
        const leadingWhitespace = match ? match[0].length : 0;
        const target = previousLine.text;
        const targetTextWidth = mixin.stringWidth(target.trimRight());
        if (!previousLine.span) {
          return source;
        }
        if (!this.wrap) {
          previousLine.hidden = true;
          return target + source;
        }
        if (leadingWhitespace < targetTextWidth) {
          return source;
        }
        previousLine.hidden = true;
        return target.trimRight() + " ".repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
      }
      rasterize(row) {
        const rrows = [];
        const widths = this.columnWidths(row);
        let wrapped;
        row.forEach((col, c) => {
          col.width = widths[c];
          if (this.wrap) {
            wrapped = mixin.wrap(col.text, this.negatePadding(col), {hard: true}).split("\n");
          } else {
            wrapped = col.text.split("\n");
          }
          if (col.border) {
            wrapped.unshift("." + "-".repeat(this.negatePadding(col) + 2) + ".");
            wrapped.push("'" + "-".repeat(this.negatePadding(col) + 2) + "'");
          }
          if (col.padding) {
            wrapped.unshift(...new Array(col.padding[top] || 0).fill(""));
            wrapped.push(...new Array(col.padding[bottom] || 0).fill(""));
          }
          wrapped.forEach((str, r) => {
            if (!rrows[r]) {
              rrows.push([]);
            }
            const rrow = rrows[r];
            for (let i = 0; i < c; i++) {
              if (rrow[i] === void 0) {
                rrow.push("");
              }
            }
            rrow.push(str);
          });
        });
        return rrows;
      }
      negatePadding(col) {
        let wrapWidth = col.width || 0;
        if (col.padding) {
          wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
        }
        if (col.border) {
          wrapWidth -= 4;
        }
        return wrapWidth;
      }
      columnWidths(row) {
        if (!this.wrap) {
          return row.map((col) => {
            return col.width || mixin.stringWidth(col.text);
          });
        }
        let unset = row.length;
        let remainingWidth = this.width;
        const widths = row.map((col) => {
          if (col.width) {
            unset--;
            remainingWidth -= col.width;
            return col.width;
          }
          return void 0;
        });
        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
        return widths.map((w, i) => {
          if (w === void 0) {
            return Math.max(unsetWidth, _minWidth(row[i]));
          }
          return w;
        });
      }
    };
    function addBorder(col, ts, style) {
      if (col.border) {
        if (/[.']-+[.']/.test(ts)) {
          return "";
        }
        if (ts.trim().length !== 0) {
          return style;
        }
        return "  ";
      }
      return "";
    }
    function _minWidth(col) {
      const padding = col.padding || [];
      const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
      if (col.border) {
        return minWidth + 4;
      }
      return minWidth;
    }
    function getWindowWidth() {
      if (typeof process === "object" && process.stdout && process.stdout.columns) {
        return process.stdout.columns;
      }
      return 80;
    }
    function alignRight(str, width) {
      str = str.trim();
      const strWidth = mixin.stringWidth(str);
      if (strWidth < width) {
        return " ".repeat(width - strWidth) + str;
      }
      return str;
    }
    function alignCenter(str, width) {
      str = str.trim();
      const strWidth = mixin.stringWidth(str);
      if (strWidth >= width) {
        return str;
      }
      return " ".repeat(width - strWidth >> 1) + str;
    }
    var mixin;
    function cliui(opts, _mixin) {
      mixin = _mixin;
      return new UI({
        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),
        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap
      });
    }
    var stringWidth = require_string_width();
    var stripAnsi = require_strip_ansi();
    var wrap = require_wrap_ansi();
    function ui(opts) {
      return cliui(opts, {
        stringWidth,
        stripAnsi,
        wrap
      });
    }
    module2.exports = ui;
  }
});

// .pnpm/escalade@3.1.1/node_modules/escalade/sync/index.js
var require_sync = __commonJS({
  ".pnpm/escalade@3.1.1/node_modules/escalade/sync/index.js"(exports2, module2) {
    var {dirname, resolve} = require("path");
    var {readdirSync, statSync} = require("fs");
    module2.exports = function(start, callback) {
      let dir = resolve(".", start);
      let tmp, stats = statSync(dir);
      if (!stats.isDirectory()) {
        dir = dirname(dir);
      }
      while (true) {
        tmp = callback(dir, readdirSync(dir));
        if (tmp)
          return resolve(dir, tmp);
        dir = dirname(tmp = dir);
        if (tmp === dir)
          break;
      }
    };
  }
});

// .pnpm/get-caller-file@2.0.5/node_modules/get-caller-file/index.js
var require_get_caller_file = __commonJS({
  ".pnpm/get-caller-file@2.0.5/node_modules/get-caller-file/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function getCallerFile(position) {
      if (position === void 0) {
        position = 2;
      }
      if (position >= Error.stackTraceLimit) {
        throw new TypeError("getCallerFile(position) requires position be less then Error.stackTraceLimit but position was: `" + position + "` and Error.stackTraceLimit was: `" + Error.stackTraceLimit + "`");
      }
      var oldPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = oldPrepareStackTrace;
      if (stack !== null && typeof stack === "object") {
        return stack[position] ? stack[position].getFileName() : void 0;
      }
    };
  }
});

// .pnpm/require-directory@2.1.1/node_modules/require-directory/index.js
var require_require_directory = __commonJS({
  ".pnpm/require-directory@2.1.1/node_modules/require-directory/index.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var join = require("path").join;
    var resolve = require("path").resolve;
    var dirname = require("path").dirname;
    var defaultOptions = {
      extensions: ["js", "json", "coffee"],
      recurse: true,
      rename: function(name) {
        return name;
      },
      visit: function(obj) {
        return obj;
      }
    };
    function checkFileInclusion(path, filename, options) {
      return new RegExp("\\.(" + options.extensions.join("|") + ")$", "i").test(filename) && !(options.include && options.include instanceof RegExp && !options.include.test(path)) && !(options.include && typeof options.include === "function" && !options.include(path, filename)) && !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) && !(options.exclude && typeof options.exclude === "function" && options.exclude(path, filename));
    }
    function requireDirectory(m, path, options) {
      var retval = {};
      if (path && !options && typeof path !== "string") {
        options = path;
        path = null;
      }
      options = options || {};
      for (var prop in defaultOptions) {
        if (typeof options[prop] === "undefined") {
          options[prop] = defaultOptions[prop];
        }
      }
      path = !path ? dirname(m.filename) : resolve(dirname(m.filename), path);
      fs.readdirSync(path).forEach(function(filename) {
        var joined = join(path, filename), files, key, obj;
        if (fs.statSync(joined).isDirectory() && options.recurse) {
          files = requireDirectory(m, joined, options);
          if (Object.keys(files).length) {
            retval[options.rename(filename, joined, filename)] = files;
          }
        } else {
          if (joined !== m.filename && checkFileInclusion(joined, filename, options)) {
            key = filename.substring(0, filename.lastIndexOf("."));
            obj = m.require(joined);
            retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;
          }
        }
      });
      return retval;
    }
    module2.exports = requireDirectory;
    module2.exports.defaults = defaultOptions;
  }
});

// .pnpm/yargs@16.2.0/node_modules/yargs/build/index.cjs
var require_build4 = __commonJS({
  ".pnpm/yargs@16.2.0/node_modules/yargs/build/index.cjs"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var YError = class extends Error {
      constructor(msg) {
        super(msg || "yargs error");
        this.name = "YError";
        Error.captureStackTrace(this, YError);
      }
    };
    var previouslyVisitedConfigs = [];
    var shim;
    function applyExtends(config, cwd, mergeExtends, _shim) {
      shim = _shim;
      let defaultConfig = {};
      if (Object.prototype.hasOwnProperty.call(config, "extends")) {
        if (typeof config.extends !== "string")
          return defaultConfig;
        const isPath = /\.json|\..*rc$/.test(config.extends);
        let pathToDefault = null;
        if (!isPath) {
          try {
            pathToDefault = require.resolve(config.extends);
          } catch (_err) {
            return config;
          }
        } else {
          pathToDefault = getPathToDefaultConfig(cwd, config.extends);
        }
        checkForCircularExtends(pathToDefault);
        previouslyVisitedConfigs.push(pathToDefault);
        defaultConfig = isPath ? JSON.parse(shim.readFileSync(pathToDefault, "utf8")) : require(config.extends);
        delete config.extends;
        defaultConfig = applyExtends(defaultConfig, shim.path.dirname(pathToDefault), mergeExtends, shim);
      }
      previouslyVisitedConfigs = [];
      return mergeExtends ? mergeDeep(defaultConfig, config) : Object.assign({}, defaultConfig, config);
    }
    function checkForCircularExtends(cfgPath) {
      if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {
        throw new YError(`Circular extended configurations: '${cfgPath}'.`);
      }
    }
    function getPathToDefaultConfig(cwd, pathToExtend) {
      return shim.path.resolve(cwd, pathToExtend);
    }
    function mergeDeep(config1, config2) {
      const target = {};
      function isObject(obj) {
        return obj && typeof obj === "object" && !Array.isArray(obj);
      }
      Object.assign(target, config1);
      for (const key of Object.keys(config2)) {
        if (isObject(config2[key]) && isObject(target[key])) {
          target[key] = mergeDeep(config1[key], config2[key]);
        } else {
          target[key] = config2[key];
        }
      }
      return target;
    }
    function parseCommand(cmd) {
      const extraSpacesStrippedCommand = cmd.replace(/\s{2,}/g, " ");
      const splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/);
      const bregex = /\.*[\][<>]/g;
      const firstCommand = splitCommand.shift();
      if (!firstCommand)
        throw new Error(`No command found in: ${cmd}`);
      const parsedCommand = {
        cmd: firstCommand.replace(bregex, ""),
        demanded: [],
        optional: []
      };
      splitCommand.forEach((cmd2, i) => {
        let variadic = false;
        cmd2 = cmd2.replace(/\s/g, "");
        if (/\.+[\]>]/.test(cmd2) && i === splitCommand.length - 1)
          variadic = true;
        if (/^\[/.test(cmd2)) {
          parsedCommand.optional.push({
            cmd: cmd2.replace(bregex, "").split("|"),
            variadic
          });
        } else {
          parsedCommand.demanded.push({
            cmd: cmd2.replace(bregex, "").split("|"),
            variadic
          });
        }
      });
      return parsedCommand;
    }
    var positionName = ["first", "second", "third", "fourth", "fifth", "sixth"];
    function argsert(arg1, arg2, arg3) {
      function parseArgs() {
        return typeof arg1 === "object" ? [{demanded: [], optional: []}, arg1, arg2] : [
          parseCommand(`cmd ${arg1}`),
          arg2,
          arg3
        ];
      }
      try {
        let position = 0;
        const [parsed, callerArguments, _length] = parseArgs();
        const args = [].slice.call(callerArguments);
        while (args.length && args[args.length - 1] === void 0)
          args.pop();
        const length = _length || args.length;
        if (length < parsed.demanded.length) {
          throw new YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);
        }
        const totalCommands = parsed.demanded.length + parsed.optional.length;
        if (length > totalCommands) {
          throw new YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);
        }
        parsed.demanded.forEach((demanded) => {
          const arg = args.shift();
          const observedType = guessType(arg);
          const matchingTypes = demanded.cmd.filter((type) => type === observedType || type === "*");
          if (matchingTypes.length === 0)
            argumentTypeError(observedType, demanded.cmd, position);
          position += 1;
        });
        parsed.optional.forEach((optional) => {
          if (args.length === 0)
            return;
          const arg = args.shift();
          const observedType = guessType(arg);
          const matchingTypes = optional.cmd.filter((type) => type === observedType || type === "*");
          if (matchingTypes.length === 0)
            argumentTypeError(observedType, optional.cmd, position);
          position += 1;
        });
      } catch (err) {
        console.warn(err.stack);
      }
    }
    function guessType(arg) {
      if (Array.isArray(arg)) {
        return "array";
      } else if (arg === null) {
        return "null";
      }
      return typeof arg;
    }
    function argumentTypeError(observedType, allowedTypes, position) {
      throw new YError(`Invalid ${positionName[position] || "manyith"} argument. Expected ${allowedTypes.join(" or ")} but received ${observedType}.`);
    }
    function isPromise(maybePromise) {
      return !!maybePromise && !!maybePromise.then && typeof maybePromise.then === "function";
    }
    function assertNotStrictEqual(actual, expected, shim2, message) {
      shim2.assert.notStrictEqual(actual, expected, message);
    }
    function assertSingleKey(actual, shim2) {
      shim2.assert.strictEqual(typeof actual, "string");
    }
    function objectKeys(object) {
      return Object.keys(object);
    }
    function objFilter(original = {}, filter = () => true) {
      const obj = {};
      objectKeys(original).forEach((key) => {
        if (filter(key, original[key])) {
          obj[key] = original[key];
        }
      });
      return obj;
    }
    function globalMiddlewareFactory(globalMiddleware, context) {
      return function(callback, applyBeforeValidation = false) {
        argsert("<array|function> [boolean]", [callback, applyBeforeValidation], arguments.length);
        if (Array.isArray(callback)) {
          for (let i = 0; i < callback.length; i++) {
            if (typeof callback[i] !== "function") {
              throw Error("middleware must be a function");
            }
            callback[i].applyBeforeValidation = applyBeforeValidation;
          }
          Array.prototype.push.apply(globalMiddleware, callback);
        } else if (typeof callback === "function") {
          callback.applyBeforeValidation = applyBeforeValidation;
          globalMiddleware.push(callback);
        }
        return context;
      };
    }
    function commandMiddlewareFactory(commandMiddleware) {
      if (!commandMiddleware)
        return [];
      return commandMiddleware.map((middleware) => {
        middleware.applyBeforeValidation = false;
        return middleware;
      });
    }
    function applyMiddleware(argv, yargs, middlewares, beforeValidation) {
      const beforeValidationError = new Error("middleware cannot return a promise when applyBeforeValidation is true");
      return middlewares.reduce((acc, middleware) => {
        if (middleware.applyBeforeValidation !== beforeValidation) {
          return acc;
        }
        if (isPromise(acc)) {
          return acc.then((initialObj) => Promise.all([
            initialObj,
            middleware(initialObj, yargs)
          ])).then(([initialObj, middlewareObj]) => Object.assign(initialObj, middlewareObj));
        } else {
          const result = middleware(acc, yargs);
          if (beforeValidation && isPromise(result))
            throw beforeValidationError;
          return isPromise(result) ? result.then((middlewareObj) => Object.assign(acc, middlewareObj)) : Object.assign(acc, result);
        }
      }, argv);
    }
    function getProcessArgvBinIndex() {
      if (isBundledElectronApp())
        return 0;
      return 1;
    }
    function isBundledElectronApp() {
      return isElectronApp() && !process.defaultApp;
    }
    function isElectronApp() {
      return !!process.versions.electron;
    }
    function hideBin(argv) {
      return argv.slice(getProcessArgvBinIndex() + 1);
    }
    function getProcessArgvBin() {
      return process.argv[getProcessArgvBinIndex()];
    }
    var processArgv = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      hideBin,
      getProcessArgvBin
    });
    function whichModule(exported) {
      if (typeof require === "undefined")
        return null;
      for (let i = 0, files = Object.keys(require.cache), mod; i < files.length; i++) {
        mod = require.cache[files[i]];
        if (mod.exports === exported)
          return mod;
      }
      return null;
    }
    var DEFAULT_MARKER = /(^\*)|(^\$0)/;
    function command(yargs, usage2, validation2, globalMiddleware = [], shim2) {
      const self = {};
      let handlers = {};
      let aliasMap = {};
      let defaultCommand;
      self.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {
        let aliases = [];
        const middlewares = commandMiddlewareFactory(commandMiddleware);
        handler = handler || (() => {
        });
        if (Array.isArray(cmd)) {
          if (isCommandAndAliases(cmd)) {
            [cmd, ...aliases] = cmd;
          } else {
            for (const command2 of cmd) {
              self.addHandler(command2);
            }
          }
        } else if (isCommandHandlerDefinition(cmd)) {
          let command2 = Array.isArray(cmd.command) || typeof cmd.command === "string" ? cmd.command : moduleName(cmd);
          if (cmd.aliases)
            command2 = [].concat(command2).concat(cmd.aliases);
          self.addHandler(command2, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);
          return;
        } else if (isCommandBuilderDefinition(builder)) {
          self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);
          return;
        }
        if (typeof cmd === "string") {
          const parsedCommand = parseCommand(cmd);
          aliases = aliases.map((alias) => parseCommand(alias).cmd);
          let isDefault = false;
          const parsedAliases = [parsedCommand.cmd].concat(aliases).filter((c) => {
            if (DEFAULT_MARKER.test(c)) {
              isDefault = true;
              return false;
            }
            return true;
          });
          if (parsedAliases.length === 0 && isDefault)
            parsedAliases.push("$0");
          if (isDefault) {
            parsedCommand.cmd = parsedAliases[0];
            aliases = parsedAliases.slice(1);
            cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
          }
          aliases.forEach((alias) => {
            aliasMap[alias] = parsedCommand.cmd;
          });
          if (description !== false) {
            usage2.command(cmd, description, isDefault, aliases, deprecated);
          }
          handlers[parsedCommand.cmd] = {
            original: cmd,
            description,
            handler,
            builder: builder || {},
            middlewares,
            deprecated,
            demanded: parsedCommand.demanded,
            optional: parsedCommand.optional
          };
          if (isDefault)
            defaultCommand = handlers[parsedCommand.cmd];
        }
      };
      self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {
        opts = opts || {};
        if (typeof opts.recurse !== "boolean")
          opts.recurse = false;
        if (!Array.isArray(opts.extensions))
          opts.extensions = ["js"];
        const parentVisit = typeof opts.visit === "function" ? opts.visit : (o) => o;
        opts.visit = function visit(obj, joined, filename) {
          const visited = parentVisit(obj, joined, filename);
          if (visited) {
            if (~context.files.indexOf(joined))
              return visited;
            context.files.push(joined);
            self.addHandler(visited);
          }
          return visited;
        };
        shim2.requireDirectory({require: req, filename: callerFile}, dir, opts);
      };
      function moduleName(obj) {
        const mod = whichModule(obj);
        if (!mod)
          throw new Error(`No command name given for module: ${shim2.inspect(obj)}`);
        return commandFromFilename(mod.filename);
      }
      function commandFromFilename(filename) {
        return shim2.path.basename(filename, shim2.path.extname(filename));
      }
      function extractDesc({describe, description, desc}) {
        for (const test of [describe, description, desc]) {
          if (typeof test === "string" || test === false)
            return test;
          assertNotStrictEqual(test, true, shim2);
        }
        return false;
      }
      self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap));
      self.getCommandHandlers = () => handlers;
      self.hasDefaultCommand = () => !!defaultCommand;
      self.runCommand = function runCommand(command2, yargs2, parsed, commandIndex) {
        let aliases = parsed.aliases;
        const commandHandler = handlers[command2] || handlers[aliasMap[command2]] || defaultCommand;
        const currentContext = yargs2.getContext();
        let numFiles = currentContext.files.length;
        const parentCommands = currentContext.commands.slice();
        let innerArgv = parsed.argv;
        let positionalMap = {};
        if (command2) {
          currentContext.commands.push(command2);
          currentContext.fullCommands.push(commandHandler.original);
        }
        const builder = commandHandler.builder;
        if (isCommandBuilderCallback(builder)) {
          const builderOutput = builder(yargs2.reset(parsed.aliases));
          const innerYargs = isYargsInstance(builderOutput) ? builderOutput : yargs2;
          if (shouldUpdateUsage(innerYargs)) {
            innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
          }
          innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);
          aliases = innerYargs.parsed.aliases;
        } else if (isCommandBuilderOptionDefinitions(builder)) {
          const innerYargs = yargs2.reset(parsed.aliases);
          if (shouldUpdateUsage(innerYargs)) {
            innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
          }
          Object.keys(commandHandler.builder).forEach((key) => {
            innerYargs.option(key, builder[key]);
          });
          innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);
          aliases = innerYargs.parsed.aliases;
        }
        if (!yargs2._hasOutput()) {
          positionalMap = populatePositionals(commandHandler, innerArgv, currentContext);
        }
        const middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares);
        applyMiddleware(innerArgv, yargs2, middlewares, true);
        if (!yargs2._hasOutput()) {
          yargs2._runValidation(innerArgv, aliases, positionalMap, yargs2.parsed.error, !command2);
        }
        if (commandHandler.handler && !yargs2._hasOutput()) {
          yargs2._setHasOutput();
          const populateDoubleDash = !!yargs2.getOptions().configuration["populate--"];
          yargs2._postProcess(innerArgv, populateDoubleDash);
          innerArgv = applyMiddleware(innerArgv, yargs2, middlewares, false);
          let handlerResult;
          if (isPromise(innerArgv)) {
            handlerResult = innerArgv.then((argv) => commandHandler.handler(argv));
          } else {
            handlerResult = commandHandler.handler(innerArgv);
          }
          const handlerFinishCommand = yargs2.getHandlerFinishCommand();
          if (isPromise(handlerResult)) {
            yargs2.getUsageInstance().cacheHelpMessage();
            handlerResult.then((value) => {
              if (handlerFinishCommand) {
                handlerFinishCommand(value);
              }
            }).catch((error) => {
              try {
                yargs2.getUsageInstance().fail(null, error);
              } catch (err) {
              }
            }).then(() => {
              yargs2.getUsageInstance().clearCachedHelpMessage();
            });
          } else {
            if (handlerFinishCommand) {
              handlerFinishCommand(handlerResult);
            }
          }
        }
        if (command2) {
          currentContext.commands.pop();
          currentContext.fullCommands.pop();
        }
        numFiles = currentContext.files.length - numFiles;
        if (numFiles > 0)
          currentContext.files.splice(numFiles * -1, numFiles);
        return innerArgv;
      };
      function shouldUpdateUsage(yargs2) {
        return !yargs2.getUsageInstance().getUsageDisabled() && yargs2.getUsageInstance().getUsage().length === 0;
      }
      function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {
        const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, "").trim() : commandHandler.original;
        const pc = parentCommands.filter((c2) => {
          return !DEFAULT_MARKER.test(c2);
        });
        pc.push(c);
        return `$0 ${pc.join(" ")}`;
      }
      self.runDefaultBuilderOn = function(yargs2) {
        assertNotStrictEqual(defaultCommand, void 0, shim2);
        if (shouldUpdateUsage(yargs2)) {
          const commandString = DEFAULT_MARKER.test(defaultCommand.original) ? defaultCommand.original : defaultCommand.original.replace(/^[^[\]<>]*/, "$0 ");
          yargs2.getUsageInstance().usage(commandString, defaultCommand.description);
        }
        const builder = defaultCommand.builder;
        if (isCommandBuilderCallback(builder)) {
          builder(yargs2);
        } else if (!isCommandBuilderDefinition(builder)) {
          Object.keys(builder).forEach((key) => {
            yargs2.option(key, builder[key]);
          });
        }
      };
      function populatePositionals(commandHandler, argv, context) {
        argv._ = argv._.slice(context.commands.length);
        const demanded = commandHandler.demanded.slice(0);
        const optional = commandHandler.optional.slice(0);
        const positionalMap = {};
        validation2.positionalCount(demanded.length, argv._.length);
        while (demanded.length) {
          const demand = demanded.shift();
          populatePositional(demand, argv, positionalMap);
        }
        while (optional.length) {
          const maybe = optional.shift();
          populatePositional(maybe, argv, positionalMap);
        }
        argv._ = context.commands.concat(argv._.map((a) => "" + a));
        postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));
        return positionalMap;
      }
      function populatePositional(positional, argv, positionalMap) {
        const cmd = positional.cmd[0];
        if (positional.variadic) {
          positionalMap[cmd] = argv._.splice(0).map(String);
        } else {
          if (argv._.length)
            positionalMap[cmd] = [String(argv._.shift())];
        }
      }
      function postProcessPositionals(argv, positionalMap, parseOptions) {
        const options = Object.assign({}, yargs.getOptions());
        options.default = Object.assign(parseOptions.default, options.default);
        for (const key of Object.keys(parseOptions.alias)) {
          options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);
        }
        options.array = options.array.concat(parseOptions.array);
        options.config = {};
        const unparsed = [];
        Object.keys(positionalMap).forEach((key) => {
          positionalMap[key].map((value) => {
            if (options.configuration["unknown-options-as-args"])
              options.key[key] = true;
            unparsed.push(`--${key}`);
            unparsed.push(value);
          });
        });
        if (!unparsed.length)
          return;
        const config = Object.assign({}, options.configuration, {
          "populate--": true
        });
        const parsed = shim2.Parser.detailed(unparsed, Object.assign({}, options, {
          configuration: config
        }));
        if (parsed.error) {
          yargs.getUsageInstance().fail(parsed.error.message, parsed.error);
        } else {
          const positionalKeys = Object.keys(positionalMap);
          Object.keys(positionalMap).forEach((key) => {
            positionalKeys.push(...parsed.aliases[key]);
          });
          Object.keys(parsed.argv).forEach((key) => {
            if (positionalKeys.indexOf(key) !== -1) {
              if (!positionalMap[key])
                positionalMap[key] = parsed.argv[key];
              argv[key] = parsed.argv[key];
            }
          });
        }
      }
      self.cmdToParseOptions = function(cmdString) {
        const parseOptions = {
          array: [],
          default: {},
          alias: {},
          demand: {}
        };
        const parsed = parseCommand(cmdString);
        parsed.demanded.forEach((d) => {
          const [cmd, ...aliases] = d.cmd;
          if (d.variadic) {
            parseOptions.array.push(cmd);
            parseOptions.default[cmd] = [];
          }
          parseOptions.alias[cmd] = aliases;
          parseOptions.demand[cmd] = true;
        });
        parsed.optional.forEach((o) => {
          const [cmd, ...aliases] = o.cmd;
          if (o.variadic) {
            parseOptions.array.push(cmd);
            parseOptions.default[cmd] = [];
          }
          parseOptions.alias[cmd] = aliases;
        });
        return parseOptions;
      };
      self.reset = () => {
        handlers = {};
        aliasMap = {};
        defaultCommand = void 0;
        return self;
      };
      const frozens = [];
      self.freeze = () => {
        frozens.push({
          handlers,
          aliasMap,
          defaultCommand
        });
      };
      self.unfreeze = () => {
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, void 0, shim2);
        ({handlers, aliasMap, defaultCommand} = frozen);
      };
      return self;
    }
    function isCommandBuilderDefinition(builder) {
      return typeof builder === "object" && !!builder.builder && typeof builder.handler === "function";
    }
    function isCommandAndAliases(cmd) {
      if (cmd.every((c) => typeof c === "string")) {
        return true;
      } else {
        return false;
      }
    }
    function isCommandBuilderCallback(builder) {
      return typeof builder === "function";
    }
    function isCommandBuilderOptionDefinitions(builder) {
      return typeof builder === "object";
    }
    function isCommandHandlerDefinition(cmd) {
      return typeof cmd === "object" && !Array.isArray(cmd);
    }
    function setBlocking(blocking) {
      if (typeof process === "undefined")
        return;
      [process.stdout, process.stderr].forEach((_stream) => {
        const stream = _stream;
        if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === "function") {
          stream._handle.setBlocking(blocking);
        }
      });
    }
    function usage(yargs, y18n2, shim2) {
      const __ = y18n2.__;
      const self = {};
      const fails = [];
      self.failFn = function failFn(f) {
        fails.push(f);
      };
      let failMessage = null;
      let showHelpOnFail = true;
      self.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) {
        function parseFunctionArgs() {
          return typeof arg1 === "string" ? [true, arg1] : [arg1, arg2];
        }
        const [enabled, message] = parseFunctionArgs();
        failMessage = message;
        showHelpOnFail = enabled;
        return self;
      };
      let failureOutput = false;
      self.fail = function fail(msg, err) {
        const logger = yargs._getLoggerInstance();
        if (fails.length) {
          for (let i = fails.length - 1; i >= 0; --i) {
            fails[i](msg, err, self);
          }
        } else {
          if (yargs.getExitProcess())
            setBlocking(true);
          if (!failureOutput) {
            failureOutput = true;
            if (showHelpOnFail) {
              yargs.showHelp("error");
              logger.error();
            }
            if (msg || err)
              logger.error(msg || err);
            if (failMessage) {
              if (msg || err)
                logger.error("");
              logger.error(failMessage);
            }
          }
          err = err || new YError(msg);
          if (yargs.getExitProcess()) {
            return yargs.exit(1);
          } else if (yargs._hasParseCallback()) {
            return yargs.exit(1, err);
          } else {
            throw err;
          }
        }
      };
      let usages = [];
      let usageDisabled = false;
      self.usage = (msg, description) => {
        if (msg === null) {
          usageDisabled = true;
          usages = [];
          return self;
        }
        usageDisabled = false;
        usages.push([msg, description || ""]);
        return self;
      };
      self.getUsage = () => {
        return usages;
      };
      self.getUsageDisabled = () => {
        return usageDisabled;
      };
      self.getPositionalGroupName = () => {
        return __("Positionals:");
      };
      let examples = [];
      self.example = (cmd, description) => {
        examples.push([cmd, description || ""]);
      };
      let commands = [];
      self.command = function command2(cmd, description, isDefault, aliases, deprecated = false) {
        if (isDefault) {
          commands = commands.map((cmdArray) => {
            cmdArray[2] = false;
            return cmdArray;
          });
        }
        commands.push([cmd, description || "", isDefault, aliases, deprecated]);
      };
      self.getCommands = () => commands;
      let descriptions = {};
      self.describe = function describe(keyOrKeys, desc) {
        if (Array.isArray(keyOrKeys)) {
          keyOrKeys.forEach((k) => {
            self.describe(k, desc);
          });
        } else if (typeof keyOrKeys === "object") {
          Object.keys(keyOrKeys).forEach((k) => {
            self.describe(k, keyOrKeys[k]);
          });
        } else {
          descriptions[keyOrKeys] = desc;
        }
      };
      self.getDescriptions = () => descriptions;
      let epilogs = [];
      self.epilog = (msg) => {
        epilogs.push(msg);
      };
      let wrapSet = false;
      let wrap;
      self.wrap = (cols) => {
        wrapSet = true;
        wrap = cols;
      };
      function getWrap() {
        if (!wrapSet) {
          wrap = windowWidth();
          wrapSet = true;
        }
        return wrap;
      }
      const deferY18nLookupPrefix = "__yargsString__:";
      self.deferY18nLookup = (str) => deferY18nLookupPrefix + str;
      self.help = function help() {
        if (cachedHelpMessage)
          return cachedHelpMessage;
        normalizeAliases();
        const base$0 = yargs.customScriptName ? yargs.$0 : shim2.path.basename(yargs.$0);
        const demandedOptions = yargs.getDemandedOptions();
        const demandedCommands = yargs.getDemandedCommands();
        const deprecatedOptions = yargs.getDeprecatedOptions();
        const groups = yargs.getGroups();
        const options = yargs.getOptions();
        let keys = [];
        keys = keys.concat(Object.keys(descriptions));
        keys = keys.concat(Object.keys(demandedOptions));
        keys = keys.concat(Object.keys(demandedCommands));
        keys = keys.concat(Object.keys(options.default));
        keys = keys.filter(filterHiddenOptions);
        keys = Object.keys(keys.reduce((acc, key) => {
          if (key !== "_")
            acc[key] = true;
          return acc;
        }, {}));
        const theWrap = getWrap();
        const ui = shim2.cliui({
          width: theWrap,
          wrap: !!theWrap
        });
        if (!usageDisabled) {
          if (usages.length) {
            usages.forEach((usage2) => {
              ui.div(`${usage2[0].replace(/\$0/g, base$0)}`);
              if (usage2[1]) {
                ui.div({text: `${usage2[1]}`, padding: [1, 0, 0, 0]});
              }
            });
            ui.div();
          } else if (commands.length) {
            let u = null;
            if (demandedCommands._) {
              u = `${base$0} <${__("command")}>
`;
            } else {
              u = `${base$0} [${__("command")}]
`;
            }
            ui.div(`${u}`);
          }
        }
        if (commands.length) {
          ui.div(__("Commands:"));
          const context = yargs.getContext();
          const parentCommands = context.commands.length ? `${context.commands.join(" ")} ` : "";
          if (yargs.getParserConfiguration()["sort-commands"] === true) {
            commands = commands.sort((a, b) => a[0].localeCompare(b[0]));
          }
          commands.forEach((command2) => {
            const commandString = `${base$0} ${parentCommands}${command2[0].replace(/^\$0 ?/, "")}`;
            ui.span({
              text: commandString,
              padding: [0, 2, 0, 2],
              width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4
            }, {text: command2[1]});
            const hints = [];
            if (command2[2])
              hints.push(`[${__("default")}]`);
            if (command2[3] && command2[3].length) {
              hints.push(`[${__("aliases:")} ${command2[3].join(", ")}]`);
            }
            if (command2[4]) {
              if (typeof command2[4] === "string") {
                hints.push(`[${__("deprecated: %s", command2[4])}]`);
              } else {
                hints.push(`[${__("deprecated")}]`);
              }
            }
            if (hints.length) {
              ui.div({
                text: hints.join(" "),
                padding: [0, 0, 0, 2],
                align: "right"
              });
            } else {
              ui.div();
            }
          });
          ui.div();
        }
        const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);
        keys = keys.filter((key) => !yargs.parsed.newAliases[key] && aliasKeys.every((alias) => (options.alias[alias] || []).indexOf(key) === -1));
        const defaultGroup = __("Options:");
        if (!groups[defaultGroup])
          groups[defaultGroup] = [];
        addUngroupedKeys(keys, options.alias, groups, defaultGroup);
        const isLongSwitch = (sw) => /^--/.test(getText(sw));
        const displayedGroups = Object.keys(groups).filter((groupName) => groups[groupName].length > 0).map((groupName) => {
          const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key) => {
            if (~aliasKeys.indexOf(key))
              return key;
            for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== void 0; i++) {
              if (~(options.alias[aliasKey] || []).indexOf(key))
                return aliasKey;
            }
            return key;
          });
          return {groupName, normalizedKeys};
        }).filter(({normalizedKeys}) => normalizedKeys.length > 0).map(({groupName, normalizedKeys}) => {
          const switches = normalizedKeys.reduce((acc, key) => {
            acc[key] = [key].concat(options.alias[key] || []).map((sw) => {
              if (groupName === self.getPositionalGroupName())
                return sw;
              else {
                return (/^[0-9]$/.test(sw) ? ~options.boolean.indexOf(key) ? "-" : "--" : sw.length > 1 ? "--" : "-") + sw;
              }
            }).sort((sw1, sw2) => isLongSwitch(sw1) === isLongSwitch(sw2) ? 0 : isLongSwitch(sw1) ? 1 : -1).join(", ");
            return acc;
          }, {});
          return {groupName, normalizedKeys, switches};
        });
        const shortSwitchesUsed = displayedGroups.filter(({groupName}) => groupName !== self.getPositionalGroupName()).some(({normalizedKeys, switches}) => !normalizedKeys.every((key) => isLongSwitch(switches[key])));
        if (shortSwitchesUsed) {
          displayedGroups.filter(({groupName}) => groupName !== self.getPositionalGroupName()).forEach(({normalizedKeys, switches}) => {
            normalizedKeys.forEach((key) => {
              if (isLongSwitch(switches[key])) {
                switches[key] = addIndentation(switches[key], "-x, ".length);
              }
            });
          });
        }
        displayedGroups.forEach(({groupName, normalizedKeys, switches}) => {
          ui.div(groupName);
          normalizedKeys.forEach((key) => {
            const kswitch = switches[key];
            let desc = descriptions[key] || "";
            let type = null;
            if (~desc.lastIndexOf(deferY18nLookupPrefix))
              desc = __(desc.substring(deferY18nLookupPrefix.length));
            if (~options.boolean.indexOf(key))
              type = `[${__("boolean")}]`;
            if (~options.count.indexOf(key))
              type = `[${__("count")}]`;
            if (~options.string.indexOf(key))
              type = `[${__("string")}]`;
            if (~options.normalize.indexOf(key))
              type = `[${__("string")}]`;
            if (~options.array.indexOf(key))
              type = `[${__("array")}]`;
            if (~options.number.indexOf(key))
              type = `[${__("number")}]`;
            const deprecatedExtra = (deprecated) => typeof deprecated === "string" ? `[${__("deprecated: %s", deprecated)}]` : `[${__("deprecated")}]`;
            const extra = [
              key in deprecatedOptions ? deprecatedExtra(deprecatedOptions[key]) : null,
              type,
              key in demandedOptions ? `[${__("required")}]` : null,
              options.choices && options.choices[key] ? `[${__("choices:")} ${self.stringifiedValues(options.choices[key])}]` : null,
              defaultString(options.default[key], options.defaultDescription[key])
            ].filter(Boolean).join(" ");
            ui.span({
              text: getText(kswitch),
              padding: [0, 2, 0, 2 + getIndentation(kswitch)],
              width: maxWidth(switches, theWrap) + 4
            }, desc);
            if (extra)
              ui.div({text: extra, padding: [0, 0, 0, 2], align: "right"});
            else
              ui.div();
          });
          ui.div();
        });
        if (examples.length) {
          ui.div(__("Examples:"));
          examples.forEach((example) => {
            example[0] = example[0].replace(/\$0/g, base$0);
          });
          examples.forEach((example) => {
            if (example[1] === "") {
              ui.div({
                text: example[0],
                padding: [0, 2, 0, 2]
              });
            } else {
              ui.div({
                text: example[0],
                padding: [0, 2, 0, 2],
                width: maxWidth(examples, theWrap) + 4
              }, {
                text: example[1]
              });
            }
          });
          ui.div();
        }
        if (epilogs.length > 0) {
          const e = epilogs.map((epilog) => epilog.replace(/\$0/g, base$0)).join("\n");
          ui.div(`${e}
`);
        }
        return ui.toString().replace(/\s*$/, "");
      };
      function maxWidth(table, theWrap, modifier) {
        let width = 0;
        if (!Array.isArray(table)) {
          table = Object.values(table).map((v) => [v]);
        }
        table.forEach((v) => {
          width = Math.max(shim2.stringWidth(modifier ? `${modifier} ${getText(v[0])}` : getText(v[0])) + getIndentation(v[0]), width);
        });
        if (theWrap)
          width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
        return width;
      }
      function normalizeAliases() {
        const demandedOptions = yargs.getDemandedOptions();
        const options = yargs.getOptions();
        (Object.keys(options.alias) || []).forEach((key) => {
          options.alias[key].forEach((alias) => {
            if (descriptions[alias])
              self.describe(key, descriptions[alias]);
            if (alias in demandedOptions)
              yargs.demandOption(key, demandedOptions[alias]);
            if (~options.boolean.indexOf(alias))
              yargs.boolean(key);
            if (~options.count.indexOf(alias))
              yargs.count(key);
            if (~options.string.indexOf(alias))
              yargs.string(key);
            if (~options.normalize.indexOf(alias))
              yargs.normalize(key);
            if (~options.array.indexOf(alias))
              yargs.array(key);
            if (~options.number.indexOf(alias))
              yargs.number(key);
          });
        });
      }
      let cachedHelpMessage;
      self.cacheHelpMessage = function() {
        cachedHelpMessage = this.help();
      };
      self.clearCachedHelpMessage = function() {
        cachedHelpMessage = void 0;
      };
      function addUngroupedKeys(keys, aliases, groups, defaultGroup) {
        let groupedKeys = [];
        let toCheck = null;
        Object.keys(groups).forEach((group) => {
          groupedKeys = groupedKeys.concat(groups[group]);
        });
        keys.forEach((key) => {
          toCheck = [key].concat(aliases[key]);
          if (!toCheck.some((k) => groupedKeys.indexOf(k) !== -1)) {
            groups[defaultGroup].push(key);
          }
        });
        return groupedKeys;
      }
      function filterHiddenOptions(key) {
        return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt];
      }
      self.showHelp = (level) => {
        const logger = yargs._getLoggerInstance();
        if (!level)
          level = "error";
        const emit = typeof level === "function" ? level : logger[level];
        emit(self.help());
      };
      self.functionDescription = (fn) => {
        const description = fn.name ? shim2.Parser.decamelize(fn.name, "-") : __("generated-value");
        return ["(", description, ")"].join("");
      };
      self.stringifiedValues = function stringifiedValues(values, separator) {
        let string = "";
        const sep = separator || ", ";
        const array = [].concat(values);
        if (!values || !array.length)
          return string;
        array.forEach((value) => {
          if (string.length)
            string += sep;
          string += JSON.stringify(value);
        });
        return string;
      };
      function defaultString(value, defaultDescription) {
        let string = `[${__("default:")} `;
        if (value === void 0 && !defaultDescription)
          return null;
        if (defaultDescription) {
          string += defaultDescription;
        } else {
          switch (typeof value) {
            case "string":
              string += `"${value}"`;
              break;
            case "object":
              string += JSON.stringify(value);
              break;
            default:
              string += value;
          }
        }
        return `${string}]`;
      }
      function windowWidth() {
        const maxWidth2 = 80;
        if (shim2.process.stdColumns) {
          return Math.min(maxWidth2, shim2.process.stdColumns);
        } else {
          return maxWidth2;
        }
      }
      let version = null;
      self.version = (ver) => {
        version = ver;
      };
      self.showVersion = () => {
        const logger = yargs._getLoggerInstance();
        logger.log(version);
      };
      self.reset = function reset(localLookup) {
        failMessage = null;
        failureOutput = false;
        usages = [];
        usageDisabled = false;
        epilogs = [];
        examples = [];
        commands = [];
        descriptions = objFilter(descriptions, (k) => !localLookup[k]);
        return self;
      };
      const frozens = [];
      self.freeze = function freeze() {
        frozens.push({
          failMessage,
          failureOutput,
          usages,
          usageDisabled,
          epilogs,
          examples,
          commands,
          descriptions
        });
      };
      self.unfreeze = function unfreeze() {
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, void 0, shim2);
        ({
          failMessage,
          failureOutput,
          usages,
          usageDisabled,
          epilogs,
          examples,
          commands,
          descriptions
        } = frozen);
      };
      return self;
    }
    function isIndentedText(text) {
      return typeof text === "object";
    }
    function addIndentation(text, indent) {
      return isIndentedText(text) ? {text: text.text, indentation: text.indentation + indent} : {text, indentation: indent};
    }
    function getIndentation(text) {
      return isIndentedText(text) ? text.indentation : 0;
    }
    function getText(text) {
      return isIndentedText(text) ? text.text : text;
    }
    var completionShTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc
#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.
#
_yargs_completions()
{
    local cur_word args type_list

    cur_word="\${COMP_WORDS[COMP_CWORD]}"
    args=("\${COMP_WORDS[@]}")

    # ask yargs to generate completions.
    type_list=$({{app_path}} --get-yargs-completions "\${args[@]}")

    COMPREPLY=( $(compgen -W "\${type_list}" -- \${cur_word}) )

    # if no match was found, fall back to filename completion
    if [ \${#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=()
    fi

    return 0
}
complete -o default -F _yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
    var completionZshTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zsh_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'
' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
    function completion(yargs, usage2, command2, shim2) {
      const self = {
        completionKey: "get-yargs-completions"
      };
      let aliases;
      self.setParsed = function setParsed(parsed) {
        aliases = parsed.aliases;
      };
      const zshShell = shim2.getEnv("SHELL") && shim2.getEnv("SHELL").indexOf("zsh") !== -1 || shim2.getEnv("ZSH_NAME") && shim2.getEnv("ZSH_NAME").indexOf("zsh") !== -1;
      self.getCompletion = function getCompletion(args, done) {
        const completions = [];
        const current = args.length ? args[args.length - 1] : "";
        const argv = yargs.parse(args, true);
        const parentCommands = yargs.getContext().commands;
        function runCompletionFunction(argv2) {
          assertNotStrictEqual(completionFunction, null, shim2);
          if (isSyncCompletionFunction(completionFunction)) {
            const result = completionFunction(current, argv2);
            if (isPromise(result)) {
              return result.then((list) => {
                shim2.process.nextTick(() => {
                  done(list);
                });
              }).catch((err) => {
                shim2.process.nextTick(() => {
                  throw err;
                });
              });
            }
            return done(result);
          } else {
            return completionFunction(current, argv2, (completions2) => {
              done(completions2);
            });
          }
        }
        if (completionFunction) {
          return isPromise(argv) ? argv.then(runCompletionFunction) : runCompletionFunction(argv);
        }
        const handlers = command2.getCommandHandlers();
        for (let i = 0, ii = args.length; i < ii; ++i) {
          if (handlers[args[i]] && handlers[args[i]].builder) {
            const builder = handlers[args[i]].builder;
            if (isCommandBuilderCallback(builder)) {
              const y = yargs.reset();
              builder(y);
              return y.argv;
            }
          }
        }
        if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current) {
          usage2.getCommands().forEach((usageCommand) => {
            const commandName = parseCommand(usageCommand[0]).cmd;
            if (args.indexOf(commandName) === -1) {
              if (!zshShell) {
                completions.push(commandName);
              } else {
                const desc = usageCommand[1] || "";
                completions.push(commandName.replace(/:/g, "\\:") + ":" + desc);
              }
            }
          });
        }
        if (current.match(/^-/) || current === "" && completions.length === 0) {
          const descs = usage2.getDescriptions();
          const options = yargs.getOptions();
          Object.keys(options.key).forEach((key) => {
            const negable = !!options.configuration["boolean-negation"] && options.boolean.includes(key);
            let keyAndAliases = [key].concat(aliases[key] || []);
            if (negable)
              keyAndAliases = keyAndAliases.concat(keyAndAliases.map((key2) => `no-${key2}`));
            function completeOptionKey(key2) {
              const notInArgs = keyAndAliases.every((val) => args.indexOf(`--${val}`) === -1);
              if (notInArgs) {
                const startsByTwoDashes = (s) => /^--/.test(s);
                const isShortOption = (s) => /^[^0-9]$/.test(s);
                const dashes = !startsByTwoDashes(current) && isShortOption(key2) ? "-" : "--";
                if (!zshShell) {
                  completions.push(dashes + key2);
                } else {
                  const desc = descs[key2] || "";
                  completions.push(dashes + `${key2.replace(/:/g, "\\:")}:${desc.replace("__yargsString__:", "")}`);
                }
              }
            }
            completeOptionKey(key);
            if (negable && !!options.default[key])
              completeOptionKey(`no-${key}`);
          });
        }
        done(completions);
      };
      self.generateCompletionScript = function generateCompletionScript($0, cmd) {
        let script = zshShell ? completionZshTemplate : completionShTemplate;
        const name = shim2.path.basename($0);
        if ($0.match(/\.js$/))
          $0 = `./${$0}`;
        script = script.replace(/{{app_name}}/g, name);
        script = script.replace(/{{completion_command}}/g, cmd);
        return script.replace(/{{app_path}}/g, $0);
      };
      let completionFunction = null;
      self.registerFunction = (fn) => {
        completionFunction = fn;
      };
      return self;
    }
    function isSyncCompletionFunction(completionFunction) {
      return completionFunction.length < 3;
    }
    function levenshtein(a, b) {
      if (a.length === 0)
        return b.length;
      if (b.length === 0)
        return a.length;
      const matrix = [];
      let i;
      for (i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      }
      let j;
      for (j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      }
      for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) === a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
          }
        }
      }
      return matrix[b.length][a.length];
    }
    var specialKeys = ["$0", "--", "_"];
    function validation(yargs, usage2, y18n2, shim2) {
      const __ = y18n2.__;
      const __n = y18n2.__n;
      const self = {};
      self.nonOptionCount = function nonOptionCount(argv) {
        const demandedCommands = yargs.getDemandedCommands();
        const positionalCount = argv._.length + (argv["--"] ? argv["--"].length : 0);
        const _s = positionalCount - yargs.getContext().commands.length;
        if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {
          if (_s < demandedCommands._.min) {
            if (demandedCommands._.minMsg !== void 0) {
              usage2.fail(demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.min.toString()) : null);
            } else {
              usage2.fail(__n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", _s, _s.toString(), demandedCommands._.min.toString()));
            }
          } else if (_s > demandedCommands._.max) {
            if (demandedCommands._.maxMsg !== void 0) {
              usage2.fail(demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.max.toString()) : null);
            } else {
              usage2.fail(__n("Too many non-option arguments: got %s, maximum of %s", "Too many non-option arguments: got %s, maximum of %s", _s, _s.toString(), demandedCommands._.max.toString()));
            }
          }
        }
      };
      self.positionalCount = function positionalCount(required, observed) {
        if (observed < required) {
          usage2.fail(__n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", observed, observed + "", required + ""));
        }
      };
      self.requiredArguments = function requiredArguments(argv) {
        const demandedOptions = yargs.getDemandedOptions();
        let missing = null;
        for (const key of Object.keys(demandedOptions)) {
          if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === "undefined") {
            missing = missing || {};
            missing[key] = demandedOptions[key];
          }
        }
        if (missing) {
          const customMsgs = [];
          for (const key of Object.keys(missing)) {
            const msg = missing[key];
            if (msg && customMsgs.indexOf(msg) < 0) {
              customMsgs.push(msg);
            }
          }
          const customMsg = customMsgs.length ? `
${customMsgs.join("\n")}` : "";
          usage2.fail(__n("Missing required argument: %s", "Missing required arguments: %s", Object.keys(missing).length, Object.keys(missing).join(", ") + customMsg));
        }
      };
      self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {
        const commandKeys = yargs.getCommandInstance().getCommands();
        const unknown = [];
        const currentContext = yargs.getContext();
        Object.keys(argv).forEach((key) => {
          if (specialKeys.indexOf(key) === -1 && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) && !self.isValidAndSomeAliasIsNotNew(key, aliases)) {
            unknown.push(key);
          }
        });
        if (checkPositionals && (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand)) {
          argv._.slice(currentContext.commands.length).forEach((key) => {
            if (commandKeys.indexOf("" + key) === -1) {
              unknown.push("" + key);
            }
          });
        }
        if (unknown.length > 0) {
          usage2.fail(__n("Unknown argument: %s", "Unknown arguments: %s", unknown.length, unknown.join(", ")));
        }
      };
      self.unknownCommands = function unknownCommands(argv) {
        const commandKeys = yargs.getCommandInstance().getCommands();
        const unknown = [];
        const currentContext = yargs.getContext();
        if (currentContext.commands.length > 0 || commandKeys.length > 0) {
          argv._.slice(currentContext.commands.length).forEach((key) => {
            if (commandKeys.indexOf("" + key) === -1) {
              unknown.push("" + key);
            }
          });
        }
        if (unknown.length > 0) {
          usage2.fail(__n("Unknown command: %s", "Unknown commands: %s", unknown.length, unknown.join(", ")));
          return true;
        } else {
          return false;
        }
      };
      self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {
        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {
          return false;
        }
        const newAliases = yargs.parsed.newAliases;
        for (const a of [key, ...aliases[key]]) {
          if (!Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]) {
            return true;
          }
        }
        return false;
      };
      self.limitedChoices = function limitedChoices(argv) {
        const options = yargs.getOptions();
        const invalid = {};
        if (!Object.keys(options.choices).length)
          return;
        Object.keys(argv).forEach((key) => {
          if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {
            [].concat(argv[key]).forEach((value) => {
              if (options.choices[key].indexOf(value) === -1 && value !== void 0) {
                invalid[key] = (invalid[key] || []).concat(value);
              }
            });
          }
        });
        const invalidKeys = Object.keys(invalid);
        if (!invalidKeys.length)
          return;
        let msg = __("Invalid values:");
        invalidKeys.forEach((key) => {
          msg += `
  ${__("Argument: %s, Given: %s, Choices: %s", key, usage2.stringifiedValues(invalid[key]), usage2.stringifiedValues(options.choices[key]))}`;
        });
        usage2.fail(msg);
      };
      let checks = [];
      self.check = function check(f, global) {
        checks.push({
          func: f,
          global
        });
      };
      self.customChecks = function customChecks(argv, aliases) {
        for (let i = 0, f; (f = checks[i]) !== void 0; i++) {
          const func = f.func;
          let result = null;
          try {
            result = func(argv, aliases);
          } catch (err) {
            usage2.fail(err.message ? err.message : err, err);
            continue;
          }
          if (!result) {
            usage2.fail(__("Argument check failed: %s", func.toString()));
          } else if (typeof result === "string" || result instanceof Error) {
            usage2.fail(result.toString(), result);
          }
        }
      };
      let implied = {};
      self.implies = function implies(key, value) {
        argsert("<string|object> [array|number|string]", [key, value], arguments.length);
        if (typeof key === "object") {
          Object.keys(key).forEach((k) => {
            self.implies(k, key[k]);
          });
        } else {
          yargs.global(key);
          if (!implied[key]) {
            implied[key] = [];
          }
          if (Array.isArray(value)) {
            value.forEach((i) => self.implies(key, i));
          } else {
            assertNotStrictEqual(value, void 0, shim2);
            implied[key].push(value);
          }
        }
      };
      self.getImplied = function getImplied() {
        return implied;
      };
      function keyExists(argv, val) {
        const num = Number(val);
        val = isNaN(num) ? val : num;
        if (typeof val === "number") {
          val = argv._.length >= val;
        } else if (val.match(/^--no-.+/)) {
          val = val.match(/^--no-(.+)/)[1];
          val = !argv[val];
        } else {
          val = argv[val];
        }
        return val;
      }
      self.implications = function implications(argv) {
        const implyFail = [];
        Object.keys(implied).forEach((key) => {
          const origKey = key;
          (implied[key] || []).forEach((value) => {
            let key2 = origKey;
            const origValue = value;
            key2 = keyExists(argv, key2);
            value = keyExists(argv, value);
            if (key2 && !value) {
              implyFail.push(` ${origKey} -> ${origValue}`);
            }
          });
        });
        if (implyFail.length) {
          let msg = `${__("Implications failed:")}
`;
          implyFail.forEach((value) => {
            msg += value;
          });
          usage2.fail(msg);
        }
      };
      let conflicting = {};
      self.conflicts = function conflicts(key, value) {
        argsert("<string|object> [array|string]", [key, value], arguments.length);
        if (typeof key === "object") {
          Object.keys(key).forEach((k) => {
            self.conflicts(k, key[k]);
          });
        } else {
          yargs.global(key);
          if (!conflicting[key]) {
            conflicting[key] = [];
          }
          if (Array.isArray(value)) {
            value.forEach((i) => self.conflicts(key, i));
          } else {
            conflicting[key].push(value);
          }
        }
      };
      self.getConflicting = () => conflicting;
      self.conflicting = function conflictingFn(argv) {
        Object.keys(argv).forEach((key) => {
          if (conflicting[key]) {
            conflicting[key].forEach((value) => {
              if (value && argv[key] !== void 0 && argv[value] !== void 0) {
                usage2.fail(__("Arguments %s and %s are mutually exclusive", key, value));
              }
            });
          }
        });
      };
      self.recommendCommands = function recommendCommands(cmd, potentialCommands) {
        const threshold = 3;
        potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);
        let recommended = null;
        let bestDistance = Infinity;
        for (let i = 0, candidate; (candidate = potentialCommands[i]) !== void 0; i++) {
          const d = levenshtein(cmd, candidate);
          if (d <= threshold && d < bestDistance) {
            bestDistance = d;
            recommended = candidate;
          }
        }
        if (recommended)
          usage2.fail(__("Did you mean %s?", recommended));
      };
      self.reset = function reset(localLookup) {
        implied = objFilter(implied, (k) => !localLookup[k]);
        conflicting = objFilter(conflicting, (k) => !localLookup[k]);
        checks = checks.filter((c) => c.global);
        return self;
      };
      const frozens = [];
      self.freeze = function freeze() {
        frozens.push({
          implied,
          checks,
          conflicting
        });
      };
      self.unfreeze = function unfreeze() {
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, void 0, shim2);
        ({implied, checks, conflicting} = frozen);
      };
      return self;
    }
    var shim$1;
    function YargsWithShim(_shim) {
      shim$1 = _shim;
      return Yargs;
    }
    function Yargs(processArgs = [], cwd = shim$1.process.cwd(), parentRequire) {
      const self = {};
      let command$1;
      let completion$1 = null;
      let groups = {};
      const globalMiddleware = [];
      let output = "";
      const preservedGroups = {};
      let usage$1;
      let validation$1;
      let handlerFinishCommand = null;
      const y18n2 = shim$1.y18n;
      self.middleware = globalMiddlewareFactory(globalMiddleware, self);
      self.scriptName = function(scriptName) {
        self.customScriptName = true;
        self.$0 = scriptName;
        return self;
      };
      let default$0;
      if (/\b(node|iojs|electron)(\.exe)?$/.test(shim$1.process.argv()[0])) {
        default$0 = shim$1.process.argv().slice(1, 2);
      } else {
        default$0 = shim$1.process.argv().slice(0, 1);
      }
      self.$0 = default$0.map((x) => {
        const b = rebase(cwd, x);
        return x.match(/^(\/|([a-zA-Z]:)?\\)/) && b.length < x.length ? b : x;
      }).join(" ").trim();
      if (shim$1.getEnv("_") && shim$1.getProcessArgvBin() === shim$1.getEnv("_")) {
        self.$0 = shim$1.getEnv("_").replace(`${shim$1.path.dirname(shim$1.process.execPath())}/`, "");
      }
      const context = {resets: -1, commands: [], fullCommands: [], files: []};
      self.getContext = () => context;
      let hasOutput = false;
      let exitError = null;
      self.exit = (code, err) => {
        hasOutput = true;
        exitError = err;
        if (exitProcess)
          shim$1.process.exit(code);
      };
      let completionCommand = null;
      self.completion = function(cmd, desc, fn) {
        argsert("[string] [string|boolean|function] [function]", [cmd, desc, fn], arguments.length);
        if (typeof desc === "function") {
          fn = desc;
          desc = void 0;
        }
        completionCommand = cmd || completionCommand || "completion";
        if (!desc && desc !== false) {
          desc = "generate completion script";
        }
        self.command(completionCommand, desc);
        if (fn)
          completion$1.registerFunction(fn);
        return self;
      };
      let options;
      self.resetOptions = self.reset = function resetOptions(aliases = {}) {
        context.resets++;
        options = options || {};
        const tmpOptions = {};
        tmpOptions.local = options.local ? options.local : [];
        tmpOptions.configObjects = options.configObjects ? options.configObjects : [];
        const localLookup = {};
        tmpOptions.local.forEach((l) => {
          localLookup[l] = true;
          (aliases[l] || []).forEach((a) => {
            localLookup[a] = true;
          });
        });
        Object.assign(preservedGroups, Object.keys(groups).reduce((acc, groupName) => {
          const keys = groups[groupName].filter((key) => !(key in localLookup));
          if (keys.length > 0) {
            acc[groupName] = keys;
          }
          return acc;
        }, {}));
        groups = {};
        const arrayOptions = [
          "array",
          "boolean",
          "string",
          "skipValidation",
          "count",
          "normalize",
          "number",
          "hiddenOptions"
        ];
        const objectOptions = [
          "narg",
          "key",
          "alias",
          "default",
          "defaultDescription",
          "config",
          "choices",
          "demandedOptions",
          "demandedCommands",
          "coerce",
          "deprecatedOptions"
        ];
        arrayOptions.forEach((k) => {
          tmpOptions[k] = (options[k] || []).filter((k2) => !localLookup[k2]);
        });
        objectOptions.forEach((k) => {
          tmpOptions[k] = objFilter(options[k], (k2) => !localLookup[k2]);
        });
        tmpOptions.envPrefix = options.envPrefix;
        options = tmpOptions;
        usage$1 = usage$1 ? usage$1.reset(localLookup) : usage(self, y18n2, shim$1);
        validation$1 = validation$1 ? validation$1.reset(localLookup) : validation(self, usage$1, y18n2, shim$1);
        command$1 = command$1 ? command$1.reset() : command(self, usage$1, validation$1, globalMiddleware, shim$1);
        if (!completion$1)
          completion$1 = completion(self, usage$1, command$1, shim$1);
        completionCommand = null;
        output = "";
        exitError = null;
        hasOutput = false;
        self.parsed = false;
        return self;
      };
      self.resetOptions();
      const frozens = [];
      function freeze() {
        frozens.push({
          options,
          configObjects: options.configObjects.slice(0),
          exitProcess,
          groups,
          strict,
          strictCommands,
          strictOptions,
          completionCommand,
          output,
          exitError,
          hasOutput,
          parsed: self.parsed,
          parseFn,
          parseContext,
          handlerFinishCommand
        });
        usage$1.freeze();
        validation$1.freeze();
        command$1.freeze();
      }
      function unfreeze() {
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, void 0, shim$1);
        let configObjects;
        ({
          options,
          configObjects,
          exitProcess,
          groups,
          output,
          exitError,
          hasOutput,
          parsed: self.parsed,
          strict,
          strictCommands,
          strictOptions,
          completionCommand,
          parseFn,
          parseContext,
          handlerFinishCommand
        } = frozen);
        options.configObjects = configObjects;
        usage$1.unfreeze();
        validation$1.unfreeze();
        command$1.unfreeze();
      }
      self.boolean = function(keys) {
        argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("boolean", keys);
        return self;
      };
      self.array = function(keys) {
        argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("array", keys);
        return self;
      };
      self.number = function(keys) {
        argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("number", keys);
        return self;
      };
      self.normalize = function(keys) {
        argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("normalize", keys);
        return self;
      };
      self.count = function(keys) {
        argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("count", keys);
        return self;
      };
      self.string = function(keys) {
        argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("string", keys);
        return self;
      };
      self.requiresArg = function(keys) {
        argsert("<array|string|object> [number]", [keys], arguments.length);
        if (typeof keys === "string" && options.narg[keys]) {
          return self;
        } else {
          populateParserHintSingleValueDictionary(self.requiresArg, "narg", keys, NaN);
        }
        return self;
      };
      self.skipValidation = function(keys) {
        argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("skipValidation", keys);
        return self;
      };
      function populateParserHintArray(type, keys) {
        keys = [].concat(keys);
        keys.forEach((key) => {
          key = sanitizeKey(key);
          options[type].push(key);
        });
      }
      self.nargs = function(key, value) {
        argsert("<string|object|array> [number]", [key, value], arguments.length);
        populateParserHintSingleValueDictionary(self.nargs, "narg", key, value);
        return self;
      };
      self.choices = function(key, value) {
        argsert("<object|string|array> [string|array]", [key, value], arguments.length);
        populateParserHintArrayDictionary(self.choices, "choices", key, value);
        return self;
      };
      self.alias = function(key, value) {
        argsert("<object|string|array> [string|array]", [key, value], arguments.length);
        populateParserHintArrayDictionary(self.alias, "alias", key, value);
        return self;
      };
      self.default = self.defaults = function(key, value, defaultDescription) {
        argsert("<object|string|array> [*] [string]", [key, value, defaultDescription], arguments.length);
        if (defaultDescription) {
          assertSingleKey(key, shim$1);
          options.defaultDescription[key] = defaultDescription;
        }
        if (typeof value === "function") {
          assertSingleKey(key, shim$1);
          if (!options.defaultDescription[key])
            options.defaultDescription[key] = usage$1.functionDescription(value);
          value = value.call();
        }
        populateParserHintSingleValueDictionary(self.default, "default", key, value);
        return self;
      };
      self.describe = function(key, desc) {
        argsert("<object|string|array> [string]", [key, desc], arguments.length);
        setKey(key, true);
        usage$1.describe(key, desc);
        return self;
      };
      function setKey(key, set) {
        populateParserHintSingleValueDictionary(setKey, "key", key, set);
        return self;
      }
      function demandOption(keys, msg) {
        argsert("<object|string|array> [string]", [keys, msg], arguments.length);
        populateParserHintSingleValueDictionary(self.demandOption, "demandedOptions", keys, msg);
        return self;
      }
      self.demandOption = demandOption;
      self.coerce = function(keys, value) {
        argsert("<object|string|array> [function]", [keys, value], arguments.length);
        populateParserHintSingleValueDictionary(self.coerce, "coerce", keys, value);
        return self;
      };
      function populateParserHintSingleValueDictionary(builder, type, key, value) {
        populateParserHintDictionary(builder, type, key, value, (type2, key2, value2) => {
          options[type2][key2] = value2;
        });
      }
      function populateParserHintArrayDictionary(builder, type, key, value) {
        populateParserHintDictionary(builder, type, key, value, (type2, key2, value2) => {
          options[type2][key2] = (options[type2][key2] || []).concat(value2);
        });
      }
      function populateParserHintDictionary(builder, type, key, value, singleKeyHandler) {
        if (Array.isArray(key)) {
          key.forEach((k) => {
            builder(k, value);
          });
        } else if (((key2) => typeof key2 === "object")(key)) {
          for (const k of objectKeys(key)) {
            builder(k, key[k]);
          }
        } else {
          singleKeyHandler(type, sanitizeKey(key), value);
        }
      }
      function sanitizeKey(key) {
        if (key === "__proto__")
          return "___proto___";
        return key;
      }
      function deleteFromParserHintObject(optionKey) {
        objectKeys(options).forEach((hintKey) => {
          if (((key) => key === "configObjects")(hintKey))
            return;
          const hint = options[hintKey];
          if (Array.isArray(hint)) {
            if (~hint.indexOf(optionKey))
              hint.splice(hint.indexOf(optionKey), 1);
          } else if (typeof hint === "object") {
            delete hint[optionKey];
          }
        });
        delete usage$1.getDescriptions()[optionKey];
      }
      self.config = function config(key = "config", msg, parseFn2) {
        argsert("[object|string] [string|function] [function]", [key, msg, parseFn2], arguments.length);
        if (typeof key === "object" && !Array.isArray(key)) {
          key = applyExtends(key, cwd, self.getParserConfiguration()["deep-merge-config"] || false, shim$1);
          options.configObjects = (options.configObjects || []).concat(key);
          return self;
        }
        if (typeof msg === "function") {
          parseFn2 = msg;
          msg = void 0;
        }
        self.describe(key, msg || usage$1.deferY18nLookup("Path to JSON config file"));
        (Array.isArray(key) ? key : [key]).forEach((k) => {
          options.config[k] = parseFn2 || true;
        });
        return self;
      };
      self.example = function(cmd, description) {
        argsert("<string|array> [string]", [cmd, description], arguments.length);
        if (Array.isArray(cmd)) {
          cmd.forEach((exampleParams) => self.example(...exampleParams));
        } else {
          usage$1.example(cmd, description);
        }
        return self;
      };
      self.command = function(cmd, description, builder, handler, middlewares, deprecated) {
        argsert("<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]", [cmd, description, builder, handler, middlewares, deprecated], arguments.length);
        command$1.addHandler(cmd, description, builder, handler, middlewares, deprecated);
        return self;
      };
      self.commandDir = function(dir, opts) {
        argsert("<string> [object]", [dir, opts], arguments.length);
        const req = parentRequire || shim$1.require;
        command$1.addDirectory(dir, self.getContext(), req, shim$1.getCallerFile(), opts);
        return self;
      };
      self.demand = self.required = self.require = function demand(keys, max, msg) {
        if (Array.isArray(max)) {
          max.forEach((key) => {
            assertNotStrictEqual(msg, true, shim$1);
            demandOption(key, msg);
          });
          max = Infinity;
        } else if (typeof max !== "number") {
          msg = max;
          max = Infinity;
        }
        if (typeof keys === "number") {
          assertNotStrictEqual(msg, true, shim$1);
          self.demandCommand(keys, max, msg, msg);
        } else if (Array.isArray(keys)) {
          keys.forEach((key) => {
            assertNotStrictEqual(msg, true, shim$1);
            demandOption(key, msg);
          });
        } else {
          if (typeof msg === "string") {
            demandOption(keys, msg);
          } else if (msg === true || typeof msg === "undefined") {
            demandOption(keys);
          }
        }
        return self;
      };
      self.demandCommand = function demandCommand(min = 1, max, minMsg, maxMsg) {
        argsert("[number] [number|string] [string|null|undefined] [string|null|undefined]", [min, max, minMsg, maxMsg], arguments.length);
        if (typeof max !== "number") {
          minMsg = max;
          max = Infinity;
        }
        self.global("_", false);
        options.demandedCommands._ = {
          min,
          max,
          minMsg,
          maxMsg
        };
        return self;
      };
      self.getDemandedOptions = () => {
        argsert([], 0);
        return options.demandedOptions;
      };
      self.getDemandedCommands = () => {
        argsert([], 0);
        return options.demandedCommands;
      };
      self.deprecateOption = function deprecateOption(option, message) {
        argsert("<string> [string|boolean]", [option, message], arguments.length);
        options.deprecatedOptions[option] = message;
        return self;
      };
      self.getDeprecatedOptions = () => {
        argsert([], 0);
        return options.deprecatedOptions;
      };
      self.implies = function(key, value) {
        argsert("<string|object> [number|string|array]", [key, value], arguments.length);
        validation$1.implies(key, value);
        return self;
      };
      self.conflicts = function(key1, key2) {
        argsert("<string|object> [string|array]", [key1, key2], arguments.length);
        validation$1.conflicts(key1, key2);
        return self;
      };
      self.usage = function(msg, description, builder, handler) {
        argsert("<string|null|undefined> [string|boolean] [function|object] [function]", [msg, description, builder, handler], arguments.length);
        if (description !== void 0) {
          assertNotStrictEqual(msg, null, shim$1);
          if ((msg || "").match(/^\$0( |$)/)) {
            return self.command(msg, description, builder, handler);
          } else {
            throw new YError(".usage() description must start with $0 if being used as alias for .command()");
          }
        } else {
          usage$1.usage(msg);
          return self;
        }
      };
      self.epilogue = self.epilog = function(msg) {
        argsert("<string>", [msg], arguments.length);
        usage$1.epilog(msg);
        return self;
      };
      self.fail = function(f) {
        argsert("<function>", [f], arguments.length);
        usage$1.failFn(f);
        return self;
      };
      self.onFinishCommand = function(f) {
        argsert("<function>", [f], arguments.length);
        handlerFinishCommand = f;
        return self;
      };
      self.getHandlerFinishCommand = () => handlerFinishCommand;
      self.check = function(f, _global) {
        argsert("<function> [boolean]", [f, _global], arguments.length);
        validation$1.check(f, _global !== false);
        return self;
      };
      self.global = function global(globals, global) {
        argsert("<string|array> [boolean]", [globals, global], arguments.length);
        globals = [].concat(globals);
        if (global !== false) {
          options.local = options.local.filter((l) => globals.indexOf(l) === -1);
        } else {
          globals.forEach((g) => {
            if (options.local.indexOf(g) === -1)
              options.local.push(g);
          });
        }
        return self;
      };
      self.pkgConf = function pkgConf(key, rootPath) {
        argsert("<string> [string]", [key, rootPath], arguments.length);
        let conf = null;
        const obj = pkgUp(rootPath || cwd);
        if (obj[key] && typeof obj[key] === "object") {
          conf = applyExtends(obj[key], rootPath || cwd, self.getParserConfiguration()["deep-merge-config"] || false, shim$1);
          options.configObjects = (options.configObjects || []).concat(conf);
        }
        return self;
      };
      const pkgs = {};
      function pkgUp(rootPath) {
        const npath = rootPath || "*";
        if (pkgs[npath])
          return pkgs[npath];
        let obj = {};
        try {
          let startDir = rootPath || shim$1.mainFilename;
          if (!rootPath && shim$1.path.extname(startDir)) {
            startDir = shim$1.path.dirname(startDir);
          }
          const pkgJsonPath = shim$1.findUp(startDir, (dir, names) => {
            if (names.includes("package.json")) {
              return "package.json";
            } else {
              return void 0;
            }
          });
          assertNotStrictEqual(pkgJsonPath, void 0, shim$1);
          obj = JSON.parse(shim$1.readFileSync(pkgJsonPath, "utf8"));
        } catch (_noop) {
        }
        pkgs[npath] = obj || {};
        return pkgs[npath];
      }
      let parseFn = null;
      let parseContext = null;
      self.parse = function parse(args, shortCircuit, _parseFn) {
        argsert("[string|array] [function|boolean|object] [function]", [args, shortCircuit, _parseFn], arguments.length);
        freeze();
        if (typeof args === "undefined") {
          const argv = self._parseArgs(processArgs);
          const tmpParsed = self.parsed;
          unfreeze();
          self.parsed = tmpParsed;
          return argv;
        }
        if (typeof shortCircuit === "object") {
          parseContext = shortCircuit;
          shortCircuit = _parseFn;
        }
        if (typeof shortCircuit === "function") {
          parseFn = shortCircuit;
          shortCircuit = false;
        }
        if (!shortCircuit)
          processArgs = args;
        if (parseFn)
          exitProcess = false;
        const parsed = self._parseArgs(args, !!shortCircuit);
        completion$1.setParsed(self.parsed);
        if (parseFn)
          parseFn(exitError, parsed, output);
        unfreeze();
        return parsed;
      };
      self._getParseContext = () => parseContext || {};
      self._hasParseCallback = () => !!parseFn;
      self.option = self.options = function option(key, opt) {
        argsert("<string|object> [object]", [key, opt], arguments.length);
        if (typeof key === "object") {
          Object.keys(key).forEach((k) => {
            self.options(k, key[k]);
          });
        } else {
          if (typeof opt !== "object") {
            opt = {};
          }
          options.key[key] = true;
          if (opt.alias)
            self.alias(key, opt.alias);
          const deprecate = opt.deprecate || opt.deprecated;
          if (deprecate) {
            self.deprecateOption(key, deprecate);
          }
          const demand = opt.demand || opt.required || opt.require;
          if (demand) {
            self.demand(key, demand);
          }
          if (opt.demandOption) {
            self.demandOption(key, typeof opt.demandOption === "string" ? opt.demandOption : void 0);
          }
          if (opt.conflicts) {
            self.conflicts(key, opt.conflicts);
          }
          if ("default" in opt) {
            self.default(key, opt.default);
          }
          if (opt.implies !== void 0) {
            self.implies(key, opt.implies);
          }
          if (opt.nargs !== void 0) {
            self.nargs(key, opt.nargs);
          }
          if (opt.config) {
            self.config(key, opt.configParser);
          }
          if (opt.normalize) {
            self.normalize(key);
          }
          if (opt.choices) {
            self.choices(key, opt.choices);
          }
          if (opt.coerce) {
            self.coerce(key, opt.coerce);
          }
          if (opt.group) {
            self.group(key, opt.group);
          }
          if (opt.boolean || opt.type === "boolean") {
            self.boolean(key);
            if (opt.alias)
              self.boolean(opt.alias);
          }
          if (opt.array || opt.type === "array") {
            self.array(key);
            if (opt.alias)
              self.array(opt.alias);
          }
          if (opt.number || opt.type === "number") {
            self.number(key);
            if (opt.alias)
              self.number(opt.alias);
          }
          if (opt.string || opt.type === "string") {
            self.string(key);
            if (opt.alias)
              self.string(opt.alias);
          }
          if (opt.count || opt.type === "count") {
            self.count(key);
          }
          if (typeof opt.global === "boolean") {
            self.global(key, opt.global);
          }
          if (opt.defaultDescription) {
            options.defaultDescription[key] = opt.defaultDescription;
          }
          if (opt.skipValidation) {
            self.skipValidation(key);
          }
          const desc = opt.describe || opt.description || opt.desc;
          self.describe(key, desc);
          if (opt.hidden) {
            self.hide(key);
          }
          if (opt.requiresArg) {
            self.requiresArg(key);
          }
        }
        return self;
      };
      self.getOptions = () => options;
      self.positional = function(key, opts) {
        argsert("<string> <object>", [key, opts], arguments.length);
        if (context.resets === 0) {
          throw new YError(".positional() can only be called in a command's builder function");
        }
        const supportedOpts = [
          "default",
          "defaultDescription",
          "implies",
          "normalize",
          "choices",
          "conflicts",
          "coerce",
          "type",
          "describe",
          "desc",
          "description",
          "alias"
        ];
        opts = objFilter(opts, (k, v) => {
          let accept = supportedOpts.indexOf(k) !== -1;
          if (k === "type" && ["string", "number", "boolean"].indexOf(v) === -1)
            accept = false;
          return accept;
        });
        const fullCommand = context.fullCommands[context.fullCommands.length - 1];
        const parseOptions = fullCommand ? command$1.cmdToParseOptions(fullCommand) : {
          array: [],
          alias: {},
          default: {},
          demand: {}
        };
        objectKeys(parseOptions).forEach((pk) => {
          const parseOption = parseOptions[pk];
          if (Array.isArray(parseOption)) {
            if (parseOption.indexOf(key) !== -1)
              opts[pk] = true;
          } else {
            if (parseOption[key] && !(pk in opts))
              opts[pk] = parseOption[key];
          }
        });
        self.group(key, usage$1.getPositionalGroupName());
        return self.option(key, opts);
      };
      self.group = function group(opts, groupName) {
        argsert("<string|array> <string>", [opts, groupName], arguments.length);
        const existing = preservedGroups[groupName] || groups[groupName];
        if (preservedGroups[groupName]) {
          delete preservedGroups[groupName];
        }
        const seen = {};
        groups[groupName] = (existing || []).concat(opts).filter((key) => {
          if (seen[key])
            return false;
          return seen[key] = true;
        });
        return self;
      };
      self.getGroups = () => Object.assign({}, groups, preservedGroups);
      self.env = function(prefix) {
        argsert("[string|boolean]", [prefix], arguments.length);
        if (prefix === false)
          delete options.envPrefix;
        else
          options.envPrefix = prefix || "";
        return self;
      };
      self.wrap = function(cols) {
        argsert("<number|null|undefined>", [cols], arguments.length);
        usage$1.wrap(cols);
        return self;
      };
      let strict = false;
      self.strict = function(enabled) {
        argsert("[boolean]", [enabled], arguments.length);
        strict = enabled !== false;
        return self;
      };
      self.getStrict = () => strict;
      let strictCommands = false;
      self.strictCommands = function(enabled) {
        argsert("[boolean]", [enabled], arguments.length);
        strictCommands = enabled !== false;
        return self;
      };
      self.getStrictCommands = () => strictCommands;
      let strictOptions = false;
      self.strictOptions = function(enabled) {
        argsert("[boolean]", [enabled], arguments.length);
        strictOptions = enabled !== false;
        return self;
      };
      self.getStrictOptions = () => strictOptions;
      let parserConfig = {};
      self.parserConfiguration = function parserConfiguration(config) {
        argsert("<object>", [config], arguments.length);
        parserConfig = config;
        return self;
      };
      self.getParserConfiguration = () => parserConfig;
      self.showHelp = function(level) {
        argsert("[string|function]", [level], arguments.length);
        if (!self.parsed)
          self._parseArgs(processArgs);
        if (command$1.hasDefaultCommand()) {
          context.resets++;
          command$1.runDefaultBuilderOn(self);
        }
        usage$1.showHelp(level);
        return self;
      };
      let versionOpt = null;
      self.version = function version(opt, msg, ver) {
        const defaultVersionOpt = "version";
        argsert("[boolean|string] [string] [string]", [opt, msg, ver], arguments.length);
        if (versionOpt) {
          deleteFromParserHintObject(versionOpt);
          usage$1.version(void 0);
          versionOpt = null;
        }
        if (arguments.length === 0) {
          ver = guessVersion();
          opt = defaultVersionOpt;
        } else if (arguments.length === 1) {
          if (opt === false) {
            return self;
          }
          ver = opt;
          opt = defaultVersionOpt;
        } else if (arguments.length === 2) {
          ver = msg;
          msg = void 0;
        }
        versionOpt = typeof opt === "string" ? opt : defaultVersionOpt;
        msg = msg || usage$1.deferY18nLookup("Show version number");
        usage$1.version(ver || void 0);
        self.boolean(versionOpt);
        self.describe(versionOpt, msg);
        return self;
      };
      function guessVersion() {
        const obj = pkgUp();
        return obj.version || "unknown";
      }
      let helpOpt = null;
      self.addHelpOpt = self.help = function addHelpOpt(opt, msg) {
        const defaultHelpOpt = "help";
        argsert("[string|boolean] [string]", [opt, msg], arguments.length);
        if (helpOpt) {
          deleteFromParserHintObject(helpOpt);
          helpOpt = null;
        }
        if (arguments.length === 1) {
          if (opt === false)
            return self;
        }
        helpOpt = typeof opt === "string" ? opt : defaultHelpOpt;
        self.boolean(helpOpt);
        self.describe(helpOpt, msg || usage$1.deferY18nLookup("Show help"));
        return self;
      };
      const defaultShowHiddenOpt = "show-hidden";
      options.showHiddenOpt = defaultShowHiddenOpt;
      self.addShowHiddenOpt = self.showHidden = function addShowHiddenOpt(opt, msg) {
        argsert("[string|boolean] [string]", [opt, msg], arguments.length);
        if (arguments.length === 1) {
          if (opt === false)
            return self;
        }
        const showHiddenOpt = typeof opt === "string" ? opt : defaultShowHiddenOpt;
        self.boolean(showHiddenOpt);
        self.describe(showHiddenOpt, msg || usage$1.deferY18nLookup("Show hidden options"));
        options.showHiddenOpt = showHiddenOpt;
        return self;
      };
      self.hide = function hide(key) {
        argsert("<string>", [key], arguments.length);
        options.hiddenOptions.push(key);
        return self;
      };
      self.showHelpOnFail = function showHelpOnFail(enabled, message) {
        argsert("[boolean|string] [string]", [enabled, message], arguments.length);
        usage$1.showHelpOnFail(enabled, message);
        return self;
      };
      let exitProcess = true;
      self.exitProcess = function(enabled = true) {
        argsert("[boolean]", [enabled], arguments.length);
        exitProcess = enabled;
        return self;
      };
      self.getExitProcess = () => exitProcess;
      self.showCompletionScript = function($0, cmd) {
        argsert("[string] [string]", [$0, cmd], arguments.length);
        $0 = $0 || self.$0;
        _logger.log(completion$1.generateCompletionScript($0, cmd || completionCommand || "completion"));
        return self;
      };
      self.getCompletion = function(args, done) {
        argsert("<array> <function>", [args, done], arguments.length);
        completion$1.getCompletion(args, done);
      };
      self.locale = function(locale) {
        argsert("[string]", [locale], arguments.length);
        if (!locale) {
          guessLocale();
          return y18n2.getLocale();
        }
        detectLocale = false;
        y18n2.setLocale(locale);
        return self;
      };
      self.updateStrings = self.updateLocale = function(obj) {
        argsert("<object>", [obj], arguments.length);
        detectLocale = false;
        y18n2.updateLocale(obj);
        return self;
      };
      let detectLocale = true;
      self.detectLocale = function(detect) {
        argsert("<boolean>", [detect], arguments.length);
        detectLocale = detect;
        return self;
      };
      self.getDetectLocale = () => detectLocale;
      const _logger = {
        log(...args) {
          if (!self._hasParseCallback())
            console.log(...args);
          hasOutput = true;
          if (output.length)
            output += "\n";
          output += args.join(" ");
        },
        error(...args) {
          if (!self._hasParseCallback())
            console.error(...args);
          hasOutput = true;
          if (output.length)
            output += "\n";
          output += args.join(" ");
        }
      };
      self._getLoggerInstance = () => _logger;
      self._hasOutput = () => hasOutput;
      self._setHasOutput = () => {
        hasOutput = true;
      };
      let recommendCommands;
      self.recommendCommands = function(recommend = true) {
        argsert("[boolean]", [recommend], arguments.length);
        recommendCommands = recommend;
        return self;
      };
      self.getUsageInstance = () => usage$1;
      self.getValidationInstance = () => validation$1;
      self.getCommandInstance = () => command$1;
      self.terminalWidth = () => {
        argsert([], 0);
        return shim$1.process.stdColumns;
      };
      Object.defineProperty(self, "argv", {
        get: () => self._parseArgs(processArgs),
        enumerable: true
      });
      self._parseArgs = function parseArgs(args, shortCircuit, _calledFromCommand, commandIndex) {
        let skipValidation = !!_calledFromCommand;
        args = args || processArgs;
        options.__ = y18n2.__;
        options.configuration = self.getParserConfiguration();
        const populateDoubleDash = !!options.configuration["populate--"];
        const config = Object.assign({}, options.configuration, {
          "populate--": true
        });
        const parsed = shim$1.Parser.detailed(args, Object.assign({}, options, {
          configuration: Object.assign({"parse-positional-numbers": false}, config)
        }));
        let argv = parsed.argv;
        if (parseContext)
          argv = Object.assign({}, argv, parseContext);
        const aliases = parsed.aliases;
        argv.$0 = self.$0;
        self.parsed = parsed;
        try {
          guessLocale();
          if (shortCircuit) {
            return self._postProcess(argv, populateDoubleDash, _calledFromCommand);
          }
          if (helpOpt) {
            const helpCmds = [helpOpt].concat(aliases[helpOpt] || []).filter((k) => k.length > 1);
            if (~helpCmds.indexOf("" + argv._[argv._.length - 1])) {
              argv._.pop();
              argv[helpOpt] = true;
            }
          }
          const handlerKeys = command$1.getCommands();
          const requestCompletions = completion$1.completionKey in argv;
          const skipRecommendation = argv[helpOpt] || requestCompletions;
          const skipDefaultCommand = skipRecommendation && (handlerKeys.length > 1 || handlerKeys[0] !== "$0");
          if (argv._.length) {
            if (handlerKeys.length) {
              let firstUnknownCommand;
              for (let i = commandIndex || 0, cmd; argv._[i] !== void 0; i++) {
                cmd = String(argv._[i]);
                if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {
                  const innerArgv = command$1.runCommand(cmd, self, parsed, i + 1);
                  return self._postProcess(innerArgv, populateDoubleDash);
                } else if (!firstUnknownCommand && cmd !== completionCommand) {
                  firstUnknownCommand = cmd;
                  break;
                }
              }
              if (command$1.hasDefaultCommand() && !skipDefaultCommand) {
                const innerArgv = command$1.runCommand(null, self, parsed);
                return self._postProcess(innerArgv, populateDoubleDash);
              }
              if (recommendCommands && firstUnknownCommand && !skipRecommendation) {
                validation$1.recommendCommands(firstUnknownCommand, handlerKeys);
              }
            }
            if (completionCommand && ~argv._.indexOf(completionCommand) && !requestCompletions) {
              if (exitProcess)
                setBlocking(true);
              self.showCompletionScript();
              self.exit(0);
            }
          } else if (command$1.hasDefaultCommand() && !skipDefaultCommand) {
            const innerArgv = command$1.runCommand(null, self, parsed);
            return self._postProcess(innerArgv, populateDoubleDash);
          }
          if (requestCompletions) {
            if (exitProcess)
              setBlocking(true);
            args = [].concat(args);
            const completionArgs = args.slice(args.indexOf(`--${completion$1.completionKey}`) + 1);
            completion$1.getCompletion(completionArgs, (completions) => {
              (completions || []).forEach((completion2) => {
                _logger.log(completion2);
              });
              self.exit(0);
            });
            return self._postProcess(argv, !populateDoubleDash, _calledFromCommand);
          }
          if (!hasOutput) {
            Object.keys(argv).forEach((key) => {
              if (key === helpOpt && argv[key]) {
                if (exitProcess)
                  setBlocking(true);
                skipValidation = true;
                self.showHelp("log");
                self.exit(0);
              } else if (key === versionOpt && argv[key]) {
                if (exitProcess)
                  setBlocking(true);
                skipValidation = true;
                usage$1.showVersion();
                self.exit(0);
              }
            });
          }
          if (!skipValidation && options.skipValidation.length > 0) {
            skipValidation = Object.keys(argv).some((key) => options.skipValidation.indexOf(key) >= 0 && argv[key] === true);
          }
          if (!skipValidation) {
            if (parsed.error)
              throw new YError(parsed.error.message);
            if (!requestCompletions) {
              self._runValidation(argv, aliases, {}, parsed.error);
            }
          }
        } catch (err) {
          if (err instanceof YError)
            usage$1.fail(err.message, err);
          else
            throw err;
        }
        return self._postProcess(argv, populateDoubleDash, _calledFromCommand);
      };
      self._postProcess = function(argv, populateDoubleDash, calledFromCommand = false) {
        if (isPromise(argv))
          return argv;
        if (calledFromCommand)
          return argv;
        if (!populateDoubleDash) {
          argv = self._copyDoubleDash(argv);
        }
        const parsePositionalNumbers = self.getParserConfiguration()["parse-positional-numbers"] || self.getParserConfiguration()["parse-positional-numbers"] === void 0;
        if (parsePositionalNumbers) {
          argv = self._parsePositionalNumbers(argv);
        }
        return argv;
      };
      self._copyDoubleDash = function(argv) {
        if (!argv._ || !argv["--"])
          return argv;
        argv._.push.apply(argv._, argv["--"]);
        try {
          delete argv["--"];
        } catch (_err) {
        }
        return argv;
      };
      self._parsePositionalNumbers = function(argv) {
        const args = argv["--"] ? argv["--"] : argv._;
        for (let i = 0, arg; (arg = args[i]) !== void 0; i++) {
          if (shim$1.Parser.looksLikeNumber(arg) && Number.isSafeInteger(Math.floor(parseFloat(`${arg}`)))) {
            args[i] = Number(arg);
          }
        }
        return argv;
      };
      self._runValidation = function runValidation(argv, aliases, positionalMap, parseErrors, isDefaultCommand = false) {
        if (parseErrors)
          throw new YError(parseErrors.message);
        validation$1.nonOptionCount(argv);
        validation$1.requiredArguments(argv);
        let failedStrictCommands = false;
        if (strictCommands) {
          failedStrictCommands = validation$1.unknownCommands(argv);
        }
        if (strict && !failedStrictCommands) {
          validation$1.unknownArguments(argv, aliases, positionalMap, isDefaultCommand);
        } else if (strictOptions) {
          validation$1.unknownArguments(argv, aliases, {}, false, false);
        }
        validation$1.customChecks(argv, aliases);
        validation$1.limitedChoices(argv);
        validation$1.implications(argv);
        validation$1.conflicting(argv);
      };
      function guessLocale() {
        if (!detectLocale)
          return;
        const locale = shim$1.getEnv("LC_ALL") || shim$1.getEnv("LC_MESSAGES") || shim$1.getEnv("LANG") || shim$1.getEnv("LANGUAGE") || "en_US";
        self.locale(locale.replace(/[.:].*/, ""));
      }
      self.help();
      self.version();
      return self;
    }
    var rebase = (base, dir) => shim$1.path.relative(base, dir);
    function isYargsInstance(y) {
      return !!y && typeof y._parseArgs === "function";
    }
    var _a;
    var _b;
    var {readFileSync} = require("fs");
    var {inspect} = require("util");
    var {resolve} = require("path");
    var y18n = require_build();
    var Parser = require_build2();
    var cjsPlatformShim = {
      assert: {
        notStrictEqual: assert.notStrictEqual,
        strictEqual: assert.strictEqual
      },
      cliui: require_build3(),
      findUp: require_sync(),
      getEnv: (key) => {
        return process.env[key];
      },
      getCallerFile: require_get_caller_file(),
      getProcessArgvBin,
      inspect,
      mainFilename: (_b = (_a = require === null || require === void 0 ? void 0 : require.main) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : process.cwd(),
      Parser,
      path: require("path"),
      process: {
        argv: () => process.argv,
        cwd: process.cwd,
        execPath: () => process.execPath,
        exit: (code) => {
          process.exit(code);
        },
        nextTick: process.nextTick,
        stdColumns: typeof process.stdout.columns !== "undefined" ? process.stdout.columns : null
      },
      readFileSync,
      require,
      requireDirectory: require_require_directory(),
      stringWidth: require_string_width(),
      y18n: y18n({
        directory: resolve(__dirname, "../locales"),
        updateFiles: false
      })
    };
    var minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 10;
    if (process && process.version) {
      const major = Number(process.version.match(/v([^.]+)/)[1]);
      if (major < minNodeVersion) {
        throw Error(`yargs supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs#supported-nodejs-versions`);
      }
    }
    var Parser$1 = require_build2();
    var Yargs$1 = YargsWithShim(cjsPlatformShim);
    var cjs = {
      applyExtends,
      cjsPlatformShim,
      Yargs: Yargs$1,
      argsert,
      globalMiddlewareFactory,
      isPromise,
      objFilter,
      parseCommand,
      Parser: Parser$1,
      processArgv,
      rebase,
      YError
    };
    module2.exports = cjs;
  }
});

// .pnpm/yargs@16.2.0/node_modules/yargs/index.cjs
var require_yargs = __commonJS({
  ".pnpm/yargs@16.2.0/node_modules/yargs/index.cjs"(exports2, module2) {
    "use strict";
    var {Yargs, processArgv} = require_build4();
    Argv(processArgv.hideBin(process.argv));
    module2.exports = Argv;
    function Argv(processArgs, cwd) {
      const argv = Yargs(processArgs, cwd, require);
      singletonify(argv);
      return argv;
    }
    function singletonify(inst) {
      Object.keys(inst).forEach((key) => {
        if (key === "argv") {
          Argv.__defineGetter__(key, inst.__lookupGetter__(key));
        } else if (typeof inst[key] === "function") {
          Argv[key] = inst[key].bind(inst);
        } else {
          Argv.__defineGetter__("$0", () => {
            return inst.$0;
          });
          Argv.__defineGetter__("parsed", () => {
            return inst.parsed;
          });
        }
      });
    }
  }
});

// .pnpm/kleur@3.0.3/node_modules/kleur/index.js
var require_kleur = __commonJS({
  ".pnpm/kleur@3.0.3/node_modules/kleur/index.js"(exports2, module2) {
    "use strict";
    var {FORCE_COLOR, NODE_DISABLE_COLORS, TERM} = process.env;
    var $ = {
      enabled: !NODE_DISABLE_COLORS && TERM !== "dumb" && FORCE_COLOR !== "0",
      reset: init(0, 0),
      bold: init(1, 22),
      dim: init(2, 22),
      italic: init(3, 23),
      underline: init(4, 24),
      inverse: init(7, 27),
      hidden: init(8, 28),
      strikethrough: init(9, 29),
      black: init(30, 39),
      red: init(31, 39),
      green: init(32, 39),
      yellow: init(33, 39),
      blue: init(34, 39),
      magenta: init(35, 39),
      cyan: init(36, 39),
      white: init(37, 39),
      gray: init(90, 39),
      grey: init(90, 39),
      bgBlack: init(40, 49),
      bgRed: init(41, 49),
      bgGreen: init(42, 49),
      bgYellow: init(43, 49),
      bgBlue: init(44, 49),
      bgMagenta: init(45, 49),
      bgCyan: init(46, 49),
      bgWhite: init(47, 49)
    };
    function run(arr, str) {
      let i = 0, tmp, beg = "", end = "";
      for (; i < arr.length; i++) {
        tmp = arr[i];
        beg += tmp.open;
        end += tmp.close;
        if (str.includes(tmp.close)) {
          str = str.replace(tmp.rgx, tmp.close + tmp.open);
        }
      }
      return beg + str + end;
    }
    function chain(has, keys) {
      let ctx = {has, keys};
      ctx.reset = $.reset.bind(ctx);
      ctx.bold = $.bold.bind(ctx);
      ctx.dim = $.dim.bind(ctx);
      ctx.italic = $.italic.bind(ctx);
      ctx.underline = $.underline.bind(ctx);
      ctx.inverse = $.inverse.bind(ctx);
      ctx.hidden = $.hidden.bind(ctx);
      ctx.strikethrough = $.strikethrough.bind(ctx);
      ctx.black = $.black.bind(ctx);
      ctx.red = $.red.bind(ctx);
      ctx.green = $.green.bind(ctx);
      ctx.yellow = $.yellow.bind(ctx);
      ctx.blue = $.blue.bind(ctx);
      ctx.magenta = $.magenta.bind(ctx);
      ctx.cyan = $.cyan.bind(ctx);
      ctx.white = $.white.bind(ctx);
      ctx.gray = $.gray.bind(ctx);
      ctx.grey = $.grey.bind(ctx);
      ctx.bgBlack = $.bgBlack.bind(ctx);
      ctx.bgRed = $.bgRed.bind(ctx);
      ctx.bgGreen = $.bgGreen.bind(ctx);
      ctx.bgYellow = $.bgYellow.bind(ctx);
      ctx.bgBlue = $.bgBlue.bind(ctx);
      ctx.bgMagenta = $.bgMagenta.bind(ctx);
      ctx.bgCyan = $.bgCyan.bind(ctx);
      ctx.bgWhite = $.bgWhite.bind(ctx);
      return ctx;
    }
    function init(open, close) {
      let blk = {
        open: `[${open}m`,
        close: `[${close}m`,
        rgx: new RegExp(`\\x1b\\[${close}m`, "g")
      };
      return function(txt) {
        if (this !== void 0 && this.has !== void 0) {
          this.has.includes(open) || (this.has.push(open), this.keys.push(blk));
          return txt === void 0 ? this : $.enabled ? run(this.keys, txt + "") : txt + "";
        }
        return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt + "") : txt + "";
      };
    }
    module2.exports = $;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/util/action.js
var require_action = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/util/action.js"(exports2, module2) {
    "use strict";
    module2.exports = (key, isSelect) => {
      if (key.meta && key.name !== "escape")
        return;
      if (key.ctrl) {
        if (key.name === "a")
          return "first";
        if (key.name === "c")
          return "abort";
        if (key.name === "d")
          return "abort";
        if (key.name === "e")
          return "last";
        if (key.name === "g")
          return "reset";
      }
      if (isSelect) {
        if (key.name === "j")
          return "down";
        if (key.name === "k")
          return "up";
      }
      if (key.name === "return")
        return "submit";
      if (key.name === "enter")
        return "submit";
      if (key.name === "backspace")
        return "delete";
      if (key.name === "delete")
        return "deleteForward";
      if (key.name === "abort")
        return "abort";
      if (key.name === "escape")
        return "exit";
      if (key.name === "tab")
        return "next";
      if (key.name === "pagedown")
        return "nextPage";
      if (key.name === "pageup")
        return "prevPage";
      if (key.name === "home")
        return "home";
      if (key.name === "end")
        return "end";
      if (key.name === "up")
        return "up";
      if (key.name === "down")
        return "down";
      if (key.name === "right")
        return "right";
      if (key.name === "left")
        return "left";
      return false;
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/util/strip.js
var require_strip = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/util/strip.js"(exports2, module2) {
    "use strict";
    module2.exports = (str) => {
      const pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"].join("|");
      const RGX = new RegExp(pattern, "g");
      return typeof str === "string" ? str.replace(RGX, "") : str;
    };
  }
});

// .pnpm/sisteransi@1.0.5/node_modules/sisteransi/src/index.js
var require_src = __commonJS({
  ".pnpm/sisteransi@1.0.5/node_modules/sisteransi/src/index.js"(exports2, module2) {
    "use strict";
    var ESC = "";
    var CSI = `${ESC}[`;
    var beep = "\x07";
    var cursor = {
      to(x, y) {
        if (!y)
          return `${CSI}${x + 1}G`;
        return `${CSI}${y + 1};${x + 1}H`;
      },
      move(x, y) {
        let ret = "";
        if (x < 0)
          ret += `${CSI}${-x}D`;
        else if (x > 0)
          ret += `${CSI}${x}C`;
        if (y < 0)
          ret += `${CSI}${-y}A`;
        else if (y > 0)
          ret += `${CSI}${y}B`;
        return ret;
      },
      up: (count = 1) => `${CSI}${count}A`,
      down: (count = 1) => `${CSI}${count}B`,
      forward: (count = 1) => `${CSI}${count}C`,
      backward: (count = 1) => `${CSI}${count}D`,
      nextLine: (count = 1) => `${CSI}E`.repeat(count),
      prevLine: (count = 1) => `${CSI}F`.repeat(count),
      left: `${CSI}G`,
      hide: `${CSI}?25l`,
      show: `${CSI}?25h`,
      save: `${ESC}7`,
      restore: `${ESC}8`
    };
    var scroll = {
      up: (count = 1) => `${CSI}S`.repeat(count),
      down: (count = 1) => `${CSI}T`.repeat(count)
    };
    var erase = {
      screen: `${CSI}2J`,
      up: (count = 1) => `${CSI}1J`.repeat(count),
      down: (count = 1) => `${CSI}J`.repeat(count),
      line: `${CSI}2K`,
      lineEnd: `${CSI}K`,
      lineStart: `${CSI}1K`,
      lines(count) {
        let clear = "";
        for (let i = 0; i < count; i++)
          clear += this.line + (i < count - 1 ? cursor.up() : "");
        if (count)
          clear += cursor.left;
        return clear;
      }
    };
    module2.exports = {cursor, scroll, erase, beep};
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/util/clear.js
var require_clear = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/util/clear.js"(exports2, module2) {
    "use strict";
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return {s: F, n: function n() {
            if (i >= o.length)
              return {done: true};
            return {done: false, value: o[i++]};
          }, e: function e(_e) {
            throw _e;
          }, f: F};
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {s: function s() {
        it = o[Symbol.iterator]();
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      }};
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    var strip = require_strip();
    var _require = require_src();
    var erase = _require.erase;
    var cursor = _require.cursor;
    var width = (str) => [...strip(str)].length;
    module2.exports = function(prompt, perLine) {
      if (!perLine)
        return erase.line + cursor.to(0);
      let rows = 0;
      const lines = prompt.split(/\r?\n/);
      var _iterator = _createForOfIteratorHelper(lines), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          let line = _step.value;
          rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return erase.lines(rows);
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/util/figures.js
var require_figures = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/util/figures.js"(exports2, module2) {
    "use strict";
    var main = {
      arrowUp: "\u2191",
      arrowDown: "\u2193",
      arrowLeft: "\u2190",
      arrowRight: "\u2192",
      radioOn: "\u25C9",
      radioOff: "\u25EF",
      tick: "\u2714",
      cross: "\u2716",
      ellipsis: "\u2026",
      pointerSmall: "\u203A",
      line: "\u2500",
      pointer: "\u276F"
    };
    var win = {
      arrowUp: main.arrowUp,
      arrowDown: main.arrowDown,
      arrowLeft: main.arrowLeft,
      arrowRight: main.arrowRight,
      radioOn: "(*)",
      radioOff: "( )",
      tick: "\u221A",
      cross: "\xD7",
      ellipsis: "...",
      pointerSmall: "\xBB",
      line: "\u2500",
      pointer: ">"
    };
    var figures = process.platform === "win32" ? win : main;
    module2.exports = figures;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/util/style.js
var require_style = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/util/style.js"(exports2, module2) {
    "use strict";
    var c = require_kleur();
    var figures = require_figures();
    var styles = Object.freeze({
      password: {
        scale: 1,
        render: (input) => "*".repeat(input.length)
      },
      emoji: {
        scale: 2,
        render: (input) => "\u{1F603}".repeat(input.length)
      },
      invisible: {
        scale: 0,
        render: (input) => ""
      },
      default: {
        scale: 1,
        render: (input) => `${input}`
      }
    });
    var render = (type) => styles[type] || styles.default;
    var symbols = Object.freeze({
      aborted: c.red(figures.cross),
      done: c.green(figures.tick),
      exited: c.yellow(figures.cross),
      default: c.cyan("?")
    });
    var symbol = (done, aborted, exited) => aborted ? symbols.aborted : exited ? symbols.exited : done ? symbols.done : symbols.default;
    var delimiter = (completing) => c.gray(completing ? figures.ellipsis : figures.pointerSmall);
    var item = (expandable, expanded) => c.gray(expandable ? expanded ? figures.pointerSmall : "+" : figures.line);
    module2.exports = {
      styles,
      render,
      symbols,
      symbol,
      delimiter,
      item
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/util/lines.js
var require_lines = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/util/lines.js"(exports2, module2) {
    "use strict";
    var strip = require_strip();
    module2.exports = function(msg, perLine) {
      let lines = String(strip(msg) || "").split(/\r?\n/);
      if (!perLine)
        return lines.length;
      return lines.map((l) => Math.ceil(l.length / perLine)).reduce((a, b) => a + b);
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/util/wrap.js
var require_wrap = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/util/wrap.js"(exports2, module2) {
    "use strict";
    module2.exports = (msg, opts = {}) => {
      const tab = Number.isSafeInteger(parseInt(opts.margin)) ? new Array(parseInt(opts.margin)).fill(" ").join("") : opts.margin || "";
      const width = opts.width;
      return (msg || "").split(/\r?\n/g).map((line) => line.split(/\s+/g).reduce((arr, w) => {
        if (w.length + tab.length >= width || arr[arr.length - 1].length + w.length + 1 < width)
          arr[arr.length - 1] += ` ${w}`;
        else
          arr.push(`${tab}${w}`);
        return arr;
      }, [tab]).join("\n")).join("\n");
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/util/entriesToDisplay.js
var require_entriesToDisplay = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/util/entriesToDisplay.js"(exports2, module2) {
    "use strict";
    module2.exports = (cursor, total, maxVisible) => {
      maxVisible = maxVisible || total;
      let startIndex = Math.min(total - maxVisible, cursor - Math.floor(maxVisible / 2));
      if (startIndex < 0)
        startIndex = 0;
      let endIndex = Math.min(startIndex + maxVisible, total);
      return {
        startIndex,
        endIndex
      };
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/util/index.js
var require_util2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/util/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      action: require_action(),
      clear: require_clear(),
      style: require_style(),
      strip: require_strip(),
      figures: require_figures(),
      lines: require_lines(),
      wrap: require_wrap(),
      entriesToDisplay: require_entriesToDisplay()
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/prompt.js
var require_prompt = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/prompt.js"(exports2, module2) {
    "use strict";
    var readline = require("readline");
    var _require = require_util2();
    var action = _require.action;
    var EventEmitter = require("events");
    var _require2 = require_src();
    var beep = _require2.beep;
    var cursor = _require2.cursor;
    var color = require_kleur();
    var Prompt = class extends EventEmitter {
      constructor(opts = {}) {
        super();
        this.firstRender = true;
        this.in = opts.stdin || process.stdin;
        this.out = opts.stdout || process.stdout;
        this.onRender = (opts.onRender || (() => void 0)).bind(this);
        const rl = readline.createInterface({
          input: this.in,
          escapeCodeTimeout: 50
        });
        readline.emitKeypressEvents(this.in, rl);
        if (this.in.isTTY)
          this.in.setRawMode(true);
        const isSelect = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1;
        const keypress = (str, key) => {
          let a = action(key, isSelect);
          if (a === false) {
            this._ && this._(str, key);
          } else if (typeof this[a] === "function") {
            this[a](key);
          } else {
            this.bell();
          }
        };
        this.close = () => {
          this.out.write(cursor.show);
          this.in.removeListener("keypress", keypress);
          if (this.in.isTTY)
            this.in.setRawMode(false);
          rl.close();
          this.emit(this.aborted ? "abort" : this.exited ? "exit" : "submit", this.value);
          this.closed = true;
        };
        this.in.on("keypress", keypress);
      }
      fire() {
        this.emit("state", {
          value: this.value,
          aborted: !!this.aborted,
          exited: !!this.exited
        });
      }
      bell() {
        this.out.write(beep);
      }
      render() {
        this.onRender(color);
        if (this.firstRender)
          this.firstRender = false;
      }
    };
    module2.exports = Prompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/text.js
var require_text = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/text.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_src();
    var erase = _require.erase;
    var cursor = _require.cursor;
    var _require2 = require_util2();
    var style = _require2.style;
    var clear = _require2.clear;
    var lines = _require2.lines;
    var figures = _require2.figures;
    var TextPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.transform = style.render(opts.style);
        this.scale = this.transform.scale;
        this.msg = opts.message;
        this.initial = opts.initial || ``;
        this.validator = opts.validate || (() => true);
        this.value = ``;
        this.errorMsg = opts.error || `Please Enter A Valid Value`;
        this.cursor = Number(!!this.initial);
        this.cursorOffset = 0;
        this.clear = clear(``, this.out.columns);
        this.render();
      }
      set value(v) {
        if (!v && this.initial) {
          this.placeholder = true;
          this.rendered = color.gray(this.transform.render(this.initial));
        } else {
          this.placeholder = false;
          this.rendered = this.transform.render(v);
        }
        this._value = v;
        this.fire();
      }
      get value() {
        return this._value;
      }
      reset() {
        this.value = ``;
        this.cursor = Number(!!this.initial);
        this.cursorOffset = 0;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.value = this.value || this.initial;
        this.done = this.aborted = true;
        this.error = false;
        this.red = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      validate() {
        var _this = this;
        return _asyncToGenerator(function* () {
          let valid = yield _this.validator(_this.value);
          if (typeof valid === `string`) {
            _this.errorMsg = valid;
            valid = false;
          }
          _this.error = !valid;
        })();
      }
      submit() {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          _this2.value = _this2.value || _this2.initial;
          _this2.cursorOffset = 0;
          _this2.cursor = _this2.rendered.length;
          yield _this2.validate();
          if (_this2.error) {
            _this2.red = true;
            _this2.fire();
            _this2.render();
            return;
          }
          _this2.done = true;
          _this2.aborted = false;
          _this2.fire();
          _this2.render();
          _this2.out.write("\n");
          _this2.close();
        })();
      }
      next() {
        if (!this.placeholder)
          return this.bell();
        this.value = this.initial;
        this.cursor = this.rendered.length;
        this.fire();
        this.render();
      }
      moveCursor(n) {
        if (this.placeholder)
          return;
        this.cursor = this.cursor + n;
        this.cursorOffset += n;
      }
      _(c, key) {
        let s1 = this.value.slice(0, this.cursor);
        let s2 = this.value.slice(this.cursor);
        this.value = `${s1}${c}${s2}`;
        this.red = false;
        this.cursor = this.placeholder ? 0 : s1.length + 1;
        this.render();
      }
      delete() {
        if (this.isCursorAtStart())
          return this.bell();
        let s1 = this.value.slice(0, this.cursor - 1);
        let s2 = this.value.slice(this.cursor);
        this.value = `${s1}${s2}`;
        this.red = false;
        if (this.isCursorAtStart()) {
          this.cursorOffset = 0;
        } else {
          this.cursorOffset++;
          this.moveCursor(-1);
        }
        this.render();
      }
      deleteForward() {
        if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
          return this.bell();
        let s1 = this.value.slice(0, this.cursor);
        let s2 = this.value.slice(this.cursor + 1);
        this.value = `${s1}${s2}`;
        this.red = false;
        if (this.isCursorAtEnd()) {
          this.cursorOffset = 0;
        } else {
          this.cursorOffset++;
        }
        this.render();
      }
      first() {
        this.cursor = 0;
        this.render();
      }
      last() {
        this.cursor = this.value.length;
        this.render();
      }
      left() {
        if (this.cursor <= 0 || this.placeholder)
          return this.bell();
        this.moveCursor(-1);
        this.render();
      }
      right() {
        if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
          return this.bell();
        this.moveCursor(1);
        this.render();
      }
      isCursorAtStart() {
        return this.cursor === 0 || this.placeholder && this.cursor === 1;
      }
      isCursorAtEnd() {
        return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
      }
      render() {
        if (this.closed)
          return;
        if (!this.firstRender) {
          if (this.outputError)
            this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
          this.out.write(clear(this.outputText, this.out.columns));
        }
        super.render();
        this.outputError = "";
        this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.red ? color.red(this.rendered) : this.rendered].join(` `);
        if (this.error) {
          this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? " " : figures.pointerSmall} ${color.red().italic(l)}`, ``);
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore + cursor.move(this.cursorOffset, 0));
      }
    };
    module2.exports = TextPrompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/select.js
var require_select = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/select.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_util2();
    var style = _require.style;
    var clear = _require.clear;
    var figures = _require.figures;
    var wrap = _require.wrap;
    var entriesToDisplay = _require.entriesToDisplay;
    var _require2 = require_src();
    var cursor = _require2.cursor;
    var SelectPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.hint = opts.hint || "- Use arrow-keys. Return to submit.";
        this.warn = opts.warn || "- This option is disabled";
        this.cursor = opts.initial || 0;
        this.choices = opts.choices.map((ch, idx) => {
          if (typeof ch === "string")
            ch = {
              title: ch,
              value: idx
            };
          return {
            title: ch && (ch.title || ch.value || ch),
            value: ch && (ch.value === void 0 ? idx : ch.value),
            description: ch && ch.description,
            selected: ch && ch.selected,
            disabled: ch && ch.disabled
          };
        });
        this.optionsPerPage = opts.optionsPerPage || 10;
        this.value = (this.choices[this.cursor] || {}).value;
        this.clear = clear("", this.out.columns);
        this.render();
      }
      moveCursor(n) {
        this.cursor = n;
        this.value = this.choices[n].value;
        this.fire();
      }
      reset() {
        this.moveCursor(0);
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        if (!this.selection.disabled) {
          this.done = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        } else
          this.bell();
      }
      first() {
        this.moveCursor(0);
        this.render();
      }
      last() {
        this.moveCursor(this.choices.length - 1);
        this.render();
      }
      up() {
        if (this.cursor === 0) {
          this.moveCursor(this.choices.length - 1);
        } else {
          this.moveCursor(this.cursor - 1);
        }
        this.render();
      }
      down() {
        if (this.cursor === this.choices.length - 1) {
          this.moveCursor(0);
        } else {
          this.moveCursor(this.cursor + 1);
        }
        this.render();
      }
      next() {
        this.moveCursor((this.cursor + 1) % this.choices.length);
        this.render();
      }
      _(c, key) {
        if (c === " ")
          return this.submit();
      }
      get selection() {
        return this.choices[this.cursor];
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        let _entriesToDisplay = entriesToDisplay(this.cursor, this.choices.length, this.optionsPerPage), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
        this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.done ? this.selection.title : this.selection.disabled ? color.yellow(this.warn) : color.gray(this.hint)].join(" ");
        if (!this.done) {
          this.outputText += "\n";
          for (let i = startIndex; i < endIndex; i++) {
            let title, prefix, desc = "", v = this.choices[i];
            if (i === startIndex && startIndex > 0) {
              prefix = figures.arrowUp;
            } else if (i === endIndex - 1 && endIndex < this.choices.length) {
              prefix = figures.arrowDown;
            } else {
              prefix = " ";
            }
            if (v.disabled) {
              title = this.cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
              prefix = (this.cursor === i ? color.bold().gray(figures.pointer) + " " : "  ") + prefix;
            } else {
              title = this.cursor === i ? color.cyan().underline(v.title) : v.title;
              prefix = (this.cursor === i ? color.cyan(figures.pointer) + " " : "  ") + prefix;
              if (v.description && this.cursor === i) {
                desc = ` - ${v.description}`;
                if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
                  desc = "\n" + wrap(v.description, {
                    margin: 3,
                    width: this.out.columns
                  });
                }
              }
            }
            this.outputText += `${prefix} ${title}${color.gray(desc)}
`;
          }
        }
        this.out.write(this.outputText);
      }
    };
    module2.exports = SelectPrompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/toggle.js
var require_toggle = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/toggle.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_util2();
    var style = _require.style;
    var clear = _require.clear;
    var _require2 = require_src();
    var cursor = _require2.cursor;
    var erase = _require2.erase;
    var TogglePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.value = !!opts.initial;
        this.active = opts.active || "on";
        this.inactive = opts.inactive || "off";
        this.initialValue = this.value;
        this.render();
      }
      reset() {
        this.value = this.initialValue;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      deactivate() {
        if (this.value === false)
          return this.bell();
        this.value = false;
        this.render();
      }
      activate() {
        if (this.value === true)
          return this.bell();
        this.value = true;
        this.render();
      }
      delete() {
        this.deactivate();
      }
      left() {
        this.deactivate();
      }
      right() {
        this.activate();
      }
      down() {
        this.deactivate();
      }
      up() {
        this.activate();
      }
      next() {
        this.value = !this.value;
        this.fire();
        this.render();
      }
      _(c, key) {
        if (c === " ") {
          this.value = !this.value;
        } else if (c === "1") {
          this.value = true;
        } else if (c === "0") {
          this.value = false;
        } else
          return this.bell();
        this.render();
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.value ? this.inactive : color.cyan().underline(this.inactive), color.gray("/"), this.value ? color.cyan().underline(this.active) : this.active].join(" ");
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module2.exports = TogglePrompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/datepart.js
var require_datepart = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/datepart.js"(exports2, module2) {
    "use strict";
    var DatePart = class {
      constructor({
        token,
        date,
        parts,
        locales
      }) {
        this.token = token;
        this.date = date || new Date();
        this.parts = parts || [this];
        this.locales = locales || {};
      }
      up() {
      }
      down() {
      }
      next() {
        const currentIdx = this.parts.indexOf(this);
        return this.parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
      }
      setTo(val) {
      }
      prev() {
        let parts = [].concat(this.parts).reverse();
        const currentIdx = parts.indexOf(this);
        return parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
      }
      toString() {
        return String(this.date);
      }
    };
    module2.exports = DatePart;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/meridiem.js
var require_meridiem = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/meridiem.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart();
    var Meridiem = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setHours((this.date.getHours() + 12) % 24);
      }
      down() {
        this.up();
      }
      toString() {
        let meridiem = this.date.getHours() > 12 ? "pm" : "am";
        return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
      }
    };
    module2.exports = Meridiem;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/day.js
var require_day = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/day.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart();
    var pos = (n) => {
      n = n % 10;
      return n === 1 ? "st" : n === 2 ? "nd" : n === 3 ? "rd" : "th";
    };
    var Day = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setDate(this.date.getDate() + 1);
      }
      down() {
        this.date.setDate(this.date.getDate() - 1);
      }
      setTo(val) {
        this.date.setDate(parseInt(val.substr(-2)));
      }
      toString() {
        let date = this.date.getDate();
        let day = this.date.getDay();
        return this.token === "DD" ? String(date).padStart(2, "0") : this.token === "Do" ? date + pos(date) : this.token === "d" ? day + 1 : this.token === "ddd" ? this.locales.weekdaysShort[day] : this.token === "dddd" ? this.locales.weekdays[day] : date;
      }
    };
    module2.exports = Day;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/hours.js
var require_hours = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/hours.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart();
    var Hours = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setHours(this.date.getHours() + 1);
      }
      down() {
        this.date.setHours(this.date.getHours() - 1);
      }
      setTo(val) {
        this.date.setHours(parseInt(val.substr(-2)));
      }
      toString() {
        let hours = this.date.getHours();
        if (/h/.test(this.token))
          hours = hours % 12 || 12;
        return this.token.length > 1 ? String(hours).padStart(2, "0") : hours;
      }
    };
    module2.exports = Hours;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/milliseconds.js
var require_milliseconds = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/milliseconds.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart();
    var Milliseconds = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMilliseconds(this.date.getMilliseconds() + 1);
      }
      down() {
        this.date.setMilliseconds(this.date.getMilliseconds() - 1);
      }
      setTo(val) {
        this.date.setMilliseconds(parseInt(val.substr(-this.token.length)));
      }
      toString() {
        return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
      }
    };
    module2.exports = Milliseconds;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/minutes.js
var require_minutes = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/minutes.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart();
    var Minutes = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMinutes(this.date.getMinutes() + 1);
      }
      down() {
        this.date.setMinutes(this.date.getMinutes() - 1);
      }
      setTo(val) {
        this.date.setMinutes(parseInt(val.substr(-2)));
      }
      toString() {
        let m = this.date.getMinutes();
        return this.token.length > 1 ? String(m).padStart(2, "0") : m;
      }
    };
    module2.exports = Minutes;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/month.js
var require_month = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/month.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart();
    var Month = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMonth(this.date.getMonth() + 1);
      }
      down() {
        this.date.setMonth(this.date.getMonth() - 1);
      }
      setTo(val) {
        val = parseInt(val.substr(-2)) - 1;
        this.date.setMonth(val < 0 ? 0 : val);
      }
      toString() {
        let month = this.date.getMonth();
        let tl = this.token.length;
        return tl === 2 ? String(month + 1).padStart(2, "0") : tl === 3 ? this.locales.monthsShort[month] : tl === 4 ? this.locales.months[month] : String(month + 1);
      }
    };
    module2.exports = Month;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/seconds.js
var require_seconds = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/seconds.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart();
    var Seconds = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setSeconds(this.date.getSeconds() + 1);
      }
      down() {
        this.date.setSeconds(this.date.getSeconds() - 1);
      }
      setTo(val) {
        this.date.setSeconds(parseInt(val.substr(-2)));
      }
      toString() {
        let s = this.date.getSeconds();
        return this.token.length > 1 ? String(s).padStart(2, "0") : s;
      }
    };
    module2.exports = Seconds;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/year.js
var require_year = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/year.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart();
    var Year = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setFullYear(this.date.getFullYear() + 1);
      }
      down() {
        this.date.setFullYear(this.date.getFullYear() - 1);
      }
      setTo(val) {
        this.date.setFullYear(val.substr(-4));
      }
      toString() {
        let year = String(this.date.getFullYear()).padStart(4, "0");
        return this.token.length === 2 ? year.substr(-2) : year;
      }
    };
    module2.exports = Year;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/index.js
var require_dateparts = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      DatePart: require_datepart(),
      Meridiem: require_meridiem(),
      Day: require_day(),
      Hours: require_hours(),
      Milliseconds: require_milliseconds(),
      Minutes: require_minutes(),
      Month: require_month(),
      Seconds: require_seconds(),
      Year: require_year()
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/date.js
var require_date = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/date.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_util2();
    var style = _require.style;
    var clear = _require.clear;
    var figures = _require.figures;
    var _require2 = require_src();
    var erase = _require2.erase;
    var cursor = _require2.cursor;
    var _require3 = require_dateparts();
    var DatePart = _require3.DatePart;
    var Meridiem = _require3.Meridiem;
    var Day = _require3.Day;
    var Hours = _require3.Hours;
    var Milliseconds = _require3.Milliseconds;
    var Minutes = _require3.Minutes;
    var Month = _require3.Month;
    var Seconds = _require3.Seconds;
    var Year = _require3.Year;
    var regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
    var regexGroups = {
      1: ({
        token
      }) => token.replace(/\\(.)/g, "$1"),
      2: (opts) => new Day(opts),
      3: (opts) => new Month(opts),
      4: (opts) => new Year(opts),
      5: (opts) => new Meridiem(opts),
      6: (opts) => new Hours(opts),
      7: (opts) => new Minutes(opts),
      8: (opts) => new Seconds(opts),
      9: (opts) => new Milliseconds(opts)
    };
    var dfltLocales = {
      months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
      monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
      weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
      weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
    };
    var DatePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.cursor = 0;
        this.typed = "";
        this.locales = Object.assign(dfltLocales, opts.locales);
        this._date = opts.initial || new Date();
        this.errorMsg = opts.error || "Please Enter A Valid Value";
        this.validator = opts.validate || (() => true);
        this.mask = opts.mask || "YYYY-MM-DD HH:mm:ss";
        this.clear = clear("", this.out.columns);
        this.render();
      }
      get value() {
        return this.date;
      }
      get date() {
        return this._date;
      }
      set date(date) {
        if (date)
          this._date.setTime(date.getTime());
      }
      set mask(mask) {
        let result;
        this.parts = [];
        while (result = regex.exec(mask)) {
          let match = result.shift();
          let idx = result.findIndex((gr) => gr != null);
          this.parts.push(idx in regexGroups ? regexGroups[idx]({
            token: result[idx] || match,
            date: this.date,
            parts: this.parts,
            locales: this.locales
          }) : result[idx] || match);
        }
        let parts = this.parts.reduce((arr, i) => {
          if (typeof i === "string" && typeof arr[arr.length - 1] === "string")
            arr[arr.length - 1] += i;
          else
            arr.push(i);
          return arr;
        }, []);
        this.parts.splice(0);
        this.parts.push(...parts);
        this.reset();
      }
      moveCursor(n) {
        this.typed = "";
        this.cursor = n;
        this.fire();
      }
      reset() {
        this.moveCursor(this.parts.findIndex((p) => p instanceof DatePart));
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.error = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      validate() {
        var _this = this;
        return _asyncToGenerator(function* () {
          let valid = yield _this.validator(_this.value);
          if (typeof valid === "string") {
            _this.errorMsg = valid;
            valid = false;
          }
          _this.error = !valid;
        })();
      }
      submit() {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          yield _this2.validate();
          if (_this2.error) {
            _this2.color = "red";
            _this2.fire();
            _this2.render();
            return;
          }
          _this2.done = true;
          _this2.aborted = false;
          _this2.fire();
          _this2.render();
          _this2.out.write("\n");
          _this2.close();
        })();
      }
      up() {
        this.typed = "";
        this.parts[this.cursor].up();
        this.render();
      }
      down() {
        this.typed = "";
        this.parts[this.cursor].down();
        this.render();
      }
      left() {
        let prev = this.parts[this.cursor].prev();
        if (prev == null)
          return this.bell();
        this.moveCursor(this.parts.indexOf(prev));
        this.render();
      }
      right() {
        let next = this.parts[this.cursor].next();
        if (next == null)
          return this.bell();
        this.moveCursor(this.parts.indexOf(next));
        this.render();
      }
      next() {
        let next = this.parts[this.cursor].next();
        this.moveCursor(next ? this.parts.indexOf(next) : this.parts.findIndex((part) => part instanceof DatePart));
        this.render();
      }
      _(c) {
        if (/\d/.test(c)) {
          this.typed += c;
          this.parts[this.cursor].setTo(this.typed);
          this.render();
        }
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.parts.reduce((arr, p, idx) => arr.concat(idx === this.cursor && !this.done ? color.cyan().underline(p.toString()) : p), []).join("")].join(" ");
        if (this.error) {
          this.outputText += this.errorMsg.split("\n").reduce((a, l, i) => a + `
${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module2.exports = DatePrompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/number.js
var require_number = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/number.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_src();
    var cursor = _require.cursor;
    var erase = _require.erase;
    var _require2 = require_util2();
    var style = _require2.style;
    var figures = _require2.figures;
    var clear = _require2.clear;
    var lines = _require2.lines;
    var isNumber = /[0-9]/;
    var isDef = (any) => any !== void 0;
    var round = (number, precision) => {
      let factor = Math.pow(10, precision);
      return Math.round(number * factor) / factor;
    };
    var NumberPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.transform = style.render(opts.style);
        this.msg = opts.message;
        this.initial = isDef(opts.initial) ? opts.initial : "";
        this.float = !!opts.float;
        this.round = opts.round || 2;
        this.inc = opts.increment || 1;
        this.min = isDef(opts.min) ? opts.min : -Infinity;
        this.max = isDef(opts.max) ? opts.max : Infinity;
        this.errorMsg = opts.error || `Please Enter A Valid Value`;
        this.validator = opts.validate || (() => true);
        this.color = `cyan`;
        this.value = ``;
        this.typed = ``;
        this.lastHit = 0;
        this.render();
      }
      set value(v) {
        if (!v && v !== 0) {
          this.placeholder = true;
          this.rendered = color.gray(this.transform.render(`${this.initial}`));
          this._value = ``;
        } else {
          this.placeholder = false;
          this.rendered = this.transform.render(`${round(v, this.round)}`);
          this._value = round(v, this.round);
        }
        this.fire();
      }
      get value() {
        return this._value;
      }
      parse(x) {
        return this.float ? parseFloat(x) : parseInt(x);
      }
      valid(c) {
        return c === `-` || c === `.` && this.float || isNumber.test(c);
      }
      reset() {
        this.typed = ``;
        this.value = ``;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        let x = this.value;
        this.value = x !== `` ? x : this.initial;
        this.done = this.aborted = true;
        this.error = false;
        this.fire();
        this.render();
        this.out.write(`
`);
        this.close();
      }
      validate() {
        var _this = this;
        return _asyncToGenerator(function* () {
          let valid = yield _this.validator(_this.value);
          if (typeof valid === `string`) {
            _this.errorMsg = valid;
            valid = false;
          }
          _this.error = !valid;
        })();
      }
      submit() {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          yield _this2.validate();
          if (_this2.error) {
            _this2.color = `red`;
            _this2.fire();
            _this2.render();
            return;
          }
          let x = _this2.value;
          _this2.value = x !== `` ? x : _this2.initial;
          _this2.done = true;
          _this2.aborted = false;
          _this2.error = false;
          _this2.fire();
          _this2.render();
          _this2.out.write(`
`);
          _this2.close();
        })();
      }
      up() {
        this.typed = ``;
        if (this.value === "") {
          this.value = this.min - this.inc;
        }
        if (this.value >= this.max)
          return this.bell();
        this.value += this.inc;
        this.color = `cyan`;
        this.fire();
        this.render();
      }
      down() {
        this.typed = ``;
        if (this.value === "") {
          this.value = this.min + this.inc;
        }
        if (this.value <= this.min)
          return this.bell();
        this.value -= this.inc;
        this.color = `cyan`;
        this.fire();
        this.render();
      }
      delete() {
        let val = this.value.toString();
        if (val.length === 0)
          return this.bell();
        this.value = this.parse(val = val.slice(0, -1)) || ``;
        if (this.value !== "" && this.value < this.min) {
          this.value = this.min;
        }
        this.color = `cyan`;
        this.fire();
        this.render();
      }
      next() {
        this.value = this.initial;
        this.fire();
        this.render();
      }
      _(c, key) {
        if (!this.valid(c))
          return this.bell();
        const now = Date.now();
        if (now - this.lastHit > 1e3)
          this.typed = ``;
        this.typed += c;
        this.lastHit = now;
        this.color = `cyan`;
        if (c === `.`)
          return this.fire();
        this.value = Math.min(this.parse(this.typed), this.max);
        if (this.value > this.max)
          this.value = this.max;
        if (this.value < this.min)
          this.value = this.min;
        this.fire();
        this.render();
      }
      render() {
        if (this.closed)
          return;
        if (!this.firstRender) {
          if (this.outputError)
            this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
          this.out.write(clear(this.outputText, this.out.columns));
        }
        super.render();
        this.outputError = "";
        this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), !this.done || !this.done && !this.placeholder ? color[this.color]().underline(this.rendered) : this.rendered].join(` `);
        if (this.error) {
          this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore);
      }
    };
    module2.exports = NumberPrompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/multiselect.js
var require_multiselect = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/multiselect.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var _require = require_src();
    var cursor = _require.cursor;
    var Prompt = require_prompt();
    var _require2 = require_util2();
    var clear = _require2.clear;
    var figures = _require2.figures;
    var style = _require2.style;
    var wrap = _require2.wrap;
    var entriesToDisplay = _require2.entriesToDisplay;
    var MultiselectPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.cursor = opts.cursor || 0;
        this.scrollIndex = opts.cursor || 0;
        this.hint = opts.hint || "";
        this.warn = opts.warn || "- This option is disabled -";
        this.minSelected = opts.min;
        this.showMinError = false;
        this.maxChoices = opts.max;
        this.instructions = opts.instructions;
        this.optionsPerPage = opts.optionsPerPage || 10;
        this.value = opts.choices.map((ch, idx) => {
          if (typeof ch === "string")
            ch = {
              title: ch,
              value: idx
            };
          return {
            title: ch && (ch.title || ch.value || ch),
            description: ch && ch.description,
            value: ch && (ch.value === void 0 ? idx : ch.value),
            selected: ch && ch.selected,
            disabled: ch && ch.disabled
          };
        });
        this.clear = clear("", this.out.columns);
        if (!opts.overrideRender) {
          this.render();
        }
      }
      reset() {
        this.value.map((v) => !v.selected);
        this.cursor = 0;
        this.fire();
        this.render();
      }
      selected() {
        return this.value.filter((v) => v.selected);
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        const selected = this.value.filter((e) => e.selected);
        if (this.minSelected && selected.length < this.minSelected) {
          this.showMinError = true;
          this.render();
        } else {
          this.done = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
      }
      first() {
        this.cursor = 0;
        this.render();
      }
      last() {
        this.cursor = this.value.length - 1;
        this.render();
      }
      next() {
        this.cursor = (this.cursor + 1) % this.value.length;
        this.render();
      }
      up() {
        if (this.cursor === 0) {
          this.cursor = this.value.length - 1;
        } else {
          this.cursor--;
        }
        this.render();
      }
      down() {
        if (this.cursor === this.value.length - 1) {
          this.cursor = 0;
        } else {
          this.cursor++;
        }
        this.render();
      }
      left() {
        this.value[this.cursor].selected = false;
        this.render();
      }
      right() {
        if (this.value.filter((e) => e.selected).length >= this.maxChoices)
          return this.bell();
        this.value[this.cursor].selected = true;
        this.render();
      }
      handleSpaceToggle() {
        const v = this.value[this.cursor];
        if (v.selected) {
          v.selected = false;
          this.render();
        } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
          return this.bell();
        } else {
          v.selected = true;
          this.render();
        }
      }
      toggleAll() {
        if (this.maxChoices !== void 0 || this.value[this.cursor].disabled) {
          return this.bell();
        }
        const newSelected = !this.value[this.cursor].selected;
        this.value.filter((v) => !v.disabled).forEach((v) => v.selected = newSelected);
        this.render();
      }
      _(c, key) {
        if (c === " ") {
          this.handleSpaceToggle();
        } else if (c === "a") {
          this.toggleAll();
        } else {
          return this.bell();
        }
      }
      renderInstructions() {
        if (this.instructions === void 0 || this.instructions) {
          if (typeof this.instructions === "string") {
            return this.instructions;
          }
          return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + `    enter/return: Complete answer`;
        }
        return "";
      }
      renderOption(cursor2, v, i, arrowIndicator) {
        const prefix = (v.selected ? color.green(figures.radioOn) : figures.radioOff) + " " + arrowIndicator + " ";
        let title, desc;
        if (v.disabled) {
          title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
        } else {
          title = cursor2 === i ? color.cyan().underline(v.title) : v.title;
          if (cursor2 === i && v.description) {
            desc = ` - ${v.description}`;
            if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
              desc = "\n" + wrap(v.description, {
                margin: prefix.length,
                width: this.out.columns
              });
            }
          }
        }
        return prefix + title + color.gray(desc || "");
      }
      paginateOptions(options) {
        if (options.length === 0) {
          return color.red("No matches for this query.");
        }
        let _entriesToDisplay = entriesToDisplay(this.cursor, options.length, this.optionsPerPage), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
        let prefix, styledOptions = [];
        for (let i = startIndex; i < endIndex; i++) {
          if (i === startIndex && startIndex > 0) {
            prefix = figures.arrowUp;
          } else if (i === endIndex - 1 && endIndex < options.length) {
            prefix = figures.arrowDown;
          } else {
            prefix = " ";
          }
          styledOptions.push(this.renderOption(this.cursor, options[i], i, prefix));
        }
        return "\n" + styledOptions.join("\n");
      }
      renderOptions(options) {
        if (!this.done) {
          return this.paginateOptions(options);
        }
        return "";
      }
      renderDoneOrInstructions() {
        if (this.done) {
          return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
        }
        const output = [color.gray(this.hint), this.renderInstructions()];
        if (this.value[this.cursor].disabled) {
          output.push(color.yellow(this.warn));
        }
        return output.join(" ");
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        super.render();
        let prompt = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.renderDoneOrInstructions()].join(" ");
        if (this.showMinError) {
          prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
          this.showMinError = false;
        }
        prompt += this.renderOptions(this.value);
        this.out.write(this.clear + prompt);
        this.clear = clear(prompt, this.out.columns);
      }
    };
    module2.exports = MultiselectPrompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/autocomplete.js
var require_autocomplete = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/autocomplete.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_src();
    var erase = _require.erase;
    var cursor = _require.cursor;
    var _require2 = require_util2();
    var style = _require2.style;
    var clear = _require2.clear;
    var figures = _require2.figures;
    var wrap = _require2.wrap;
    var entriesToDisplay = _require2.entriesToDisplay;
    var getVal = (arr, i) => arr[i] && (arr[i].value || arr[i].title || arr[i]);
    var getTitle = (arr, i) => arr[i] && (arr[i].title || arr[i].value || arr[i]);
    var getIndex = (arr, valOrTitle) => {
      const index = arr.findIndex((el) => el.value === valOrTitle || el.title === valOrTitle);
      return index > -1 ? index : void 0;
    };
    var AutocompletePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.suggest = opts.suggest;
        this.choices = opts.choices;
        this.initial = typeof opts.initial === "number" ? opts.initial : getIndex(opts.choices, opts.initial);
        this.select = this.initial || opts.cursor || 0;
        this.i18n = {
          noMatches: opts.noMatches || "no matches found"
        };
        this.fallback = opts.fallback || this.initial;
        this.clearFirst = opts.clearFirst || false;
        this.suggestions = [];
        this.input = "";
        this.limit = opts.limit || 10;
        this.cursor = 0;
        this.transform = style.render(opts.style);
        this.scale = this.transform.scale;
        this.render = this.render.bind(this);
        this.complete = this.complete.bind(this);
        this.clear = clear("", this.out.columns);
        this.complete(this.render);
        this.render();
      }
      set fallback(fb) {
        this._fb = Number.isSafeInteger(parseInt(fb)) ? parseInt(fb) : fb;
      }
      get fallback() {
        let choice;
        if (typeof this._fb === "number")
          choice = this.choices[this._fb];
        else if (typeof this._fb === "string")
          choice = {
            title: this._fb
          };
        return choice || this._fb || {
          title: this.i18n.noMatches
        };
      }
      moveSelect(i) {
        this.select = i;
        if (this.suggestions.length > 0)
          this.value = getVal(this.suggestions, i);
        else
          this.value = this.fallback.value;
        this.fire();
      }
      complete(cb) {
        var _this = this;
        return _asyncToGenerator(function* () {
          const p = _this.completing = _this.suggest(_this.input, _this.choices);
          const suggestions = yield p;
          if (_this.completing !== p)
            return;
          _this.suggestions = suggestions.map((s, i, arr) => ({
            title: getTitle(arr, i),
            value: getVal(arr, i),
            description: s.description
          }));
          _this.completing = false;
          const l = Math.max(suggestions.length - 1, 0);
          _this.moveSelect(Math.min(l, _this.select));
          cb && cb();
        })();
      }
      reset() {
        this.input = "";
        this.complete(() => {
          this.moveSelect(this.initial !== void 0 ? this.initial : 0);
          this.render();
        });
        this.render();
      }
      exit() {
        if (this.clearFirst && this.input.length > 0) {
          this.reset();
        } else {
          this.done = this.exited = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
      }
      abort() {
        this.done = this.aborted = true;
        this.exited = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        this.done = true;
        this.aborted = this.exited = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      _(c, key) {
        let s1 = this.input.slice(0, this.cursor);
        let s2 = this.input.slice(this.cursor);
        this.input = `${s1}${c}${s2}`;
        this.cursor = s1.length + 1;
        this.complete(this.render);
        this.render();
      }
      delete() {
        if (this.cursor === 0)
          return this.bell();
        let s1 = this.input.slice(0, this.cursor - 1);
        let s2 = this.input.slice(this.cursor);
        this.input = `${s1}${s2}`;
        this.complete(this.render);
        this.cursor = this.cursor - 1;
        this.render();
      }
      deleteForward() {
        if (this.cursor * this.scale >= this.rendered.length)
          return this.bell();
        let s1 = this.input.slice(0, this.cursor);
        let s2 = this.input.slice(this.cursor + 1);
        this.input = `${s1}${s2}`;
        this.complete(this.render);
        this.render();
      }
      first() {
        this.moveSelect(0);
        this.render();
      }
      last() {
        this.moveSelect(this.suggestions.length - 1);
        this.render();
      }
      up() {
        if (this.select === 0) {
          this.moveSelect(this.suggestions.length - 1);
        } else {
          this.moveSelect(this.select - 1);
        }
        this.render();
      }
      down() {
        if (this.select === this.suggestions.length - 1) {
          this.moveSelect(0);
        } else {
          this.moveSelect(this.select + 1);
        }
        this.render();
      }
      next() {
        if (this.select === this.suggestions.length - 1) {
          this.moveSelect(0);
        } else
          this.moveSelect(this.select + 1);
        this.render();
      }
      nextPage() {
        this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1));
        this.render();
      }
      prevPage() {
        this.moveSelect(Math.max(this.select - this.limit, 0));
        this.render();
      }
      left() {
        if (this.cursor <= 0)
          return this.bell();
        this.cursor = this.cursor - 1;
        this.render();
      }
      right() {
        if (this.cursor * this.scale >= this.rendered.length)
          return this.bell();
        this.cursor = this.cursor + 1;
        this.render();
      }
      renderOption(v, hovered, isStart, isEnd) {
        let desc;
        let prefix = isStart ? figures.arrowUp : isEnd ? figures.arrowDown : " ";
        let title = hovered ? color.cyan().underline(v.title) : v.title;
        prefix = (hovered ? color.cyan(figures.pointer) + " " : "  ") + prefix;
        if (v.description) {
          desc = ` - ${v.description}`;
          if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
            desc = "\n" + wrap(v.description, {
              margin: 3,
              width: this.out.columns
            });
          }
        }
        return prefix + " " + title + color.gray(desc || "");
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        let _entriesToDisplay = entriesToDisplay(this.select, this.choices.length, this.limit), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
        this.outputText = [style.symbol(this.done, this.aborted, this.exited), color.bold(this.msg), style.delimiter(this.completing), this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)].join(" ");
        if (!this.done) {
          const suggestions = this.suggestions.slice(startIndex, endIndex).map((item, i) => this.renderOption(item, this.select === i + startIndex, i === 0 && startIndex > 0, i + startIndex === endIndex - 1 && endIndex < this.choices.length)).join("\n");
          this.outputText += `
` + (suggestions || color.gray(this.fallback.title));
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module2.exports = AutocompletePrompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/autocompleteMultiselect.js
var require_autocompleteMultiselect = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/autocompleteMultiselect.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var _require = require_src();
    var cursor = _require.cursor;
    var MultiselectPrompt = require_multiselect();
    var _require2 = require_util2();
    var clear = _require2.clear;
    var style = _require2.style;
    var figures = _require2.figures;
    var AutocompleteMultiselectPrompt = class extends MultiselectPrompt {
      constructor(opts = {}) {
        opts.overrideRender = true;
        super(opts);
        this.inputValue = "";
        this.clear = clear("", this.out.columns);
        this.filteredOptions = this.value;
        this.render();
      }
      last() {
        this.cursor = this.filteredOptions.length - 1;
        this.render();
      }
      next() {
        this.cursor = (this.cursor + 1) % this.filteredOptions.length;
        this.render();
      }
      up() {
        if (this.cursor === 0) {
          this.cursor = this.filteredOptions.length - 1;
        } else {
          this.cursor--;
        }
        this.render();
      }
      down() {
        if (this.cursor === this.filteredOptions.length - 1) {
          this.cursor = 0;
        } else {
          this.cursor++;
        }
        this.render();
      }
      left() {
        this.filteredOptions[this.cursor].selected = false;
        this.render();
      }
      right() {
        if (this.value.filter((e) => e.selected).length >= this.maxChoices)
          return this.bell();
        this.filteredOptions[this.cursor].selected = true;
        this.render();
      }
      delete() {
        if (this.inputValue.length) {
          this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1);
          this.updateFilteredOptions();
        }
      }
      updateFilteredOptions() {
        const currentHighlight = this.filteredOptions[this.cursor];
        this.filteredOptions = this.value.filter((v) => {
          if (this.inputValue) {
            if (typeof v.title === "string") {
              if (v.title.toLowerCase().includes(this.inputValue.toLowerCase())) {
                return true;
              }
            }
            if (typeof v.value === "string") {
              if (v.value.toLowerCase().includes(this.inputValue.toLowerCase())) {
                return true;
              }
            }
            return false;
          }
          return true;
        });
        const newHighlightIndex = this.filteredOptions.findIndex((v) => v === currentHighlight);
        this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex;
        this.render();
      }
      handleSpaceToggle() {
        const v = this.filteredOptions[this.cursor];
        if (v.selected) {
          v.selected = false;
          this.render();
        } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
          return this.bell();
        } else {
          v.selected = true;
          this.render();
        }
      }
      handleInputChange(c) {
        this.inputValue = this.inputValue + c;
        this.updateFilteredOptions();
      }
      _(c, key) {
        if (c === " ") {
          this.handleSpaceToggle();
        } else {
          this.handleInputChange(c);
        }
      }
      renderInstructions() {
        if (this.instructions === void 0 || this.instructions) {
          if (typeof this.instructions === "string") {
            return this.instructions;
          }
          return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
`;
        }
        return "";
      }
      renderCurrentInput() {
        return `
Filtered results for: ${this.inputValue ? this.inputValue : color.gray("Enter something to filter")}
`;
      }
      renderOption(cursor2, v, i) {
        let title;
        if (v.disabled)
          title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
        else
          title = cursor2 === i ? color.cyan().underline(v.title) : v.title;
        return (v.selected ? color.green(figures.radioOn) : figures.radioOff) + "  " + title;
      }
      renderDoneOrInstructions() {
        if (this.done) {
          return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
        }
        const output = [color.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
        if (this.filteredOptions.length && this.filteredOptions[this.cursor].disabled) {
          output.push(color.yellow(this.warn));
        }
        return output.join(" ");
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        super.render();
        let prompt = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.renderDoneOrInstructions()].join(" ");
        if (this.showMinError) {
          prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
          this.showMinError = false;
        }
        prompt += this.renderOptions(this.filteredOptions);
        this.out.write(this.clear + prompt);
        this.clear = clear(prompt, this.out.columns);
      }
    };
    module2.exports = AutocompleteMultiselectPrompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/confirm.js
var require_confirm = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/confirm.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_util2();
    var style = _require.style;
    var clear = _require.clear;
    var _require2 = require_src();
    var erase = _require2.erase;
    var cursor = _require2.cursor;
    var ConfirmPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.value = opts.initial;
        this.initialValue = !!opts.initial;
        this.yesMsg = opts.yes || "yes";
        this.yesOption = opts.yesOption || "(Y/n)";
        this.noMsg = opts.no || "no";
        this.noOption = opts.noOption || "(y/N)";
        this.render();
      }
      reset() {
        this.value = this.initialValue;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        this.value = this.value || false;
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      _(c, key) {
        if (c.toLowerCase() === "y") {
          this.value = true;
          return this.submit();
        }
        if (c.toLowerCase() === "n") {
          this.value = false;
          return this.submit();
        }
        return this.bell();
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.done ? this.value ? this.yesMsg : this.noMsg : color.gray(this.initialValue ? this.yesOption : this.noOption)].join(" ");
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module2.exports = ConfirmPrompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/index.js
var require_elements = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      TextPrompt: require_text(),
      SelectPrompt: require_select(),
      TogglePrompt: require_toggle(),
      DatePrompt: require_date(),
      NumberPrompt: require_number(),
      MultiselectPrompt: require_multiselect(),
      AutocompletePrompt: require_autocomplete(),
      AutocompleteMultiselectPrompt: require_autocompleteMultiselect(),
      ConfirmPrompt: require_confirm()
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/prompts.js
var require_prompts = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/prompts.js"(exports2) {
    "use strict";
    var $ = exports2;
    var el = require_elements();
    var noop = (v) => v;
    function toPrompt(type, args, opts = {}) {
      return new Promise((res, rej) => {
        const p = new el[type](args);
        const onAbort = opts.onAbort || noop;
        const onSubmit = opts.onSubmit || noop;
        const onExit = opts.onExit || noop;
        p.on("state", args.onState || noop);
        p.on("submit", (x) => res(onSubmit(x)));
        p.on("exit", (x) => res(onExit(x)));
        p.on("abort", (x) => rej(onAbort(x)));
      });
    }
    $.text = (args) => toPrompt("TextPrompt", args);
    $.password = (args) => {
      args.style = "password";
      return $.text(args);
    };
    $.invisible = (args) => {
      args.style = "invisible";
      return $.text(args);
    };
    $.number = (args) => toPrompt("NumberPrompt", args);
    $.date = (args) => toPrompt("DatePrompt", args);
    $.confirm = (args) => toPrompt("ConfirmPrompt", args);
    $.list = (args) => {
      const sep = args.separator || ",";
      return toPrompt("TextPrompt", args, {
        onSubmit: (str) => str.split(sep).map((s) => s.trim())
      });
    };
    $.toggle = (args) => toPrompt("TogglePrompt", args);
    $.select = (args) => toPrompt("SelectPrompt", args);
    $.multiselect = (args) => {
      args.choices = [].concat(args.choices || []);
      const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
      return toPrompt("MultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    $.autocompleteMultiselect = (args) => {
      args.choices = [].concat(args.choices || []);
      const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
      return toPrompt("AutocompleteMultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    var byTitle = (input, choices) => Promise.resolve(choices.filter((item) => item.title.slice(0, input.length).toLowerCase() === input.toLowerCase()));
    $.autocomplete = (args) => {
      args.suggest = args.suggest || byTitle;
      args.choices = [].concat(args.choices || []);
      return toPrompt("AutocompletePrompt", args);
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/dist/index.js
var require_dist = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/dist/index.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return {s: F, n: function n() {
            if (i >= o.length)
              return {done: true};
            return {done: false, value: o[i++]};
          }, e: function e(_e) {
            throw _e;
          }, f: F};
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {s: function s() {
        it = o[Symbol.iterator]();
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      }};
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var prompts = require_prompts();
    var passOn = ["suggest", "format", "onState", "validate", "onRender", "type"];
    var noop = () => {
    };
    function prompt() {
      return _prompt.apply(this, arguments);
    }
    function _prompt() {
      _prompt = _asyncToGenerator(function* (questions = [], {
        onSubmit = noop,
        onCancel = noop
      } = {}) {
        const answers = {};
        const override2 = prompt._override || {};
        questions = [].concat(questions);
        let answer, question, quit, name, type, lastPrompt;
        const getFormattedAnswer = /* @__PURE__ */ function() {
          var _ref = _asyncToGenerator(function* (question2, answer2, skipValidation = false) {
            if (!skipValidation && question2.validate && question2.validate(answer2) !== true) {
              return;
            }
            return question2.format ? yield question2.format(answer2, answers) : answer2;
          });
          return function getFormattedAnswer2(_x, _x2) {
            return _ref.apply(this, arguments);
          };
        }();
        var _iterator = _createForOfIteratorHelper(questions), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            question = _step.value;
            var _question = question;
            name = _question.name;
            type = _question.type;
            if (typeof type === "function") {
              type = yield type(answer, _objectSpread({}, answers), question);
              question["type"] = type;
            }
            if (!type)
              continue;
            for (let key in question) {
              if (passOn.includes(key))
                continue;
              let value = question[key];
              question[key] = typeof value === "function" ? yield value(answer, _objectSpread({}, answers), lastPrompt) : value;
            }
            lastPrompt = question;
            if (typeof question.message !== "string") {
              throw new Error("prompt message is required");
            }
            var _question2 = question;
            name = _question2.name;
            type = _question2.type;
            if (prompts[type] === void 0) {
              throw new Error(`prompt type (${type}) is not defined`);
            }
            if (override2[question.name] !== void 0) {
              answer = yield getFormattedAnswer(question, override2[question.name]);
              if (answer !== void 0) {
                answers[name] = answer;
                continue;
              }
            }
            try {
              answer = prompt._injected ? getInjectedAnswer(prompt._injected, question.initial) : yield prompts[type](question);
              answers[name] = answer = yield getFormattedAnswer(question, answer, true);
              quit = yield onSubmit(question, answer, answers);
            } catch (err) {
              quit = !(yield onCancel(question, answers));
            }
            if (quit)
              return answers;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return answers;
      });
      return _prompt.apply(this, arguments);
    }
    function getInjectedAnswer(injected, deafultValue) {
      const answer = injected.shift();
      if (answer instanceof Error) {
        throw answer;
      }
      return answer === void 0 ? deafultValue : answer;
    }
    function inject(answers) {
      prompt._injected = (prompt._injected || []).concat(answers);
    }
    function override(answers) {
      prompt._override = Object.assign({}, answers);
    }
    module2.exports = Object.assign(prompt, {
      prompt,
      prompts,
      inject,
      override
    });
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/util/action.js
var require_action2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/util/action.js"(exports2, module2) {
    "use strict";
    module2.exports = (key, isSelect) => {
      if (key.meta && key.name !== "escape")
        return;
      if (key.ctrl) {
        if (key.name === "a")
          return "first";
        if (key.name === "c")
          return "abort";
        if (key.name === "d")
          return "abort";
        if (key.name === "e")
          return "last";
        if (key.name === "g")
          return "reset";
      }
      if (isSelect) {
        if (key.name === "j")
          return "down";
        if (key.name === "k")
          return "up";
      }
      if (key.name === "return")
        return "submit";
      if (key.name === "enter")
        return "submit";
      if (key.name === "backspace")
        return "delete";
      if (key.name === "delete")
        return "deleteForward";
      if (key.name === "abort")
        return "abort";
      if (key.name === "escape")
        return "exit";
      if (key.name === "tab")
        return "next";
      if (key.name === "pagedown")
        return "nextPage";
      if (key.name === "pageup")
        return "prevPage";
      if (key.name === "home")
        return "home";
      if (key.name === "end")
        return "end";
      if (key.name === "up")
        return "up";
      if (key.name === "down")
        return "down";
      if (key.name === "right")
        return "right";
      if (key.name === "left")
        return "left";
      return false;
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/util/strip.js
var require_strip2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/util/strip.js"(exports2, module2) {
    "use strict";
    module2.exports = (str) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"
      ].join("|");
      const RGX = new RegExp(pattern, "g");
      return typeof str === "string" ? str.replace(RGX, "") : str;
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/util/clear.js
var require_clear2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/util/clear.js"(exports2, module2) {
    "use strict";
    var strip = require_strip2();
    var {erase, cursor} = require_src();
    var width = (str) => [...strip(str)].length;
    module2.exports = function(prompt, perLine) {
      if (!perLine)
        return erase.line + cursor.to(0);
      let rows = 0;
      const lines = prompt.split(/\r?\n/);
      for (let line of lines) {
        rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
      }
      return erase.lines(rows);
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/util/figures.js
var require_figures2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/util/figures.js"(exports2, module2) {
    "use strict";
    var main = {
      arrowUp: "\u2191",
      arrowDown: "\u2193",
      arrowLeft: "\u2190",
      arrowRight: "\u2192",
      radioOn: "\u25C9",
      radioOff: "\u25EF",
      tick: "\u2714",
      cross: "\u2716",
      ellipsis: "\u2026",
      pointerSmall: "\u203A",
      line: "\u2500",
      pointer: "\u276F"
    };
    var win = {
      arrowUp: main.arrowUp,
      arrowDown: main.arrowDown,
      arrowLeft: main.arrowLeft,
      arrowRight: main.arrowRight,
      radioOn: "(*)",
      radioOff: "( )",
      tick: "\u221A",
      cross: "\xD7",
      ellipsis: "...",
      pointerSmall: "\xBB",
      line: "\u2500",
      pointer: ">"
    };
    var figures = process.platform === "win32" ? win : main;
    module2.exports = figures;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/util/style.js
var require_style2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/util/style.js"(exports2, module2) {
    "use strict";
    var c = require_kleur();
    var figures = require_figures2();
    var styles = Object.freeze({
      password: {scale: 1, render: (input) => "*".repeat(input.length)},
      emoji: {scale: 2, render: (input) => "\u{1F603}".repeat(input.length)},
      invisible: {scale: 0, render: (input) => ""},
      default: {scale: 1, render: (input) => `${input}`}
    });
    var render = (type) => styles[type] || styles.default;
    var symbols = Object.freeze({
      aborted: c.red(figures.cross),
      done: c.green(figures.tick),
      exited: c.yellow(figures.cross),
      default: c.cyan("?")
    });
    var symbol = (done, aborted, exited) => aborted ? symbols.aborted : exited ? symbols.exited : done ? symbols.done : symbols.default;
    var delimiter = (completing) => c.gray(completing ? figures.ellipsis : figures.pointerSmall);
    var item = (expandable, expanded) => c.gray(expandable ? expanded ? figures.pointerSmall : "+" : figures.line);
    module2.exports = {
      styles,
      render,
      symbols,
      symbol,
      delimiter,
      item
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/util/lines.js
var require_lines2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/util/lines.js"(exports2, module2) {
    "use strict";
    var strip = require_strip2();
    module2.exports = function(msg, perLine) {
      let lines = String(strip(msg) || "").split(/\r?\n/);
      if (!perLine)
        return lines.length;
      return lines.map((l) => Math.ceil(l.length / perLine)).reduce((a, b) => a + b);
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/util/wrap.js
var require_wrap2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/util/wrap.js"(exports2, module2) {
    "use strict";
    module2.exports = (msg, opts = {}) => {
      const tab = Number.isSafeInteger(parseInt(opts.margin)) ? new Array(parseInt(opts.margin)).fill(" ").join("") : opts.margin || "";
      const width = opts.width;
      return (msg || "").split(/\r?\n/g).map((line) => line.split(/\s+/g).reduce((arr, w) => {
        if (w.length + tab.length >= width || arr[arr.length - 1].length + w.length + 1 < width)
          arr[arr.length - 1] += ` ${w}`;
        else
          arr.push(`${tab}${w}`);
        return arr;
      }, [tab]).join("\n")).join("\n");
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/util/entriesToDisplay.js
var require_entriesToDisplay2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/util/entriesToDisplay.js"(exports2, module2) {
    "use strict";
    module2.exports = (cursor, total, maxVisible) => {
      maxVisible = maxVisible || total;
      let startIndex = Math.min(total - maxVisible, cursor - Math.floor(maxVisible / 2));
      if (startIndex < 0)
        startIndex = 0;
      let endIndex = Math.min(startIndex + maxVisible, total);
      return {startIndex, endIndex};
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/util/index.js
var require_util3 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/util/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      action: require_action2(),
      clear: require_clear2(),
      style: require_style2(),
      strip: require_strip2(),
      figures: require_figures2(),
      lines: require_lines2(),
      wrap: require_wrap2(),
      entriesToDisplay: require_entriesToDisplay2()
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/prompt.js
var require_prompt2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/prompt.js"(exports2, module2) {
    "use strict";
    var readline = require("readline");
    var {action} = require_util3();
    var EventEmitter = require("events");
    var {beep, cursor} = require_src();
    var color = require_kleur();
    var Prompt = class extends EventEmitter {
      constructor(opts = {}) {
        super();
        this.firstRender = true;
        this.in = opts.stdin || process.stdin;
        this.out = opts.stdout || process.stdout;
        this.onRender = (opts.onRender || (() => void 0)).bind(this);
        const rl = readline.createInterface({input: this.in, escapeCodeTimeout: 50});
        readline.emitKeypressEvents(this.in, rl);
        if (this.in.isTTY)
          this.in.setRawMode(true);
        const isSelect = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1;
        const keypress = (str, key) => {
          let a = action(key, isSelect);
          if (a === false) {
            this._ && this._(str, key);
          } else if (typeof this[a] === "function") {
            this[a](key);
          } else {
            this.bell();
          }
        };
        this.close = () => {
          this.out.write(cursor.show);
          this.in.removeListener("keypress", keypress);
          if (this.in.isTTY)
            this.in.setRawMode(false);
          rl.close();
          this.emit(this.aborted ? "abort" : this.exited ? "exit" : "submit", this.value);
          this.closed = true;
        };
        this.in.on("keypress", keypress);
      }
      fire() {
        this.emit("state", {
          value: this.value,
          aborted: !!this.aborted,
          exited: !!this.exited
        });
      }
      bell() {
        this.out.write(beep);
      }
      render() {
        this.onRender(color);
        if (this.firstRender)
          this.firstRender = false;
      }
    };
    module2.exports = Prompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/text.js
var require_text2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/text.js"(exports2, module2) {
    var color = require_kleur();
    var Prompt = require_prompt2();
    var {erase, cursor} = require_src();
    var {style, clear, lines, figures} = require_util3();
    var TextPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.transform = style.render(opts.style);
        this.scale = this.transform.scale;
        this.msg = opts.message;
        this.initial = opts.initial || ``;
        this.validator = opts.validate || (() => true);
        this.value = ``;
        this.errorMsg = opts.error || `Please Enter A Valid Value`;
        this.cursor = Number(!!this.initial);
        this.cursorOffset = 0;
        this.clear = clear(``, this.out.columns);
        this.render();
      }
      set value(v) {
        if (!v && this.initial) {
          this.placeholder = true;
          this.rendered = color.gray(this.transform.render(this.initial));
        } else {
          this.placeholder = false;
          this.rendered = this.transform.render(v);
        }
        this._value = v;
        this.fire();
      }
      get value() {
        return this._value;
      }
      reset() {
        this.value = ``;
        this.cursor = Number(!!this.initial);
        this.cursorOffset = 0;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.value = this.value || this.initial;
        this.done = this.aborted = true;
        this.error = false;
        this.red = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      async validate() {
        let valid = await this.validator(this.value);
        if (typeof valid === `string`) {
          this.errorMsg = valid;
          valid = false;
        }
        this.error = !valid;
      }
      async submit() {
        this.value = this.value || this.initial;
        this.cursorOffset = 0;
        this.cursor = this.rendered.length;
        await this.validate();
        if (this.error) {
          this.red = true;
          this.fire();
          this.render();
          return;
        }
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      next() {
        if (!this.placeholder)
          return this.bell();
        this.value = this.initial;
        this.cursor = this.rendered.length;
        this.fire();
        this.render();
      }
      moveCursor(n) {
        if (this.placeholder)
          return;
        this.cursor = this.cursor + n;
        this.cursorOffset += n;
      }
      _(c, key) {
        let s1 = this.value.slice(0, this.cursor);
        let s2 = this.value.slice(this.cursor);
        this.value = `${s1}${c}${s2}`;
        this.red = false;
        this.cursor = this.placeholder ? 0 : s1.length + 1;
        this.render();
      }
      delete() {
        if (this.isCursorAtStart())
          return this.bell();
        let s1 = this.value.slice(0, this.cursor - 1);
        let s2 = this.value.slice(this.cursor);
        this.value = `${s1}${s2}`;
        this.red = false;
        if (this.isCursorAtStart()) {
          this.cursorOffset = 0;
        } else {
          this.cursorOffset++;
          this.moveCursor(-1);
        }
        this.render();
      }
      deleteForward() {
        if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
          return this.bell();
        let s1 = this.value.slice(0, this.cursor);
        let s2 = this.value.slice(this.cursor + 1);
        this.value = `${s1}${s2}`;
        this.red = false;
        if (this.isCursorAtEnd()) {
          this.cursorOffset = 0;
        } else {
          this.cursorOffset++;
        }
        this.render();
      }
      first() {
        this.cursor = 0;
        this.render();
      }
      last() {
        this.cursor = this.value.length;
        this.render();
      }
      left() {
        if (this.cursor <= 0 || this.placeholder)
          return this.bell();
        this.moveCursor(-1);
        this.render();
      }
      right() {
        if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
          return this.bell();
        this.moveCursor(1);
        this.render();
      }
      isCursorAtStart() {
        return this.cursor === 0 || this.placeholder && this.cursor === 1;
      }
      isCursorAtEnd() {
        return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
      }
      render() {
        if (this.closed)
          return;
        if (!this.firstRender) {
          if (this.outputError)
            this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
          this.out.write(clear(this.outputText, this.out.columns));
        }
        super.render();
        this.outputError = "";
        this.outputText = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(this.done),
          this.red ? color.red(this.rendered) : this.rendered
        ].join(` `);
        if (this.error) {
          this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? " " : figures.pointerSmall} ${color.red().italic(l)}`, ``);
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore + cursor.move(this.cursorOffset, 0));
      }
    };
    module2.exports = TextPrompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/select.js
var require_select2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/select.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var Prompt = require_prompt2();
    var {style, clear, figures, wrap, entriesToDisplay} = require_util3();
    var {cursor} = require_src();
    var SelectPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.hint = opts.hint || "- Use arrow-keys. Return to submit.";
        this.warn = opts.warn || "- This option is disabled";
        this.cursor = opts.initial || 0;
        this.choices = opts.choices.map((ch, idx) => {
          if (typeof ch === "string")
            ch = {title: ch, value: idx};
          return {
            title: ch && (ch.title || ch.value || ch),
            value: ch && (ch.value === void 0 ? idx : ch.value),
            description: ch && ch.description,
            selected: ch && ch.selected,
            disabled: ch && ch.disabled
          };
        });
        this.optionsPerPage = opts.optionsPerPage || 10;
        this.value = (this.choices[this.cursor] || {}).value;
        this.clear = clear("", this.out.columns);
        this.render();
      }
      moveCursor(n) {
        this.cursor = n;
        this.value = this.choices[n].value;
        this.fire();
      }
      reset() {
        this.moveCursor(0);
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        if (!this.selection.disabled) {
          this.done = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        } else
          this.bell();
      }
      first() {
        this.moveCursor(0);
        this.render();
      }
      last() {
        this.moveCursor(this.choices.length - 1);
        this.render();
      }
      up() {
        if (this.cursor === 0) {
          this.moveCursor(this.choices.length - 1);
        } else {
          this.moveCursor(this.cursor - 1);
        }
        this.render();
      }
      down() {
        if (this.cursor === this.choices.length - 1) {
          this.moveCursor(0);
        } else {
          this.moveCursor(this.cursor + 1);
        }
        this.render();
      }
      next() {
        this.moveCursor((this.cursor + 1) % this.choices.length);
        this.render();
      }
      _(c, key) {
        if (c === " ")
          return this.submit();
      }
      get selection() {
        return this.choices[this.cursor];
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        let {startIndex, endIndex} = entriesToDisplay(this.cursor, this.choices.length, this.optionsPerPage);
        this.outputText = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(false),
          this.done ? this.selection.title : this.selection.disabled ? color.yellow(this.warn) : color.gray(this.hint)
        ].join(" ");
        if (!this.done) {
          this.outputText += "\n";
          for (let i = startIndex; i < endIndex; i++) {
            let title, prefix, desc = "", v = this.choices[i];
            if (i === startIndex && startIndex > 0) {
              prefix = figures.arrowUp;
            } else if (i === endIndex - 1 && endIndex < this.choices.length) {
              prefix = figures.arrowDown;
            } else {
              prefix = " ";
            }
            if (v.disabled) {
              title = this.cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
              prefix = (this.cursor === i ? color.bold().gray(figures.pointer) + " " : "  ") + prefix;
            } else {
              title = this.cursor === i ? color.cyan().underline(v.title) : v.title;
              prefix = (this.cursor === i ? color.cyan(figures.pointer) + " " : "  ") + prefix;
              if (v.description && this.cursor === i) {
                desc = ` - ${v.description}`;
                if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
                  desc = "\n" + wrap(v.description, {margin: 3, width: this.out.columns});
                }
              }
            }
            this.outputText += `${prefix} ${title}${color.gray(desc)}
`;
          }
        }
        this.out.write(this.outputText);
      }
    };
    module2.exports = SelectPrompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/toggle.js
var require_toggle2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/toggle.js"(exports2, module2) {
    var color = require_kleur();
    var Prompt = require_prompt2();
    var {style, clear} = require_util3();
    var {cursor, erase} = require_src();
    var TogglePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.value = !!opts.initial;
        this.active = opts.active || "on";
        this.inactive = opts.inactive || "off";
        this.initialValue = this.value;
        this.render();
      }
      reset() {
        this.value = this.initialValue;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      deactivate() {
        if (this.value === false)
          return this.bell();
        this.value = false;
        this.render();
      }
      activate() {
        if (this.value === true)
          return this.bell();
        this.value = true;
        this.render();
      }
      delete() {
        this.deactivate();
      }
      left() {
        this.deactivate();
      }
      right() {
        this.activate();
      }
      down() {
        this.deactivate();
      }
      up() {
        this.activate();
      }
      next() {
        this.value = !this.value;
        this.fire();
        this.render();
      }
      _(c, key) {
        if (c === " ") {
          this.value = !this.value;
        } else if (c === "1") {
          this.value = true;
        } else if (c === "0") {
          this.value = false;
        } else
          return this.bell();
        this.render();
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        this.outputText = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(this.done),
          this.value ? this.inactive : color.cyan().underline(this.inactive),
          color.gray("/"),
          this.value ? color.cyan().underline(this.active) : this.active
        ].join(" ");
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module2.exports = TogglePrompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/datepart.js
var require_datepart2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/datepart.js"(exports2, module2) {
    "use strict";
    var DatePart = class {
      constructor({token, date, parts, locales}) {
        this.token = token;
        this.date = date || new Date();
        this.parts = parts || [this];
        this.locales = locales || {};
      }
      up() {
      }
      down() {
      }
      next() {
        const currentIdx = this.parts.indexOf(this);
        return this.parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
      }
      setTo(val) {
      }
      prev() {
        let parts = [].concat(this.parts).reverse();
        const currentIdx = parts.indexOf(this);
        return parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
      }
      toString() {
        return String(this.date);
      }
    };
    module2.exports = DatePart;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/meridiem.js
var require_meridiem2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/meridiem.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2();
    var Meridiem = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setHours((this.date.getHours() + 12) % 24);
      }
      down() {
        this.up();
      }
      toString() {
        let meridiem = this.date.getHours() > 12 ? "pm" : "am";
        return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
      }
    };
    module2.exports = Meridiem;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/day.js
var require_day2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/day.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2();
    var pos = (n) => {
      n = n % 10;
      return n === 1 ? "st" : n === 2 ? "nd" : n === 3 ? "rd" : "th";
    };
    var Day = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setDate(this.date.getDate() + 1);
      }
      down() {
        this.date.setDate(this.date.getDate() - 1);
      }
      setTo(val) {
        this.date.setDate(parseInt(val.substr(-2)));
      }
      toString() {
        let date = this.date.getDate();
        let day = this.date.getDay();
        return this.token === "DD" ? String(date).padStart(2, "0") : this.token === "Do" ? date + pos(date) : this.token === "d" ? day + 1 : this.token === "ddd" ? this.locales.weekdaysShort[day] : this.token === "dddd" ? this.locales.weekdays[day] : date;
      }
    };
    module2.exports = Day;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/hours.js
var require_hours2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/hours.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2();
    var Hours = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setHours(this.date.getHours() + 1);
      }
      down() {
        this.date.setHours(this.date.getHours() - 1);
      }
      setTo(val) {
        this.date.setHours(parseInt(val.substr(-2)));
      }
      toString() {
        let hours = this.date.getHours();
        if (/h/.test(this.token))
          hours = hours % 12 || 12;
        return this.token.length > 1 ? String(hours).padStart(2, "0") : hours;
      }
    };
    module2.exports = Hours;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/milliseconds.js
var require_milliseconds2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/milliseconds.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2();
    var Milliseconds = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMilliseconds(this.date.getMilliseconds() + 1);
      }
      down() {
        this.date.setMilliseconds(this.date.getMilliseconds() - 1);
      }
      setTo(val) {
        this.date.setMilliseconds(parseInt(val.substr(-this.token.length)));
      }
      toString() {
        return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
      }
    };
    module2.exports = Milliseconds;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/minutes.js
var require_minutes2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/minutes.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2();
    var Minutes = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMinutes(this.date.getMinutes() + 1);
      }
      down() {
        this.date.setMinutes(this.date.getMinutes() - 1);
      }
      setTo(val) {
        this.date.setMinutes(parseInt(val.substr(-2)));
      }
      toString() {
        let m = this.date.getMinutes();
        return this.token.length > 1 ? String(m).padStart(2, "0") : m;
      }
    };
    module2.exports = Minutes;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/month.js
var require_month2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/month.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2();
    var Month = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMonth(this.date.getMonth() + 1);
      }
      down() {
        this.date.setMonth(this.date.getMonth() - 1);
      }
      setTo(val) {
        val = parseInt(val.substr(-2)) - 1;
        this.date.setMonth(val < 0 ? 0 : val);
      }
      toString() {
        let month = this.date.getMonth();
        let tl = this.token.length;
        return tl === 2 ? String(month + 1).padStart(2, "0") : tl === 3 ? this.locales.monthsShort[month] : tl === 4 ? this.locales.months[month] : String(month + 1);
      }
    };
    module2.exports = Month;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/seconds.js
var require_seconds2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/seconds.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2();
    var Seconds = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setSeconds(this.date.getSeconds() + 1);
      }
      down() {
        this.date.setSeconds(this.date.getSeconds() - 1);
      }
      setTo(val) {
        this.date.setSeconds(parseInt(val.substr(-2)));
      }
      toString() {
        let s = this.date.getSeconds();
        return this.token.length > 1 ? String(s).padStart(2, "0") : s;
      }
    };
    module2.exports = Seconds;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/year.js
var require_year2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/year.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2();
    var Year = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setFullYear(this.date.getFullYear() + 1);
      }
      down() {
        this.date.setFullYear(this.date.getFullYear() - 1);
      }
      setTo(val) {
        this.date.setFullYear(val.substr(-4));
      }
      toString() {
        let year = String(this.date.getFullYear()).padStart(4, "0");
        return this.token.length === 2 ? year.substr(-2) : year;
      }
    };
    module2.exports = Year;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/index.js
var require_dateparts2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      DatePart: require_datepart2(),
      Meridiem: require_meridiem2(),
      Day: require_day2(),
      Hours: require_hours2(),
      Milliseconds: require_milliseconds2(),
      Minutes: require_minutes2(),
      Month: require_month2(),
      Seconds: require_seconds2(),
      Year: require_year2()
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/date.js
var require_date2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/date.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var Prompt = require_prompt2();
    var {style, clear, figures} = require_util3();
    var {erase, cursor} = require_src();
    var {DatePart, Meridiem, Day, Hours, Milliseconds, Minutes, Month, Seconds, Year} = require_dateparts2();
    var regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
    var regexGroups = {
      1: ({token}) => token.replace(/\\(.)/g, "$1"),
      2: (opts) => new Day(opts),
      3: (opts) => new Month(opts),
      4: (opts) => new Year(opts),
      5: (opts) => new Meridiem(opts),
      6: (opts) => new Hours(opts),
      7: (opts) => new Minutes(opts),
      8: (opts) => new Seconds(opts),
      9: (opts) => new Milliseconds(opts)
    };
    var dfltLocales = {
      months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
      monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
      weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
      weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
    };
    var DatePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.cursor = 0;
        this.typed = "";
        this.locales = Object.assign(dfltLocales, opts.locales);
        this._date = opts.initial || new Date();
        this.errorMsg = opts.error || "Please Enter A Valid Value";
        this.validator = opts.validate || (() => true);
        this.mask = opts.mask || "YYYY-MM-DD HH:mm:ss";
        this.clear = clear("", this.out.columns);
        this.render();
      }
      get value() {
        return this.date;
      }
      get date() {
        return this._date;
      }
      set date(date) {
        if (date)
          this._date.setTime(date.getTime());
      }
      set mask(mask) {
        let result;
        this.parts = [];
        while (result = regex.exec(mask)) {
          let match = result.shift();
          let idx = result.findIndex((gr) => gr != null);
          this.parts.push(idx in regexGroups ? regexGroups[idx]({token: result[idx] || match, date: this.date, parts: this.parts, locales: this.locales}) : result[idx] || match);
        }
        let parts = this.parts.reduce((arr, i) => {
          if (typeof i === "string" && typeof arr[arr.length - 1] === "string")
            arr[arr.length - 1] += i;
          else
            arr.push(i);
          return arr;
        }, []);
        this.parts.splice(0);
        this.parts.push(...parts);
        this.reset();
      }
      moveCursor(n) {
        this.typed = "";
        this.cursor = n;
        this.fire();
      }
      reset() {
        this.moveCursor(this.parts.findIndex((p) => p instanceof DatePart));
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.error = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      async validate() {
        let valid = await this.validator(this.value);
        if (typeof valid === "string") {
          this.errorMsg = valid;
          valid = false;
        }
        this.error = !valid;
      }
      async submit() {
        await this.validate();
        if (this.error) {
          this.color = "red";
          this.fire();
          this.render();
          return;
        }
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      up() {
        this.typed = "";
        this.parts[this.cursor].up();
        this.render();
      }
      down() {
        this.typed = "";
        this.parts[this.cursor].down();
        this.render();
      }
      left() {
        let prev = this.parts[this.cursor].prev();
        if (prev == null)
          return this.bell();
        this.moveCursor(this.parts.indexOf(prev));
        this.render();
      }
      right() {
        let next = this.parts[this.cursor].next();
        if (next == null)
          return this.bell();
        this.moveCursor(this.parts.indexOf(next));
        this.render();
      }
      next() {
        let next = this.parts[this.cursor].next();
        this.moveCursor(next ? this.parts.indexOf(next) : this.parts.findIndex((part) => part instanceof DatePart));
        this.render();
      }
      _(c) {
        if (/\d/.test(c)) {
          this.typed += c;
          this.parts[this.cursor].setTo(this.typed);
          this.render();
        }
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        this.outputText = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(false),
          this.parts.reduce((arr, p, idx) => arr.concat(idx === this.cursor && !this.done ? color.cyan().underline(p.toString()) : p), []).join("")
        ].join(" ");
        if (this.error) {
          this.outputText += this.errorMsg.split("\n").reduce((a, l, i) => a + `
${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module2.exports = DatePrompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/number.js
var require_number2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/number.js"(exports2, module2) {
    var color = require_kleur();
    var Prompt = require_prompt2();
    var {cursor, erase} = require_src();
    var {style, figures, clear, lines} = require_util3();
    var isNumber = /[0-9]/;
    var isDef = (any) => any !== void 0;
    var round = (number, precision) => {
      let factor = Math.pow(10, precision);
      return Math.round(number * factor) / factor;
    };
    var NumberPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.transform = style.render(opts.style);
        this.msg = opts.message;
        this.initial = isDef(opts.initial) ? opts.initial : "";
        this.float = !!opts.float;
        this.round = opts.round || 2;
        this.inc = opts.increment || 1;
        this.min = isDef(opts.min) ? opts.min : -Infinity;
        this.max = isDef(opts.max) ? opts.max : Infinity;
        this.errorMsg = opts.error || `Please Enter A Valid Value`;
        this.validator = opts.validate || (() => true);
        this.color = `cyan`;
        this.value = ``;
        this.typed = ``;
        this.lastHit = 0;
        this.render();
      }
      set value(v) {
        if (!v && v !== 0) {
          this.placeholder = true;
          this.rendered = color.gray(this.transform.render(`${this.initial}`));
          this._value = ``;
        } else {
          this.placeholder = false;
          this.rendered = this.transform.render(`${round(v, this.round)}`);
          this._value = round(v, this.round);
        }
        this.fire();
      }
      get value() {
        return this._value;
      }
      parse(x) {
        return this.float ? parseFloat(x) : parseInt(x);
      }
      valid(c) {
        return c === `-` || c === `.` && this.float || isNumber.test(c);
      }
      reset() {
        this.typed = ``;
        this.value = ``;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        let x = this.value;
        this.value = x !== `` ? x : this.initial;
        this.done = this.aborted = true;
        this.error = false;
        this.fire();
        this.render();
        this.out.write(`
`);
        this.close();
      }
      async validate() {
        let valid = await this.validator(this.value);
        if (typeof valid === `string`) {
          this.errorMsg = valid;
          valid = false;
        }
        this.error = !valid;
      }
      async submit() {
        await this.validate();
        if (this.error) {
          this.color = `red`;
          this.fire();
          this.render();
          return;
        }
        let x = this.value;
        this.value = x !== `` ? x : this.initial;
        this.done = true;
        this.aborted = false;
        this.error = false;
        this.fire();
        this.render();
        this.out.write(`
`);
        this.close();
      }
      up() {
        this.typed = ``;
        if (this.value === "") {
          this.value = this.min - this.inc;
        }
        if (this.value >= this.max)
          return this.bell();
        this.value += this.inc;
        this.color = `cyan`;
        this.fire();
        this.render();
      }
      down() {
        this.typed = ``;
        if (this.value === "") {
          this.value = this.min + this.inc;
        }
        if (this.value <= this.min)
          return this.bell();
        this.value -= this.inc;
        this.color = `cyan`;
        this.fire();
        this.render();
      }
      delete() {
        let val = this.value.toString();
        if (val.length === 0)
          return this.bell();
        this.value = this.parse(val = val.slice(0, -1)) || ``;
        if (this.value !== "" && this.value < this.min) {
          this.value = this.min;
        }
        this.color = `cyan`;
        this.fire();
        this.render();
      }
      next() {
        this.value = this.initial;
        this.fire();
        this.render();
      }
      _(c, key) {
        if (!this.valid(c))
          return this.bell();
        const now = Date.now();
        if (now - this.lastHit > 1e3)
          this.typed = ``;
        this.typed += c;
        this.lastHit = now;
        this.color = `cyan`;
        if (c === `.`)
          return this.fire();
        this.value = Math.min(this.parse(this.typed), this.max);
        if (this.value > this.max)
          this.value = this.max;
        if (this.value < this.min)
          this.value = this.min;
        this.fire();
        this.render();
      }
      render() {
        if (this.closed)
          return;
        if (!this.firstRender) {
          if (this.outputError)
            this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
          this.out.write(clear(this.outputText, this.out.columns));
        }
        super.render();
        this.outputError = "";
        this.outputText = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(this.done),
          !this.done || !this.done && !this.placeholder ? color[this.color]().underline(this.rendered) : this.rendered
        ].join(` `);
        if (this.error) {
          this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore);
      }
    };
    module2.exports = NumberPrompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/multiselect.js
var require_multiselect2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/multiselect.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var {cursor} = require_src();
    var Prompt = require_prompt2();
    var {clear, figures, style, wrap, entriesToDisplay} = require_util3();
    var MultiselectPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.cursor = opts.cursor || 0;
        this.scrollIndex = opts.cursor || 0;
        this.hint = opts.hint || "";
        this.warn = opts.warn || "- This option is disabled -";
        this.minSelected = opts.min;
        this.showMinError = false;
        this.maxChoices = opts.max;
        this.instructions = opts.instructions;
        this.optionsPerPage = opts.optionsPerPage || 10;
        this.value = opts.choices.map((ch, idx) => {
          if (typeof ch === "string")
            ch = {title: ch, value: idx};
          return {
            title: ch && (ch.title || ch.value || ch),
            description: ch && ch.description,
            value: ch && (ch.value === void 0 ? idx : ch.value),
            selected: ch && ch.selected,
            disabled: ch && ch.disabled
          };
        });
        this.clear = clear("", this.out.columns);
        if (!opts.overrideRender) {
          this.render();
        }
      }
      reset() {
        this.value.map((v) => !v.selected);
        this.cursor = 0;
        this.fire();
        this.render();
      }
      selected() {
        return this.value.filter((v) => v.selected);
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        const selected = this.value.filter((e) => e.selected);
        if (this.minSelected && selected.length < this.minSelected) {
          this.showMinError = true;
          this.render();
        } else {
          this.done = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
      }
      first() {
        this.cursor = 0;
        this.render();
      }
      last() {
        this.cursor = this.value.length - 1;
        this.render();
      }
      next() {
        this.cursor = (this.cursor + 1) % this.value.length;
        this.render();
      }
      up() {
        if (this.cursor === 0) {
          this.cursor = this.value.length - 1;
        } else {
          this.cursor--;
        }
        this.render();
      }
      down() {
        if (this.cursor === this.value.length - 1) {
          this.cursor = 0;
        } else {
          this.cursor++;
        }
        this.render();
      }
      left() {
        this.value[this.cursor].selected = false;
        this.render();
      }
      right() {
        if (this.value.filter((e) => e.selected).length >= this.maxChoices)
          return this.bell();
        this.value[this.cursor].selected = true;
        this.render();
      }
      handleSpaceToggle() {
        const v = this.value[this.cursor];
        if (v.selected) {
          v.selected = false;
          this.render();
        } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
          return this.bell();
        } else {
          v.selected = true;
          this.render();
        }
      }
      toggleAll() {
        if (this.maxChoices !== void 0 || this.value[this.cursor].disabled) {
          return this.bell();
        }
        const newSelected = !this.value[this.cursor].selected;
        this.value.filter((v) => !v.disabled).forEach((v) => v.selected = newSelected);
        this.render();
      }
      _(c, key) {
        if (c === " ") {
          this.handleSpaceToggle();
        } else if (c === "a") {
          this.toggleAll();
        } else {
          return this.bell();
        }
      }
      renderInstructions() {
        if (this.instructions === void 0 || this.instructions) {
          if (typeof this.instructions === "string") {
            return this.instructions;
          }
          return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + `    enter/return: Complete answer`;
        }
        return "";
      }
      renderOption(cursor2, v, i, arrowIndicator) {
        const prefix = (v.selected ? color.green(figures.radioOn) : figures.radioOff) + " " + arrowIndicator + " ";
        let title, desc;
        if (v.disabled) {
          title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
        } else {
          title = cursor2 === i ? color.cyan().underline(v.title) : v.title;
          if (cursor2 === i && v.description) {
            desc = ` - ${v.description}`;
            if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
              desc = "\n" + wrap(v.description, {margin: prefix.length, width: this.out.columns});
            }
          }
        }
        return prefix + title + color.gray(desc || "");
      }
      paginateOptions(options) {
        if (options.length === 0) {
          return color.red("No matches for this query.");
        }
        let {startIndex, endIndex} = entriesToDisplay(this.cursor, options.length, this.optionsPerPage);
        let prefix, styledOptions = [];
        for (let i = startIndex; i < endIndex; i++) {
          if (i === startIndex && startIndex > 0) {
            prefix = figures.arrowUp;
          } else if (i === endIndex - 1 && endIndex < options.length) {
            prefix = figures.arrowDown;
          } else {
            prefix = " ";
          }
          styledOptions.push(this.renderOption(this.cursor, options[i], i, prefix));
        }
        return "\n" + styledOptions.join("\n");
      }
      renderOptions(options) {
        if (!this.done) {
          return this.paginateOptions(options);
        }
        return "";
      }
      renderDoneOrInstructions() {
        if (this.done) {
          return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
        }
        const output = [color.gray(this.hint), this.renderInstructions()];
        if (this.value[this.cursor].disabled) {
          output.push(color.yellow(this.warn));
        }
        return output.join(" ");
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        super.render();
        let prompt = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(false),
          this.renderDoneOrInstructions()
        ].join(" ");
        if (this.showMinError) {
          prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
          this.showMinError = false;
        }
        prompt += this.renderOptions(this.value);
        this.out.write(this.clear + prompt);
        this.clear = clear(prompt, this.out.columns);
      }
    };
    module2.exports = MultiselectPrompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/autocomplete.js
var require_autocomplete2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/autocomplete.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var Prompt = require_prompt2();
    var {erase, cursor} = require_src();
    var {style, clear, figures, wrap, entriesToDisplay} = require_util3();
    var getVal = (arr, i) => arr[i] && (arr[i].value || arr[i].title || arr[i]);
    var getTitle = (arr, i) => arr[i] && (arr[i].title || arr[i].value || arr[i]);
    var getIndex = (arr, valOrTitle) => {
      const index = arr.findIndex((el) => el.value === valOrTitle || el.title === valOrTitle);
      return index > -1 ? index : void 0;
    };
    var AutocompletePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.suggest = opts.suggest;
        this.choices = opts.choices;
        this.initial = typeof opts.initial === "number" ? opts.initial : getIndex(opts.choices, opts.initial);
        this.select = this.initial || opts.cursor || 0;
        this.i18n = {noMatches: opts.noMatches || "no matches found"};
        this.fallback = opts.fallback || this.initial;
        this.clearFirst = opts.clearFirst || false;
        this.suggestions = [];
        this.input = "";
        this.limit = opts.limit || 10;
        this.cursor = 0;
        this.transform = style.render(opts.style);
        this.scale = this.transform.scale;
        this.render = this.render.bind(this);
        this.complete = this.complete.bind(this);
        this.clear = clear("", this.out.columns);
        this.complete(this.render);
        this.render();
      }
      set fallback(fb) {
        this._fb = Number.isSafeInteger(parseInt(fb)) ? parseInt(fb) : fb;
      }
      get fallback() {
        let choice;
        if (typeof this._fb === "number")
          choice = this.choices[this._fb];
        else if (typeof this._fb === "string")
          choice = {title: this._fb};
        return choice || this._fb || {title: this.i18n.noMatches};
      }
      moveSelect(i) {
        this.select = i;
        if (this.suggestions.length > 0)
          this.value = getVal(this.suggestions, i);
        else
          this.value = this.fallback.value;
        this.fire();
      }
      async complete(cb) {
        const p = this.completing = this.suggest(this.input, this.choices);
        const suggestions = await p;
        if (this.completing !== p)
          return;
        this.suggestions = suggestions.map((s, i, arr) => ({title: getTitle(arr, i), value: getVal(arr, i), description: s.description}));
        this.completing = false;
        const l = Math.max(suggestions.length - 1, 0);
        this.moveSelect(Math.min(l, this.select));
        cb && cb();
      }
      reset() {
        this.input = "";
        this.complete(() => {
          this.moveSelect(this.initial !== void 0 ? this.initial : 0);
          this.render();
        });
        this.render();
      }
      exit() {
        if (this.clearFirst && this.input.length > 0) {
          this.reset();
        } else {
          this.done = this.exited = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
      }
      abort() {
        this.done = this.aborted = true;
        this.exited = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        this.done = true;
        this.aborted = this.exited = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      _(c, key) {
        let s1 = this.input.slice(0, this.cursor);
        let s2 = this.input.slice(this.cursor);
        this.input = `${s1}${c}${s2}`;
        this.cursor = s1.length + 1;
        this.complete(this.render);
        this.render();
      }
      delete() {
        if (this.cursor === 0)
          return this.bell();
        let s1 = this.input.slice(0, this.cursor - 1);
        let s2 = this.input.slice(this.cursor);
        this.input = `${s1}${s2}`;
        this.complete(this.render);
        this.cursor = this.cursor - 1;
        this.render();
      }
      deleteForward() {
        if (this.cursor * this.scale >= this.rendered.length)
          return this.bell();
        let s1 = this.input.slice(0, this.cursor);
        let s2 = this.input.slice(this.cursor + 1);
        this.input = `${s1}${s2}`;
        this.complete(this.render);
        this.render();
      }
      first() {
        this.moveSelect(0);
        this.render();
      }
      last() {
        this.moveSelect(this.suggestions.length - 1);
        this.render();
      }
      up() {
        if (this.select === 0) {
          this.moveSelect(this.suggestions.length - 1);
        } else {
          this.moveSelect(this.select - 1);
        }
        this.render();
      }
      down() {
        if (this.select === this.suggestions.length - 1) {
          this.moveSelect(0);
        } else {
          this.moveSelect(this.select + 1);
        }
        this.render();
      }
      next() {
        if (this.select === this.suggestions.length - 1) {
          this.moveSelect(0);
        } else
          this.moveSelect(this.select + 1);
        this.render();
      }
      nextPage() {
        this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1));
        this.render();
      }
      prevPage() {
        this.moveSelect(Math.max(this.select - this.limit, 0));
        this.render();
      }
      left() {
        if (this.cursor <= 0)
          return this.bell();
        this.cursor = this.cursor - 1;
        this.render();
      }
      right() {
        if (this.cursor * this.scale >= this.rendered.length)
          return this.bell();
        this.cursor = this.cursor + 1;
        this.render();
      }
      renderOption(v, hovered, isStart, isEnd) {
        let desc;
        let prefix = isStart ? figures.arrowUp : isEnd ? figures.arrowDown : " ";
        let title = hovered ? color.cyan().underline(v.title) : v.title;
        prefix = (hovered ? color.cyan(figures.pointer) + " " : "  ") + prefix;
        if (v.description) {
          desc = ` - ${v.description}`;
          if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
            desc = "\n" + wrap(v.description, {margin: 3, width: this.out.columns});
          }
        }
        return prefix + " " + title + color.gray(desc || "");
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        let {startIndex, endIndex} = entriesToDisplay(this.select, this.choices.length, this.limit);
        this.outputText = [
          style.symbol(this.done, this.aborted, this.exited),
          color.bold(this.msg),
          style.delimiter(this.completing),
          this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)
        ].join(" ");
        if (!this.done) {
          const suggestions = this.suggestions.slice(startIndex, endIndex).map((item, i) => this.renderOption(item, this.select === i + startIndex, i === 0 && startIndex > 0, i + startIndex === endIndex - 1 && endIndex < this.choices.length)).join("\n");
          this.outputText += `
` + (suggestions || color.gray(this.fallback.title));
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module2.exports = AutocompletePrompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/autocompleteMultiselect.js
var require_autocompleteMultiselect2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/autocompleteMultiselect.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var {cursor} = require_src();
    var MultiselectPrompt = require_multiselect2();
    var {clear, style, figures} = require_util3();
    var AutocompleteMultiselectPrompt = class extends MultiselectPrompt {
      constructor(opts = {}) {
        opts.overrideRender = true;
        super(opts);
        this.inputValue = "";
        this.clear = clear("", this.out.columns);
        this.filteredOptions = this.value;
        this.render();
      }
      last() {
        this.cursor = this.filteredOptions.length - 1;
        this.render();
      }
      next() {
        this.cursor = (this.cursor + 1) % this.filteredOptions.length;
        this.render();
      }
      up() {
        if (this.cursor === 0) {
          this.cursor = this.filteredOptions.length - 1;
        } else {
          this.cursor--;
        }
        this.render();
      }
      down() {
        if (this.cursor === this.filteredOptions.length - 1) {
          this.cursor = 0;
        } else {
          this.cursor++;
        }
        this.render();
      }
      left() {
        this.filteredOptions[this.cursor].selected = false;
        this.render();
      }
      right() {
        if (this.value.filter((e) => e.selected).length >= this.maxChoices)
          return this.bell();
        this.filteredOptions[this.cursor].selected = true;
        this.render();
      }
      delete() {
        if (this.inputValue.length) {
          this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1);
          this.updateFilteredOptions();
        }
      }
      updateFilteredOptions() {
        const currentHighlight = this.filteredOptions[this.cursor];
        this.filteredOptions = this.value.filter((v) => {
          if (this.inputValue) {
            if (typeof v.title === "string") {
              if (v.title.toLowerCase().includes(this.inputValue.toLowerCase())) {
                return true;
              }
            }
            if (typeof v.value === "string") {
              if (v.value.toLowerCase().includes(this.inputValue.toLowerCase())) {
                return true;
              }
            }
            return false;
          }
          return true;
        });
        const newHighlightIndex = this.filteredOptions.findIndex((v) => v === currentHighlight);
        this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex;
        this.render();
      }
      handleSpaceToggle() {
        const v = this.filteredOptions[this.cursor];
        if (v.selected) {
          v.selected = false;
          this.render();
        } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
          return this.bell();
        } else {
          v.selected = true;
          this.render();
        }
      }
      handleInputChange(c) {
        this.inputValue = this.inputValue + c;
        this.updateFilteredOptions();
      }
      _(c, key) {
        if (c === " ") {
          this.handleSpaceToggle();
        } else {
          this.handleInputChange(c);
        }
      }
      renderInstructions() {
        if (this.instructions === void 0 || this.instructions) {
          if (typeof this.instructions === "string") {
            return this.instructions;
          }
          return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
`;
        }
        return "";
      }
      renderCurrentInput() {
        return `
Filtered results for: ${this.inputValue ? this.inputValue : color.gray("Enter something to filter")}
`;
      }
      renderOption(cursor2, v, i) {
        let title;
        if (v.disabled)
          title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
        else
          title = cursor2 === i ? color.cyan().underline(v.title) : v.title;
        return (v.selected ? color.green(figures.radioOn) : figures.radioOff) + "  " + title;
      }
      renderDoneOrInstructions() {
        if (this.done) {
          return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
        }
        const output = [color.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
        if (this.filteredOptions.length && this.filteredOptions[this.cursor].disabled) {
          output.push(color.yellow(this.warn));
        }
        return output.join(" ");
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        super.render();
        let prompt = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(false),
          this.renderDoneOrInstructions()
        ].join(" ");
        if (this.showMinError) {
          prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
          this.showMinError = false;
        }
        prompt += this.renderOptions(this.filteredOptions);
        this.out.write(this.clear + prompt);
        this.clear = clear(prompt, this.out.columns);
      }
    };
    module2.exports = AutocompleteMultiselectPrompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/confirm.js
var require_confirm2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/confirm.js"(exports2, module2) {
    var color = require_kleur();
    var Prompt = require_prompt2();
    var {style, clear} = require_util3();
    var {erase, cursor} = require_src();
    var ConfirmPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.value = opts.initial;
        this.initialValue = !!opts.initial;
        this.yesMsg = opts.yes || "yes";
        this.yesOption = opts.yesOption || "(Y/n)";
        this.noMsg = opts.no || "no";
        this.noOption = opts.noOption || "(y/N)";
        this.render();
      }
      reset() {
        this.value = this.initialValue;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        this.value = this.value || false;
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      _(c, key) {
        if (c.toLowerCase() === "y") {
          this.value = true;
          return this.submit();
        }
        if (c.toLowerCase() === "n") {
          this.value = false;
          return this.submit();
        }
        return this.bell();
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        this.outputText = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(this.done),
          this.done ? this.value ? this.yesMsg : this.noMsg : color.gray(this.initialValue ? this.yesOption : this.noOption)
        ].join(" ");
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module2.exports = ConfirmPrompt;
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/index.js
var require_elements2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      TextPrompt: require_text2(),
      SelectPrompt: require_select2(),
      TogglePrompt: require_toggle2(),
      DatePrompt: require_date2(),
      NumberPrompt: require_number2(),
      MultiselectPrompt: require_multiselect2(),
      AutocompletePrompt: require_autocomplete2(),
      AutocompleteMultiselectPrompt: require_autocompleteMultiselect2(),
      ConfirmPrompt: require_confirm2()
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/prompts.js
var require_prompts2 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/prompts.js"(exports2) {
    "use strict";
    var $ = exports2;
    var el = require_elements2();
    var noop = (v) => v;
    function toPrompt(type, args, opts = {}) {
      return new Promise((res, rej) => {
        const p = new el[type](args);
        const onAbort = opts.onAbort || noop;
        const onSubmit = opts.onSubmit || noop;
        const onExit = opts.onExit || noop;
        p.on("state", args.onState || noop);
        p.on("submit", (x) => res(onSubmit(x)));
        p.on("exit", (x) => res(onExit(x)));
        p.on("abort", (x) => rej(onAbort(x)));
      });
    }
    $.text = (args) => toPrompt("TextPrompt", args);
    $.password = (args) => {
      args.style = "password";
      return $.text(args);
    };
    $.invisible = (args) => {
      args.style = "invisible";
      return $.text(args);
    };
    $.number = (args) => toPrompt("NumberPrompt", args);
    $.date = (args) => toPrompt("DatePrompt", args);
    $.confirm = (args) => toPrompt("ConfirmPrompt", args);
    $.list = (args) => {
      const sep = args.separator || ",";
      return toPrompt("TextPrompt", args, {
        onSubmit: (str) => str.split(sep).map((s) => s.trim())
      });
    };
    $.toggle = (args) => toPrompt("TogglePrompt", args);
    $.select = (args) => toPrompt("SelectPrompt", args);
    $.multiselect = (args) => {
      args.choices = [].concat(args.choices || []);
      const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
      return toPrompt("MultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    $.autocompleteMultiselect = (args) => {
      args.choices = [].concat(args.choices || []);
      const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
      return toPrompt("AutocompleteMultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    var byTitle = (input, choices) => Promise.resolve(choices.filter((item) => item.title.slice(0, input.length).toLowerCase() === input.toLowerCase()));
    $.autocomplete = (args) => {
      args.suggest = args.suggest || byTitle;
      args.choices = [].concat(args.choices || []);
      return toPrompt("AutocompletePrompt", args);
    };
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/lib/index.js
var require_lib = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/lib/index.js"(exports2, module2) {
    "use strict";
    var prompts = require_prompts2();
    var passOn = ["suggest", "format", "onState", "validate", "onRender", "type"];
    var noop = () => {
    };
    async function prompt(questions = [], {onSubmit = noop, onCancel = noop} = {}) {
      const answers = {};
      const override2 = prompt._override || {};
      questions = [].concat(questions);
      let answer, question, quit, name, type, lastPrompt;
      const getFormattedAnswer = async (question2, answer2, skipValidation = false) => {
        if (!skipValidation && question2.validate && question2.validate(answer2) !== true) {
          return;
        }
        return question2.format ? await question2.format(answer2, answers) : answer2;
      };
      for (question of questions) {
        ({name, type} = question);
        if (typeof type === "function") {
          type = await type(answer, __spreadValues({}, answers), question);
          question["type"] = type;
        }
        if (!type)
          continue;
        for (let key in question) {
          if (passOn.includes(key))
            continue;
          let value = question[key];
          question[key] = typeof value === "function" ? await value(answer, __spreadValues({}, answers), lastPrompt) : value;
        }
        lastPrompt = question;
        if (typeof question.message !== "string") {
          throw new Error("prompt message is required");
        }
        ({name, type} = question);
        if (prompts[type] === void 0) {
          throw new Error(`prompt type (${type}) is not defined`);
        }
        if (override2[question.name] !== void 0) {
          answer = await getFormattedAnswer(question, override2[question.name]);
          if (answer !== void 0) {
            answers[name] = answer;
            continue;
          }
        }
        try {
          answer = prompt._injected ? getInjectedAnswer(prompt._injected, question.initial) : await prompts[type](question);
          answers[name] = answer = await getFormattedAnswer(question, answer, true);
          quit = await onSubmit(question, answer, answers);
        } catch (err) {
          quit = !await onCancel(question, answers);
        }
        if (quit)
          return answers;
      }
      return answers;
    }
    function getInjectedAnswer(injected, deafultValue) {
      const answer = injected.shift();
      if (answer instanceof Error) {
        throw answer;
      }
      return answer === void 0 ? deafultValue : answer;
    }
    function inject(answers) {
      prompt._injected = (prompt._injected || []).concat(answers);
    }
    function override(answers) {
      prompt._override = Object.assign({}, answers);
    }
    module2.exports = Object.assign(prompt, {prompt, prompts, inject, override});
  }
});

// .pnpm/prompts@2.4.1/node_modules/prompts/index.js
var require_prompts3 = __commonJS({
  ".pnpm/prompts@2.4.1/node_modules/prompts/index.js"(exports2, module2) {
    function isNodeLT(tar) {
      tar = (Array.isArray(tar) ? tar : tar.split(".")).map(Number);
      let i = 0, src = process.versions.node.split(".").map(Number);
      for (; i < tar.length; i++) {
        if (src[i] > tar[i])
          return false;
        if (tar[i] > src[i])
          return true;
      }
      return false;
    }
    module2.exports = isNodeLT("8.6.0") ? require_dist() : require_lib();
  }
});

// .pnpm/colors@1.0.3/node_modules/colors/lib/styles.js
var require_styles = __commonJS({
  ".pnpm/colors@1.0.3/node_modules/colors/lib/styles.js"(exports2, module2) {
    var styles = {};
    module2["exports"] = styles;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = "[" + val[0] + "m";
      style.close = "[" + val[1] + "m";
    });
  }
});

// .pnpm/colors@1.0.3/node_modules/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  ".pnpm/colors@1.0.3/node_modules/colors/lib/system/supports-colors.js"(exports2, module2) {
    var argv = process.argv;
    module2.exports = function() {
      if (argv.indexOf("--no-color") !== -1 || argv.indexOf("--color=false") !== -1) {
        return false;
      }
      if (argv.indexOf("--color") !== -1 || argv.indexOf("--color=true") !== -1 || argv.indexOf("--color=always") !== -1) {
        return true;
      }
      if (process.stdout && !process.stdout.isTTY) {
        return false;
      }
      if (process.platform === "win32") {
        return true;
      }
      if ("COLORTERM" in process.env) {
        return true;
      }
      if (process.env.TERM === "dumb") {
        return false;
      }
      if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
        return true;
      }
      return false;
    }();
  }
});

// .pnpm/colors@1.0.3/node_modules/colors/lib/custom/trap.js
var require_trap = __commonJS({
  ".pnpm/colors@1.0.3/node_modules/colors/lib/custom/trap.js"(exports2, module2) {
    module2["exports"] = function runTheTrap(text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: ["\xCB", "\u0115", "\u018E", "\u0258", "\u03A3", "\u03BE", "\u04BC", "\u0A6C"],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: ["\xD8", "\xF5", "\xF8", "\u01FE", "\u0298", "\u047A", "\u05DD", "\u06DD", "\u0E4F"],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
  }
});

// .pnpm/colors@1.0.3/node_modules/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  ".pnpm/colors@1.0.3/node_modules/colors/lib/custom/zalgo.js"(exports2, module2) {
    module2["exports"] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      }, all = [].concat(soul.up, soul.down, soul.mid), zalgo2 = {};
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      function is_char(character) {
        var bool = false;
        all.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      function heComes(text2, options2) {
        var result = "", counts, l;
        options2 = options2 || {};
        options2["up"] = options2["up"] || true;
        options2["mid"] = options2["mid"] || true;
        options2["down"] = options2["down"] || true;
        options2["size"] = options2["size"] || "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (is_char(l)) {
            continue;
          }
          result = result + text2[l];
          counts = {"up": 0, "down": 0, "mid": 0};
          switch (options2.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.min = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.min = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0; i <= counts[index]; i++) {
              if (options2[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text);
    };
  }
});

// .pnpm/colors@1.0.3/node_modules/colors/lib/maps/america.js
var require_america = __commonJS({
  ".pnpm/colors@1.0.3/node_modules/colors/lib/maps/america.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = function() {
      return function(letter, i, exploded) {
        if (letter === " ")
          return letter;
        switch (i % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    }();
  }
});

// .pnpm/colors@1.0.3/node_modules/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  ".pnpm/colors@1.0.3/node_modules/colors/lib/maps/zebra.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = function(letter, i, exploded) {
      return i % 2 === 0 ? letter : colors.inverse(letter);
    };
  }
});

// .pnpm/colors@1.0.3/node_modules/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  ".pnpm/colors@1.0.3/node_modules/colors/lib/maps/rainbow.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = function() {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    }();
  }
});

// .pnpm/colors@1.0.3/node_modules/colors/lib/maps/random.js
var require_random = __commonJS({
  ".pnpm/colors@1.0.3/node_modules/colors/lib/maps/random.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = function() {
      var available = ["underline", "inverse", "grey", "yellow", "red", "green", "blue", "white", "cyan", "magenta"];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);
      };
    }();
  }
});

// .pnpm/colors@1.0.3/node_modules/colors/lib/colors.js
var require_colors = __commonJS({
  ".pnpm/colors@1.0.3/node_modules/colors/lib/colors.js"(exports2, module2) {
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    colors.supportsColor = require_supports_colors();
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor;
    }
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style) {
      return ansiStyles[style].open + str + ansiStyles[style].close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles);
    function applyStyle() {
      var args = arguments;
      var argsLen = args.length;
      var str = argsLen !== 0 && String(arguments[0]);
      if (argsLen > 1) {
        for (var a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!colors.enabled || !str) {
        return str;
      }
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
      }
      return str;
    }
    function applyTheme(theme) {
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            return colors[theme[style2]](str);
          };
        })(style);
      }
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        try {
          colors.themes[theme] = require(theme);
          applyTheme(colors.themes[theme]);
          return colors.themes[theme];
        } catch (err) {
          console.log(err);
          return err;
        }
      } else {
        applyTheme(theme);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles).forEach(function(name) {
        ret[name] = {
          get: function() {
            return build([name]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map2, str) {
      var exploded = str.split(""), i = 0;
      exploded = exploded.map(map2);
      return exploded.join("");
    };
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america();
    colors.maps.zebra = require_zebra();
    colors.maps.rainbow = require_rainbow();
    colors.maps.random = require_random();
    for (var map in colors.maps) {
      (function(map2) {
        colors[map2] = function(str) {
          return sequencer(colors.maps[map2], str);
        };
      })(map);
    }
    defineProps(colors, init());
  }
});

// .pnpm/colors@1.0.3/node_modules/colors/safe.js
var require_safe = __commonJS({
  ".pnpm/colors@1.0.3/node_modules/colors/safe.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = colors;
  }
});

// .pnpm/cli-table@0.3.6/node_modules/cli-table/lib/utils.js
var require_utils = __commonJS({
  ".pnpm/cli-table@0.3.6/node_modules/cli-table/lib/utils.js"(exports2) {
    exports2.repeat = function(str, times) {
      return Array(times + 1).join(str);
    };
    exports2.pad = function(str, len, pad, dir) {
      if (len + 1 >= str.length)
        switch (dir) {
          case "left":
            str = Array(len + 1 - str.length).join(pad) + str;
            break;
          case "both":
            var right = Math.ceil((padlen = len - str.length) / 2);
            var left = padlen - right;
            str = Array(left + 1).join(pad) + str + Array(right + 1).join(pad);
            break;
          default:
            str = str + Array(len + 1 - str.length).join(pad);
        }
      ;
      return str;
    };
    exports2.truncate = function(str, length, chr) {
      chr = chr || "\u2026";
      return str.length >= length ? str.substr(0, length - chr.length) + chr : str;
    };
    function options(defaults, opts) {
      for (var p in opts) {
        if (p === "__proto__" || p === "constructor" || p === "prototype") {
          continue;
        }
        if (opts[p] && opts[p].constructor && opts[p].constructor === Object) {
          defaults[p] = defaults[p] || {};
          options(defaults[p], opts[p]);
        } else {
          defaults[p] = opts[p];
        }
      }
      return defaults;
    }
    exports2.options = options;
    exports2.strlen = function(str) {
      var code = /\u001b\[(?:\d*;){0,5}\d*m/g;
      var stripped = ("" + str).replace(code, "");
      var split = stripped.split("\n");
      return split.reduce(function(memo, s) {
        return s.length > memo ? s.length : memo;
      }, 0);
    };
  }
});

// .pnpm/cli-table@0.3.6/node_modules/cli-table/lib/index.js
var require_lib2 = __commonJS({
  ".pnpm/cli-table@0.3.6/node_modules/cli-table/lib/index.js"(exports2, module2) {
    var colors = require_safe();
    var utils = require_utils();
    var repeat = utils.repeat;
    var truncate = utils.truncate;
    var pad = utils.pad;
    function Table(options) {
      this.options = utils.options({
        chars: {
          "top": "\u2500",
          "top-mid": "\u252C",
          "top-left": "\u250C",
          "top-right": "\u2510",
          "bottom": "\u2500",
          "bottom-mid": "\u2534",
          "bottom-left": "\u2514",
          "bottom-right": "\u2518",
          "left": "\u2502",
          "left-mid": "\u251C",
          "mid": "\u2500",
          "mid-mid": "\u253C",
          "right": "\u2502",
          "right-mid": "\u2524",
          "middle": "\u2502"
        },
        truncate: "\u2026",
        colWidths: [],
        colAligns: [],
        style: {
          "padding-left": 1,
          "padding-right": 1,
          head: ["red"],
          border: ["grey"],
          compact: false
        },
        head: []
      }, options);
    }
    Table.prototype.__proto__ = Array.prototype;
    Table.prototype.__defineGetter__("width", function() {
      var str = this.toString().split("\n");
      if (str.length)
        return str[0].length;
      return 0;
    });
    Table.prototype.render;
    Table.prototype.toString = function() {
      var ret = "", options = this.options, style = options.style, head = options.head, chars = options.chars, truncater = options.truncate, colWidths = options.colWidths || new Array(this.head.length), totalWidth = 0;
      if (!head.length && !this.length)
        return "";
      if (!colWidths.length) {
        var all_rows = this.slice(0);
        if (head.length) {
          all_rows = all_rows.concat([head]);
        }
        ;
        all_rows.forEach(function(cells) {
          if (typeof cells === "object" && cells.length) {
            extractColumnWidths(cells);
          } else {
            var header_cell = Object.keys(cells)[0], value_cell = cells[header_cell];
            colWidths[0] = Math.max(colWidths[0] || 0, get_width(header_cell) || 0);
            if (typeof value_cell === "object" && value_cell.length) {
              extractColumnWidths(value_cell, 1);
            } else {
              colWidths[1] = Math.max(colWidths[1] || 0, get_width(value_cell) || 0);
            }
          }
        });
      }
      ;
      totalWidth = (colWidths.length == 1 ? colWidths[0] : colWidths.reduce(function(a, b) {
        return a + b;
      })) + colWidths.length + 1;
      function extractColumnWidths(arr, offset) {
        var offset = offset || 0;
        arr.forEach(function(cell, i) {
          colWidths[i + offset] = Math.max(colWidths[i + offset] || 0, get_width(cell) || 0);
        });
      }
      ;
      function get_width(obj) {
        return typeof obj == "object" && obj.width != void 0 ? obj.width : (typeof obj == "object" ? utils.strlen(obj.text) : utils.strlen(obj)) + (style["padding-left"] || 0) + (style["padding-right"] || 0);
      }
      function line(line2, left, right, intersection) {
        var width = 0, line2 = left + repeat(line2, totalWidth - 2) + right;
        colWidths.forEach(function(w, i) {
          if (i == colWidths.length - 1)
            return;
          width += w + 1;
          line2 = line2.substr(0, width) + intersection + line2.substr(width + 1);
        });
        return applyStyles(options.style.border, line2);
      }
      ;
      function lineTop() {
        var l2 = line(chars.top, chars["top-left"] || chars.top, chars["top-right"] || chars.top, chars["top-mid"]);
        if (l2)
          ret += l2 + "\n";
      }
      ;
      function generateRow(items, style2) {
        var cells = [], max_height = 0;
        if (!Array.isArray(items) && typeof items === "object") {
          var key = Object.keys(items)[0], value = items[key], first_cell_head = true;
          if (Array.isArray(value)) {
            items = value;
            items.unshift(key);
          } else {
            items = [key, value];
          }
        }
        items.forEach(function(item, i) {
          var contents = item.toString().split("\n").reduce(function(memo, l2) {
            memo.push(string(l2, i));
            return memo;
          }, []);
          var height = contents.length;
          if (height > max_height) {
            max_height = height;
          }
          ;
          cells.push({contents, height});
        });
        var lines = new Array(max_height);
        cells.forEach(function(cell, i) {
          cell.contents.forEach(function(line2, j2) {
            if (!lines[j2]) {
              lines[j2] = [];
            }
            ;
            if (style2 || first_cell_head && i === 0 && options.style.head) {
              line2 = applyStyles(options.style.head, line2);
            }
            lines[j2].push(line2);
          });
          for (var j = cell.height, l2 = max_height; j < l2; j++) {
            if (!lines[j]) {
              lines[j] = [];
            }
            ;
            lines[j].push(string("", i));
          }
        });
        var ret2 = "";
        lines.forEach(function(line2, index) {
          if (ret2.length > 0) {
            ret2 += "\n" + applyStyles(options.style.border, chars.left);
          }
          ret2 += line2.join(applyStyles(options.style.border, chars.middle)) + applyStyles(options.style.border, chars.right);
        });
        return applyStyles(options.style.border, chars.left) + ret2;
      }
      ;
      function applyStyles(styles, subject) {
        if (!subject)
          return "";
        styles.forEach(function(style2) {
          subject = colors[style2](subject);
        });
        return subject;
      }
      ;
      function string(str, index) {
        var str = String(typeof str == "object" && str.text ? str.text : str), length = utils.strlen(str), width = colWidths[index] - (style["padding-left"] || 0) - (style["padding-right"] || 0), align = options.colAligns[index] || "left";
        return repeat(" ", style["padding-left"] || 0) + (length == width ? str : length < width ? pad(str, width + (str.length - length), " ", align == "left" ? "right" : align == "middle" ? "both" : "left") : truncater ? truncate(str, width, truncater) : str) + repeat(" ", style["padding-right"] || 0);
      }
      ;
      if (head.length) {
        lineTop();
        ret += generateRow(head, style.head) + "\n";
      }
      if (this.length)
        this.forEach(function(cells, i) {
          if (!head.length && i == 0)
            lineTop();
          else {
            if (!style.compact || i < !!head.length ? 1 : cells.length == 0) {
              var l2 = line(chars.mid, chars["left-mid"], chars["right-mid"], chars["mid-mid"]);
              if (l2)
                ret += l2 + "\n";
            }
          }
          if (cells.hasOwnProperty("length") && !cells.length) {
            return;
          } else {
            ret += generateRow(cells) + "\n";
          }
          ;
        });
      var l = line(chars.bottom, chars["bottom-left"] || chars.bottom, chars["bottom-right"] || chars.bottom, chars["bottom-mid"]);
      if (l)
        ret += l;
      else
        ret = ret.slice(0, -1);
      return ret;
    };
    module2.exports = Table;
    module2.exports.version = "0.0.1";
  }
});

// lib/cli.js
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var chalk = require_source();
var FS = require("fs");
var Path = require("path");
var _package = require_package_82f828d2();
require("child_process");
require("os");
require("util");
var DeploymentManager = require_DeploymentManager_b2827254();
function _interopDefaultLegacy(e) {
  return e && typeof e === "object" && "default" in e ? e : {"default": e};
}
function _interopNamespace(e) {
  if (e && e.__esModule)
    return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function(k) {
      if (k !== "default") {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function() {
            return e[k];
          }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}
var chalk__default = /* @__PURE__ */ _interopDefaultLegacy(chalk);
var FS__namespace = /* @__PURE__ */ _interopNamespace(FS);
var Path__namespace = /* @__PURE__ */ _interopNamespace(Path);
async function cli(args) {
  const yargs = await Promise.resolve().then(function() {
    return /* @__PURE__ */ _interopNamespace(require_yargs());
  });
  const prompts = await Promise.resolve().then(function() {
    return /* @__PURE__ */ _interopNamespace(require_prompts3());
  });
  const Table = await Promise.resolve().then(function() {
    return /* @__PURE__ */ _interopNamespace(require_lib2());
  });
  const configFile = Path__namespace.resolve(process.cwd(), "deploy.json");
  if (!FS__namespace.existsSync(configFile)) {
    throw new DeploymentManager.Exception("MissingConfigFile", "Cannot find deploy.json in current directory.");
  }
  const config = await DeploymentManager.importJSON(configFile);
  const deployer = new DeploymentManager.DeploymentManager(config);
  yargs.default(args).scriptName("deploy").version(_package.version).command("check", "check server compatibility", {
    builder: {},
    handler: async () => {
      await deployer.check();
      console.log(chalk__default["default"].green("OK."));
    }
  }).command("apps", "show available apps", {
    builder: {},
    handler: async () => {
      const apps = await deployer.apps();
      const table = new Table.default({head: ["App Name"]});
      for (const app of apps) {
        table.push([app]);
      }
      if (apps.length === 0)
        console.warn(chalk__default["default"].yellow("No apps found."));
      else
        console.log(table.toString());
    }
  }).command("releases", "show releases of an app", {
    builder: {
      app: {
        alias: ["a"],
        default: process.env.DEPLOYER_APP,
        demandOption: true,
        description: "App name"
      }
    },
    handler: async ({app}) => {
      const appManager = await deployer.connect(app);
      const releases = appManager.app.releases;
      const instances = await appManager.instances();
      if (releases.length > 0) {
        const table = new Table.default({
          head: ["Id", "Created At", "Commit", "Tag", "Instances"]
        });
        for (const release of releases) {
          table.push([
            release.id,
            release.createdAt,
            release.commit,
            release.tag,
            instances.filter((instance) => instance.releaseId === release.id).map((instance) => instance.id).join(", ")
          ]);
        }
        console.log(table.toString());
      } else {
        console.warn(chalk__default["default"].yellow("No releases found."));
      }
    }
  }).command("instances", "show instances of an app", {
    builder: {
      app: {
        alias: ["a"],
        default: process.env.DEPLOYER_APP,
        demandOption: true,
        description: "App name"
      }
    },
    handler: async ({app}) => {
      const appManager = await deployer.connect(app);
      const instances = await appManager.instances();
      if (instances.length > 0) {
        const table = new Table.default({
          head: ["Id", "Release", "Created At", "Preview"]
        });
        for (const instance of instances) {
          table.push([instance.id.slice(-6), `v${instance.releaseId}`, instance.createdAt, instance.preview]);
        }
        console.log(table.toString());
      } else {
        console.warn(chalk__default["default"].yellow("No releases found."));
      }
    }
  }).command("create-app", "create a new app", {
    builder: {},
    handler: async () => {
      const {name, domain, email, domainAliases, repository, healthcheck, maxReleases, maxDeploymentHistory} = await prompts.default([
        {
          type: "text",
          name: "name",
          message: "Short app name"
        },
        {
          type: "text",
          name: "domain",
          message: "Primary application domain"
        },
        {
          type: "text",
          name: "email",
          message: "Email address for SSL certificate notifications"
        },
        {
          type: "list",
          name: "domainAliases",
          message: "Other domains"
        },
        {
          type: "text",
          name: "repository",
          message: "GitHub repository"
        },
        {
          type: "text",
          name: "healthcheck",
          message: "Healthcheck URL",
          initial: 'curl -sSf "http://localhost:${PORT}/health"'
        },
        {
          type: "number",
          name: "maxReleases",
          message: "Max number of releases to keep",
          increment: 1,
          initial: 5
        },
        {
          type: "number",
          name: "maxDeploymentHistory",
          message: "Max deployment history to keep",
          increment: 1,
          initial: 100
        }
      ]);
      const app = await deployer.create({
        name,
        domain,
        email,
        domainAliases: domainAliases.filter(Boolean),
        repository,
        healthcheck,
        maxReleases,
        maxDeploymentHistory
      });
      console.log(chalk__default["default"].gray(`Application ${chalk__default["default"].white(DeploymentManager.quote(app.app.name))} created. Set ${chalk__default["default"].green(`DEPLOYER_APP=${app.app.name}`)} to use as default app.`));
    }
  }).command("create-release [artefact]", "create a new release", {
    builder: (yargs2) => yargs2.positional("artefact", {default: ".", description: "Directory or a tar file"}).option("app", {
      alias: ["a"],
      default: process.env.DEPLOYER_APP,
      demandOption: true,
      description: "App name"
    }).option("commit", {demandOption: true, description: "Commit SHA", alias: ["c"]}).option("tag", {description: "Release tag or version", alias: ["t"]}),
    handler: async ({app, commit, tag = "main", artefact}) => {
      if (!Path__namespace.isAbsolute(artefact)) {
        artefact = Path__namespace.resolve(process.cwd(), artefact);
      }
      const manager = await deployer.connect(app);
      const release = await manager.createRelease({commit, tag}, artefact);
      console.log(`Created release v${release.id} `);
    }
  }).command("create-instance <id>", "create an instance of a release", {
    builder: (yargs2) => yargs2.positional("id", {
      demandOption: true,
      description: "Release ID",
      number: true
    }).option("app", {
      alias: ["a"],
      default: process.env.DEPLOYER_APP,
      demandOption: true,
      description: "App name"
    }),
    handler: async ({app, id}) => {
      const manager = await deployer.connect(app);
      const instance = await manager.createInstance(id);
      console.log(`Created instance (id: ${instance.id.slice(-6)}) from v${instance.releaseId} of ${app}.`);
      console.log(`Instance URL: ${chalk__default["default"].green(instance.preview)}`);
    }
  }).command("promote-instance <id>", "promote an instance of a release to production", {
    builder: (yargs2) => yargs2.positional("id", {
      demandOption: true,
      description: "App instance ID"
    }).option("app", {
      alias: ["a"],
      default: process.env.DEPLOYER_APP,
      demandOption: true,
      description: "App name"
    }),
    handler: async ({app, id}) => {
      const manager = await deployer.connect(app);
      const instances = await manager.instances();
      const matchingInstances = instances.filter((instance) => instance.id.endsWith(id));
      if (matchingInstances.length > 1)
        throw new DeploymentManager.Exception("InstanceShortIDCollision", "Provide full instance id");
      if (matchingInstances.length === 0) {
        await manager.deploy(id);
      } else {
        await manager.deploy(matchingInstances[0].id);
      }
      console.log(chalk__default["default"].gray(`Done.`));
    }
  }).command("delete-instance <id>", "delete an instance of a release", {
    builder: (yargs2) => yargs2.positional("id", {
      demandOption: true,
      description: "App instance ID"
    }).option("app", {
      alias: ["a"],
      default: process.env.DEPLOYER_APP,
      demandOption: true,
      description: "App name"
    }),
    handler: async ({app, id}) => {
      const manager = await deployer.connect(app);
      const instances = await manager.instances();
      const matchingInstances = instances.filter((instance) => instance.id.endsWith(id));
      if (matchingInstances.length > 1)
        throw new DeploymentManager.Exception("InstanceShortIDCollision", "Provide full instance id");
      if (matchingInstances.length === 0) {
        await manager.destroyInstance(id);
      } else {
        await manager.destroyInstance(matchingInstances[0].id);
      }
      console.log(chalk__default["default"].gray(`Done.`));
    }
  }).command("delete-release <id>", "delete a release", {
    builder: (yargs2) => yargs2.positional("id", {
      demandOption: true,
      description: "Release ID",
      number: true
    }).option("app", {
      alias: ["a"],
      default: process.env.DEPLOYER_APP,
      demandOption: true,
      description: "App name"
    }),
    handler: async ({app, id}) => {
      const manager = await deployer.connect(app);
      await manager.destroyRelease(id);
      console.log(chalk__default["default"].gray("Done."));
    }
  }).command("status", "app/instance status", {
    builder: {
      app: {
        alias: ["a"],
        default: process.env.DEPLOYER_APP,
        demandOption: true,
        description: "App name"
      },
      instance: {
        alias: ["i"],
        description: "App instance ID"
      }
    },
    handler: async ({app, instance: id}) => {
      const manager = await deployer.connect(app);
      const instances = await manager.instances();
      const matchingInstances = id != null ? instances.filter((instance) => instance.id.endsWith(id)) : instances;
      const statuses = await Promise.all(matchingInstances.map((instance) => manager.status(instance.id)));
      const table = new Table.default({
        head: ["ID", "Release", "Status", "Preview"]
      });
      table.push(...matchingInstances.map((instance, index) => [
        instance.id.slice(-6),
        `v${instance.releaseId}`,
        statuses[index].status,
        instance.preview
      ]));
      console.log(table.toString());
    }
  }).completion("completion", false).demandCommand(1).argv;
}
exports.cli = cli;
//# sourceMappingURL=cli.js.map
