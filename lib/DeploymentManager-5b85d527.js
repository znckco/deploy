var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = {exports: {}}).exports, mod), mod.exports;
};

// .pnpm/color-name@1.1.4/node_modules/color-name/index.js
var require_color_name = __commonJS({
  ".pnpm/color-name@1.1.4/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// .pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  ".pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: {channels: 3, labels: "rgb"},
      hsl: {channels: 3, labels: "hsl"},
      hsv: {channels: 3, labels: "hsv"},
      hwb: {channels: 3, labels: "hwb"},
      cmyk: {channels: 4, labels: "cmyk"},
      xyz: {channels: 3, labels: "xyz"},
      lab: {channels: 3, labels: "lab"},
      lch: {channels: 3, labels: "lch"},
      hex: {channels: 1, labels: ["hex"]},
      keyword: {channels: 1, labels: ["keyword"]},
      ansi16: {channels: 1, labels: ["ansi16"]},
      ansi256: {channels: 1, labels: ["ansi256"]},
      hcg: {channels: 3, labels: ["h", "c", "g"]},
      apple: {channels: 3, labels: ["r16", "g16", "b16"]},
      gray: {channels: 1, labels: ["gray"]}
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const {channels, labels} = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", {value: channels});
      Object.defineProperty(convert[model], "labels", {value: labels});
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// .pnpm/color-convert@2.0.1/node_modules/color-convert/route.js
var require_route = __commonJS({
  ".pnpm/color-convert@2.0.1/node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// .pnpm/color-convert@2.0.1/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  ".pnpm/color-convert@2.0.1/node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", {value: conversions[fromModel].channels});
      Object.defineProperty(convert[fromModel], "labels", {value: conversions[fromModel].labels});
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// .pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  ".pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `[${style[0]}m`,
            close: `[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "[39m";
      styles.bgColor.close = "[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// .pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  ".pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// .pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  ".pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var {env} = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// .pnpm/chalk@4.1.0/node_modules/chalk/source/util.js
var require_util = __commonJS({
  ".pnpm/chalk@4.1.0/node_modules/chalk/source/util.js"(exports2, module2) {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// .pnpm/chalk@4.1.0/node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  ".pnpm/chalk@4.1.0/node_modules/chalk/source/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", ""],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk2, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk2;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk2, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk2, styles)(string));
          styles.push({inverse, styles: parseStyle(style)});
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk2, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// .pnpm/chalk@4.1.0/node_modules/chalk/source/index.js
var require_source = __commonJS({
  ".pnpm/chalk@4.1.0/node_modules/chalk/source/index.js"(exports2, module2) {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var {stdout: stdoutColor, stderr: stderrColor} = require_supports_color();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util();
    var {isArray} = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk3 = {};
      applyOptions(chalk3, options);
      chalk3.template = (...arguments_) => chalkTag(chalk3.template, ...arguments_);
      Object.setPrototypeOf(chalk3, Chalk.prototype);
      Object.setPrototypeOf(chalk3.template, chalk3);
      chalk3.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk3.template.Instance = ChalkClass;
      return chalk3.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, {value: builder});
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", {value: builder});
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const {level} = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const {level} = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, __spreadProps(__spreadValues({}, styles), {
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    }));
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self, string) => {
      if (self.level <= 0 || !string) {
        return self._isEmpty ? "" : string;
      }
      let styler = self._styler;
      if (styler === void 0) {
        return string;
      }
      const {openAll, closeAll} = styler;
      if (string.indexOf("") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk3, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk3, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk2 = Chalk();
    chalk2.supportsColor = stdoutColor;
    chalk2.stderr = Chalk({level: stderrColor ? stderrColor.level : 0});
    chalk2.stderr.supportsColor = stderrColor;
    module2.exports = chalk2;
  }
});

// lib/DeploymentManager-5b85d527.js
"use strict";
var chalk = require_source();
var CP = require("child_process");
var FS = require("fs");
var OS = require("os");
var Path = require("path");
var Util = require("util");
function _interopDefaultLegacy(e) {
  return e && typeof e === "object" && "default" in e ? e : {"default": e};
}
function _interopNamespace(e) {
  if (e && e.__esModule)
    return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function(k) {
      if (k !== "default") {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function() {
            return e[k];
          }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}
var chalk__default = /* @__PURE__ */ _interopDefaultLegacy(chalk);
var CP__namespace = /* @__PURE__ */ _interopNamespace(CP);
var FS__namespace = /* @__PURE__ */ _interopNamespace(FS);
var OS__namespace = /* @__PURE__ */ _interopNamespace(OS);
var Path__namespace = /* @__PURE__ */ _interopNamespace(Path);
var Util__namespace = /* @__PURE__ */ _interopNamespace(Util);
function quote(text) {
  return JSON.stringify(text);
}
var Exception = class extends Error {
  constructor(code, message = code) {
    super(message);
    this.code = code;
  }
};
var FileNotFoundException = class extends Exception {
  constructor(fileName) {
    super("FileNotFound", `No such file ${quote(fileName)}`);
    this.fileName = fileName;
  }
};
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
function areObjectsEqual(a, b, depth = 0) {
  if (typeof a !== typeof b)
    return false;
  const type = typeof a;
  if (type === "object") {
    if (a === null || b === null) {
      return a === b;
    }
    if (depth > 20)
      throw new Exception("PossibleCircularObject");
    if (Array.isArray(a) || Array.isArray(b)) {
      if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length)
          return false;
        return a.every((_, index) => areObjectsEqual(a[index], b[index], depth + 1));
      }
      return false;
    }
    const keys = Object.keys(a);
    if (keys.length !== Object.keys(b).length)
      return false;
    return keys.every((key) => areObjectsEqual(a[key], b[key], depth + 1));
  }
  return a === b;
}
function getCreatedAt() {
  return new Date().toISOString();
}
async function importJSON(configFile) {
  const contents = await FS__namespace.promises.readFile(configFile, "utf-8");
  try {
    return JSON.parse(contents);
  } catch (error) {
    throw new Exception("InvalidJSONObject", error.message);
  }
}
var AppManager = class {
  constructor(app, manifest, sh) {
    this.app = app;
    this.manifest = manifest;
    this.sh = sh;
    this.appDir = Path__namespace.dirname(this.manifest);
  }
  async saveManifest() {
    await this.sh.write(this.manifest, JSON.stringify(this.app, null, 2));
  }
  async withManifestSync(fn) {
    const app = JSON.parse(JSON.stringify(this.app));
    try {
      const result = await fn();
      await this.saveManifest();
      return result;
    } catch (error) {
      if (!areObjectsEqual(app, this.app)) {
        FS__namespace.promises.writeFile("deploy-debug.log", [
          `===== Current Manifest ====`,
          JSON.stringify(app, null, 2),
          `===== Unsaved Manifest ====`,
          JSON.stringify(this.app, null, 2)
        ].join("\n") + "\n");
        console.warn(chalk__default["default"].yellow(chalk__default["default"].bold("CommandFailure: ", "reverting app manifest to previous state.")));
      }
      throw error;
    }
  }
  async createCertificates() {
    const cmd = (await this.instances()).length > 0 ? "run --installer nginx" : "certonly";
    const args = `-n --agree-tos --dns-digitalocean --dns-digitalocean-credentials /root/.secrets/certbot/digitalocean.ini`;
    const certFile = (domain) => `/etc/letsencrypt/live/${domain}/fullchain.pem`;
    const certbot = (domain, wildCard = true) => `test -f ${quote(certFile(domain))} || certbot ${cmd} ${args} -m ${quote(this.app.domain.email)} -d ${quote(domain)} ${wildCard ? `-d ${quote(`*.${domain}`)}` : ""};`;
    await this.sh.exec([certbot(this.app.domain.primary), ...this.app.domain.aliases.map((alias) => certbot(alias))].join("\n"));
  }
  async createRelease(options, asset) {
    if (!Path__namespace.isAbsolute(asset))
      asset = Path__namespace.resolve(process.cwd(), asset);
    const stat = await FS__namespace.promises.stat(asset);
    let assetFilename = asset;
    if (stat.isFile()) {
      const {stderr} = await Util__namespace.promisify(CP__namespace.exec)(`tar -tzf  ${quote(asset)}`);
      if (stderr.trim().length > 0) {
        throw new Exception("InvalidArchive", stderr);
      }
    } else if (stat.isDirectory()) {
      const pkg = await importJSON(Path__namespace.resolve(asset, "package.json"));
      assetFilename = Path__namespace.resolve(asset, `${pkg.name}-${pkg.version}.tgz`.replace("@", "").replace("/", "-"));
      const cmd = `npm pack`;
      console.log(chalk__default["default"].gray(chalk__default["default"].bold("Execute (localhost): "), cmd));
      const {stderr} = await Util__namespace.promisify(CP__namespace.exec)(cmd, {
        env: __spreadProps(__spreadValues({}, process.env), {COPYFILE_DISABLE: "true"}),
        cwd: asset
      });
      if (stderr.trim().length > 0) {
        throw new Exception("InvalidArchive", stderr);
      }
    }
    const release = {
      id: this.app.releases.length > 0 ? this.app.releases[0].id + 1 : 1,
      commit: options.commit,
      tag: options.tag,
      createdAt: getCreatedAt()
    };
    return this.withManifestSync(async () => {
      await this.sh.upload(assetFilename, Path__namespace.join(this.appDir, "releases", `v${release.id}.tar.gz`));
      this.log(`Create release v${release.id} from ${this.app.repository}/commit/${release.commit} (version: ${release.tag})`);
      this.app.releases.unshift(release);
      return release;
    });
  }
  log(line) {
    this.app.changelog.push({
      info: `${OS__namespace.userInfo().username}@${OS__namespace.hostname()}`,
      message: line,
      timestamp: getCreatedAt()
    });
  }
  async setEnv(env) {
    Object.keys(env).forEach((key) => {
      if (!/^[a-z][a-z0-9_]*$/i.test(key))
        throw new Exception("InvalidEnvironmentVariableName", `Invalid characters in environment variable name: ${key}`);
    });
    return this.withManifestSync(async () => {
      this.app.env = Array.from(new Set([...this.app.env, ...Object.keys(env)]));
      await this.sh.exec(Object.entries(env).map(([key, value]) => {
        return `sed -i ${quote(`s/^${key}=.*$//g`)} ${this.appDir}/.envsed -i 's/^$/d' ${this.appDir}/.env
echo ${key}=${quote(value)} >> ${this.appDir}/.env`;
      }).join("\n"));
    });
  }
  async instances() {
    return this.app.deployments.current;
  }
  async getInstance(instanceId) {
    return this.app.deployments.current.find((instance) => instance.id === instanceId);
  }
  async getInstancesByReleaseId(releaseId) {
    return this.app.deployments.current.filter((instance) => instance.releaseId === releaseId);
  }
  async getRelease(releaseId) {
    return this.app.releases.find((release) => release.id === releaseId);
  }
  async getReleasesByTag(tag) {
    return this.app.releases.filter((release) => release.tag === tag);
  }
  async current() {
    const id = this.app.deployments.active;
    if (id != null) {
      return this.app.deployments.current.find((instance) => instance.id === id);
    }
  }
  async createInstance(releaseId) {
    const release = this.app.releases.find((release2) => release2.id);
    if (release == null)
      throw new Exception("UnknownRelease", `Cannot find release v${releaseId}`);
    return this.withManifestSync(async () => {
      const id = uuid();
      const usedPorts = this.app.deployments.current.map((instance2) => instance2.internal.port);
      usedPorts.sort((a, b) => a - b);
      let port = 3e3;
      for (const usedPort of usedPorts) {
        if (usedPort > port)
          break;
        port++;
      }
      const directory = `${this.appDir}/instances/${id}`;
      const logs = `/var/log/${this.app.name}/${id}.log`;
      const errors = `/var/log/${this.app.name}/${id}-error.log`;
      const instance = {
        id,
        releaseId,
        preview: `https://preview-${id}.${this.app.domain.primary}/`,
        createdAt: getCreatedAt(),
        internal: {
          directory,
          port,
          logs,
          errors
        }
      };
      const artefact = `${this.appDir}/releases/v${releaseId}.tar.gz`;
      if (!await this.sh.exists(artefact)) {
        throw new Exception("MissingReleaseArtefact", `Cannot find artefact for release v${releaseId}`);
      }
      const supervisorFile = `/etc/supervisor/conf.d/${this.app.name}-${id}.conf`;
      const supervisorConfig = [
        `[program:${this.app.name}-${id}]`,
        `directory=${directory}/package`,
        `command=bash -c "set -a; source ${this.appDir}/.env; set +a; n auto; npm install --prod; npm start"`,
        `stderr_logfile=${logs}`,
        `stdout_logfile=${errors}`,
        `user=appuser`,
        `stopasgroup=true`
      ].join("\n") + "\n";
      const nginxFile = `/etc/nginx/sites-enabled/${instance.id}.${this.app.domain.primary}.conf`;
      const nginxConfig = [
        `upstream ${this.app.name}-${instance.id} {`,
        `  server 127.0.0.1:${port};`,
        `  keepalive 64;`,
        `}`,
        `server {`,
        `  listen 80;`,
        `  server_name preview-${instance.id}.${this.app.domain.primary};`,
        `  return 301 https://$host$request_uri;`,
        `}`,
        `server {`,
        `  listen 443 ssl;`,
        `  server_name preview-${instance.id}.${this.app.domain.primary};`,
        `  ssl_certificate /etc/letsencrypt/live/${this.app.domain.primary}/fullchain.pem;`,
        `  ssl_certificate_key /etc/letsencrypt/live/${this.app.domain.primary}/privkey.pem;`,
        `  include /etc/deploy/nginx/options-ssl.conf;`,
        `  location / {`,
        `    proxy_redirect     off;`,
        `    proxy_set_header   X-Real-IP          $remote_addr;`,
        `    proxy_set_header   X-Forwarded-For    $proxy_add_x_forwarded_for;`,
        `    proxy_set_header   X-Forwarded-Proto  $scheme;`,
        `    proxy_set_header   Host               $http_host;`,
        `    proxy_set_header   X-NginX-Proxy      true;`,
        `    proxy_set_header   Connection         "";`,
        `    proxy_http_version 1.1;`,
        `    proxy_pass         http://${this.app.name}-${instance.id};`,
        `  }`,
        `}`
      ].join("\n") + "\n";
      this.app.deployments.current.push(instance);
      this.app.deployments.history.unshift({
        active: this.app.deployments.active,
        deployments: this.app.deployments.current.map((instance2) => instance2.id),
        createdAt: getCreatedAt()
      });
      this.app.deployments.history = this.app.deployments.history.slice(0, this.app.config.maxDeploymentHistory);
      await this.sh.exec([
        `type n || npm install --global n`,
        `mkdir -p ${quote(Path__namespace.dirname(logs))}`,
        `mkdir -p ${quote(directory)}`,
        `tar -zxf ${quote(artefact)} -C ${quote(directory)}`,
        `cat <<- 'EOF' > ${quote(supervisorFile)}
${supervisorConfig}
EOF
`,
        `cat <<- 'EOF' > ${quote(nginxFile)}
${nginxConfig}
EOF
`,
        `supervisorctl reread`,
        `supervisorctl update`,
        `nginx -t`
      ].join("\n"));
      await this.createCertificates();
      await this.sh.exec("service nginx reload");
      this.log(`Create new app instance ${quote(instance.id)} from release v${releaseId}.`);
      return instance;
    });
  }
  async start(instanceId) {
    await this.withManifestSync(async () => {
      this.log(`Start app instance ${this.app.name}-${instanceId}`);
      await this.sh.exec(`supervisorctl start ${this.app.name}-${instanceId}`);
    });
  }
  async restart(instanceId) {
    await this.withManifestSync(async () => {
      this.log(`Restart app instance ${this.app.name}-${instanceId}`);
      await this.sh.exec(`supervisorctl restart ${this.app.name}-${instanceId}`);
    });
  }
  async status(instanceId) {
    return await this.withManifestSync(async () => {
      this.log(`Status app instance ${this.app.name}-${instanceId}`);
      const statusText = await this.sh.execNoFail(`supervisorctl status ${this.app.name}-${instanceId}`);
      if (statusText != null) {
        const match = /^[\S]+\s+([\S]+)\s+(.*)$/i.exec(statusText.trim());
        return match == null ? {status: "UNKNOWN", text: statusText} : {status: match[1], text: statusText};
      }
      return {status: "SSH_ERROR", text: "Error in SSH command."};
    });
  }
  async stop(instanceId) {
    await this.withManifestSync(async () => {
      this.log(`Stop app instance ${this.app.name}-${instanceId}`);
      await this.sh.exec(`supervisorctl stop ${this.app.name}-${instanceId}`);
    });
  }
  async destroyRelease(releaseId) {
    await this.withManifestSync(async () => {
      const release = await this.getRelease(releaseId);
      if (release == null) {
        throw new Exception("UnknownRelease", `There is no such release.`);
      }
      const instances = await this.instances();
      const matchedInstances = instances.filter((instance) => instance.releaseId === releaseId);
      if (matchedInstances.length > 0) {
        throw new Exception("ReleaseInUse", `There are ${matchedInstances.length} active instance(s).`);
      }
      this.app.releases = this.app.releases.filter((release2) => release2.id !== releaseId);
      await this.sh.exec(`
        rm -f ${quote(`${this.appDir}/releases/v${release.id}.tar.gz`)};
      `);
      this.log(`Delete release v${release.id}`);
    });
  }
  async destroyInstance(instanceId) {
    const supervisorFile = `/etc/supervisor/conf.d/${this.app.name}-${instanceId}.conf`;
    const nginxFile = `/etc/nginx/sites-enabled/${instanceId}.${this.app.domain.primary}.conf`;
    await this.withManifestSync(async () => {
      const instance = await this.getInstance(instanceId);
      const instances = await this.instances();
      if (instance == null)
        throw new Exception("UnknownAppInstance", `No such instance: ${instanceId}`);
      this.app.deployments.current = instances.filter((instance2) => instance2.id !== instanceId);
      this.app.deployments.history.push(this.createHistoryItem());
      await this.sh.exec(`
        rm -f ${quote(supervisorFile)};
        rm -f ${quote(nginxFile)};
        rm -rf ${quote(instance.internal.directory)};
        supervisorctl reread;
        supervisorctl update;
        service nginx reload;
      `);
      this.log(`Destroy app instance ${this.app.name}-${instanceId}`);
    });
  }
  createHistoryItem() {
    return {
      active: this.app.deployments.active,
      deployments: this.app.deployments.current.map((instance) => instance.id),
      createdAt: getCreatedAt()
    };
  }
  async logs(instanceId) {
    throw new Error("Unimplemented");
  }
  async deploy(instanceId) {
    const instance = await this.getInstance(instanceId);
    if (instance == null)
      throw new Exception("UnknownAppInstance");
    return await this.withManifestSync(async () => {
      this.app.deployments.active = instanceId;
      const historyItem = this.createHistoryItem();
      const config = [
        `server {`,
        `  listen 80;`,
        `  server_name ${this.app.domain.primary} ${this.app.domain.aliases.join(" ")};`,
        `  return 301 https://$host$request_uri;`,
        `}`,
        `server {`,
        `  listen 443 ssl;`,
        `  server_name ${this.app.domain.primary} ${this.app.domain.aliases.join(" ")};`,
        `  ssl_certificate /etc/letsencrypt/live/${this.app.domain.primary}/fullchain.pem;`,
        `  ssl_certificate_key /etc/letsencrypt/live/${this.app.domain.primary}/privkey.pem;`,
        `  include /etc/deploy/nginx/options-ssl.conf`,
        `  location / {`,
        `    proxy_redirect     off;`,
        `    proxy_set_header   X-Real-IP          $remote_addr;`,
        `    proxy_set_header   X-Forwarded-For    $proxy_add_x_forwarded_for;`,
        `    proxy_set_header   X-Forwarded-Proto  $scheme;`,
        `    proxy_set_header   Host               $http_host;`,
        `    proxy_set_header   X-NginX-Proxy      true;`,
        `    proxy_set_header   Connection         "";`,
        `    proxy_http_version 1.1;`,
        `    proxy_pass         http://${this.app.name}-${instance.id};`,
        `  }`,
        `}`
      ].join("\n") + "\n";
      await this.sh.exec([
        `cat <<- 'EOF' > /etc/nginx/sites-enabled/${this.app.name}.conf
${config}
EOF
`,
        `service nginx reload`
      ].join("\n") + "\n");
      return historyItem;
    });
  }
  async rollback() {
    if (this.app.deployments.history.length === 0)
      throw new Exception("NoHistoryFound");
    const lastVersion = this.app.deployments.history[0].active;
    if (lastVersion == null)
      throw new Exception("NoDeploymentFound");
    const instance = await this.getInstance(lastVersion);
    if (instance == null)
      throw new Exception("NoDeploymentFound");
    this.log(`Rollback from ${quote(this.app.deployments.active ?? "none")} to ${quote(instance.id)}`);
    return await this.deploy(lastVersion);
  }
};
var SSHClient = class {
  constructor(server) {
    this.binSSH = process.env.SSH_BIN_PATH ?? "/usr/bin/ssh";
    this.binSCP = process.env.SCP_BIN_PATH ?? "/usr/bin/scp";
    this.server = __spreadValues({
      port: 22,
      user: "root",
      privateKey: "~/.ssh/id_rsa",
      appsDirectory: "/apps"
    }, server);
    if (process.env.DEPLOYER_SSH_KEY != null) {
      this.server.privateKey = Path__namespace.resolve(OS__namespace.tmpdir(), "deployer", Date.now() + ".pem");
      FS__namespace.mkdirSync(Path__namespace.dirname(this.server.privateKey), {recursive: true});
      FS__namespace.writeFileSync(this.server.privateKey, process.env.DEPLOYER_SSH_KEY, {mode: 384, encoding: "utf8"});
    }
  }
  async ls(expr) {
    const output = await this.exec(`find ${quote(expr)} -mindepth 1 -maxdepth 1 -type d`);
    const lines = output.trim().split(/\r?\n/);
    return lines.map((line) => line.trim());
  }
  async mkdir(path) {
    await this.exec(`mkdir -p ${quote(path)}`);
  }
  async exists(file) {
    const result = (await this.exec(`
      test -f ${quote(file)} && echo 'file'  || echo ''
      test -d ${quote(file)} && echo 'dir'   || echo ''
      `)).trim();
    return result === "file" || result === "dir";
  }
  async read(file) {
    if (await this.exists(file)) {
      const output = await this.exec(`cat ${quote(file)}`);
      return output;
    }
    throw new FileNotFoundException(file);
  }
  async write(file, contents) {
    console.debug(chalk__default["default"].gray(`Writing file: ${chalk__default["default"].bold(file)}`));
    await this.exec(`cat <<- EOF > ${quote(file)}
${contents}
EOF
`);
  }
  async readJSON(file) {
    return JSON.parse(await this.read(file));
  }
  async upload(localFile, remoteFile) {
    try {
      console.debug(chalk__default["default"].gray(chalk__default["default"].bold(`Upload (${this.server.host}): `), localFile, " to ", remoteFile));
      const {stdout, stderr} = await Util__namespace.promisify(CP__namespace.exec)(`${this.binSCP} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -q -i ${quote(this.server.privateKey)} -P ${this.server.port} ${quote(localFile)} ${this.server.user}@${this.server.host}:${quote(remoteFile)}`);
      if (stderr !== "")
        console.error(chalk__default["default"].red(stderr));
      if (stdout !== "")
        console.log(chalk__default["default"].gray(stdout));
    } catch (error) {
      throw new Exception("SCPError", error.message);
    }
  }
  async exec(script) {
    try {
      console.debug(chalk__default["default"].gray(chalk__default["default"].bold(`Execute (${this.server.host}): `), script));
      const boundary = `END_OF_SCRIPT_${Date.now()}`;
      const outputBoundary = `-------------SSH-OUTPUT-----`;
      const {stdout, stderr} = await Util__namespace.promisify(CP__namespace.exec)(`${this.binSSH} -T -q -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ${quote(this.server.privateKey)} -p ${this.server.port} ${this.server.user}@${this.server.host} <<'${boundary}'
echo ${quote(outputBoundary)};
` + script + "\n" + boundary + "\n");
      if (stderr !== "")
        console.error(chalk__default["default"].red(stderr));
      const index = stdout.indexOf(outputBoundary);
      if (index >= 0)
        return stdout.substr(index + outputBoundary.length + 1);
      return stdout;
    } catch (error) {
      throw new Exception("SCPError", error.message);
    }
  }
  async execNoFail(script) {
    try {
      return await this.exec(script);
    } catch {
      return null;
    }
  }
};
var DeploymentManager = class {
  constructor(server) {
    this.server = server;
    this.appsDir = this.server.appsDirectory ?? "/apps";
    this.sh = new SSHClient(this.server);
  }
  async info() {
    const node = await this.sh.execNoFail(`node --version`);
    const npm = await this.sh.execNoFail(`npm --version`);
    const tar = await this.sh.execNoFail(`tar --version`);
    const nginx = await this.sh.execNoFail(`nginx -v 2>&1`);
    const curl = await this.sh.execNoFail(`curl --version`);
    const user = await this.sh.execNoFail(`id -u appuser`);
    const supervisor = await this.sh.execNoFail(`supervisord --version`);
    const certbot = await this.sh.execNoFail(`certbot --version`);
    return {node, npm, tar, nginx, curl, user, certbot, supervisor};
  }
  async apps() {
    if (await this.sh.exists(this.appsDir)) {
      const files = await this.sh.ls(this.appsDir);
      const prefixLength = this.appsDir.length + 1;
      return files.map((file) => file.substr(prefixLength));
    }
    return [];
  }
  async connect(app) {
    try {
      const manifestFile = `${this.appsDir}/${app}/deploy.json`;
      const manifest = await this.sh.readJSON(manifestFile);
      return new AppManager(manifest, manifestFile, this.sh);
    } catch (error) {
      if (error instanceof FileNotFoundException) {
        throw new Exception("AppNotFound", `No such app: ${quote(app)}`);
      }
      throw error;
    }
  }
  async create(options) {
    if (await this.sh.exists(`${this.appsDir}/${options.name}/deploy.json`)) {
      throw new Exception("DuplicateApp", `Another app with name (${quote(options.name)}) already exists.`);
    }
    const manifest = {
      name: options.name,
      repository: options.repository ?? "",
      domain: {
        email: options.email ?? `certbot-notif@${options.domain}`,
        primary: options.domain,
        aliases: options.domainAliases ?? []
      },
      healthcheck: options.healthcheck ?? "curl -sSf http://localhost:${PORT}/health",
      releases: [],
      deployments: {
        current: [],
        history: []
      },
      changelog: [],
      config: {
        maxReleases: options.maxReleases ?? 10,
        maxDeploymentHistory: options.maxDeploymentHistory ?? 100
      },
      env: []
    };
    await this.check();
    await this.sh.mkdir(`/apps/${manifest.name}`);
    await this.sh.mkdir(`/apps/${manifest.name}/releases`);
    await this.sh.mkdir(`/apps/${manifest.name}/deployments`);
    await this.sh.write(`/apps/${manifest.name}/.env`, ``);
    await this.sh.write(`/apps/${manifest.name}/deploy.json`, JSON.stringify(manifest, null, 2));
    const connection = await this.connect(manifest.name);
    await connection.createCertificates();
    return connection;
  }
  async check() {
    const tools = Object.entries(await this.info()).filter(([_, version]) => version == null).map(([tool]) => tool);
    if (tools.length > 0) {
      throw new Exception("UnsupportedServer", `Missing required programs: ${tools.join(", ")}`);
    }
  }
};
exports.AppManager = AppManager;
exports.DeploymentManager = DeploymentManager;
exports.Exception = Exception;
exports.SSHClient = SSHClient;
exports.importJSON = importJSON;
exports.quote = quote;
//# sourceMappingURL=DeploymentManager-5b85d527.js.map
